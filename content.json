{"meta":{"title":"Binisalegend的博客","subtitle":"","description":"","author":"Binisalegend","url":"https://binisalegend.github.io","root":"/"},"pages":[],"posts":[{"title":"CS61A学习笔记","slug":"CS61A学习笔记","date":"2023-11-08T02:40:09.000Z","updated":"2023-11-08T03:32:44.884Z","comments":true,"path":"2023/11/08/CS61A学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/CS61A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本文是伯克利CS61A课程的配套学习笔记","text":"本文是伯克利CS61A课程的配套学习笔记 Lecture 3 : Control（函数控制）HW01 : Variables &amp; Functions, Control 可以给函数重新命名，或者理解为将一个函数的功能赋给另一个函数123456789from operator import add, sub def a_plus_abs_b(a, b): &quot;&quot;&quot;Return a+abs(b), but without calling abs.&quot;&quot;&quot; if b &gt;= 0: h = add else: h = sub return h(a, b) 这个理解不了一点，不知道那个with_if_statement干啥用的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def if_function(condition, true_result, false_result): &quot;&quot;&quot;Return true_result if condition is a true value, and false_result otherwise. &gt;&gt;&gt; if_function(True, 2, 3) 2 &gt;&gt;&gt; if_function(False, 2, 3) 3 &gt;&gt;&gt; if_function(3==2, 3+2, 3-2) 1 &gt;&gt;&gt; if_function(3&gt;2, 3+2, 3-2) 5 &quot;&quot;&quot; if condition: return true_result else: return false_result def with_if_statement(): &quot;&quot;&quot; &gt;&gt;&gt; result = with_if_statement() 47 &gt;&gt;&gt; print(result) None &quot;&quot;&quot; if cond(): return true_func() else: return false_func() def with_if_function(): &quot;&quot;&quot; &gt;&gt;&gt; result = with_if_function() 42 47 &gt;&gt;&gt; print(result) None &quot;&quot;&quot; return if_function(cond(), true_func(), false_func()) def cond(): &quot;*** YOUR CODE HERE ***&quot; return False def true_func(): &quot;*** YOUR CODE HERE ***&quot; print(42) def false_func(): &quot;*** YOUR CODE HERE ***&quot; print(47) def定义一个函数，如果给这个函数调用赋予变量名，系统只会打印定义该变量过程中的print，而不会返回return值，需要再次调用变量才会打印return；而如果不给函数调用赋予变量名，则视为直接计算函数值也会打印return值123456789101112def hailstone(x): print(x) cnt = 1 while x != 1: cnt += 1 if x % 2 == 0: x = x // 2 print(x) else: x = x * 3 + 1 print(x) return cnt ![[Pasted image 20230710114432.png]] Lab01: Variables &amp; Functions, Control 一些OK常用语句： 在输出行前打“DEBUG:”可以避免误识别print内容 python3 ok -q sum_digits -i 和 python3 ok -q sum_digits -trace没弄清楚啥意思，再摸索摸索（bushi python3 -q doctest &lt;文件名&gt; 可以运行程序中的测试 for i in range n: 语句表示从i到n-1，意思是包含i，但不包含n。字面意思，区分一下 Lecture 4:Higher-Order Functions（高阶函数）function example: sound 利用python进行三角波的形成和输出、整合，验证高级函数实用性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from wave import open from struct import Struct from math import floor frame_rate = 11025 def encode(x): &quot;&quot;&quot;Encode float x between -1 and 1 as two bytes. (See https://docs.python.org/3/library/struct.html)&quot;&quot;&quot; i = int(16384 * x) return Struct(&#x27;h&#x27;).pack(i) def play(sampler, name=&#x27;song.wav&#x27;, seconds=2): &quot;&quot;&quot;Write the output of a sampler function as a wav file. (See https://docs.python.org/3/library/wave.html) &quot;&quot;&quot; out = open(name, &#x27;wb&#x27;) out.setnchannels(1) out.setsampwidth(2) out.setframerate(frame_rate) t = 0 while t &lt; seconds * frame_rate: sample = sampler(t) out.writeframes(encode(sample)) t = t + 1 out.close() def tri(frequency, amplitude=0.3): &quot;&quot;&quot;A continuous triangle wave.&quot;&quot;&quot; period = frame_rate // frequency def sampler(t): saw_wave = t / period - floor(t / period + 0.5) tri_wave = 2 * abs(2 * saw_wave) - 1 return amplitude * tri_wave return sampler c_freq, e_freq, g_freq = 261.63, 329.63, 392.00 def both(f,g): return lambda t: f(t) + g(t) def note(f,start,end,fade=0.1): def sampler(t): seconds = t / frame_rate if seconds &lt; start: return 0 elif seconds &gt; end: return 0 elif seconds &lt; start + fade: return (seconds - start) / fade * f(t) elif seconds &gt; end - fade: return (end - seconds) / fade * f(t) else: return f(t) return sampler def mario_at(octave): c = tri(octave * c_freq) e = tri(octave * e_freq) g = tri(octave * g_freq) low_g = tri(octave * g_freq / 2) return mario(c, e, g, low_g) # c,e = tri(c_freq),tri(e_freq) # g,low_g = tri(g_freq),tri(g_freq/2) def mario(c, e, g, low_g): z = 0 song = note(e, z, z + 1/8) z += 1/8 song = both(song, note(e, z, z + 1/8)) z += 1/4 song = both(song, note(e, z, z + 1/8)) z += 1/4 song = both(song, note(c, z, z + 1/8)) z += 1/8 song = both(song, note(e, z, z + 1/8)) z += 1/4 song = both(song, note(g, z, z + 1/4)) z += 1/2 song = both(song, note(low_g, z, z + 1/4)) return song # play(both(note(c,0,1/4),note(e,1/2,1))) play(both(mario_at(1),mario_at(1/2))) # play(both(mario_at(1), mario_at(1/2))) Function Composition123456789101112131415def make_adder(n): def adder(k): return k + n return adder def square(x): return x * x def triple(x): return 3 * x def compose1(f,g): def h(x): return f(g(x)) return h Function Currying[[#^2f1599]] [[#^ecfc38]] 柯里化是一种将接受多个参数的函数转换为接受单个参数的函数序列的技术。1234567#应用def函数进行curryingdef curry2(f): def g(x): def h(y): return f(x,y) return h return g 123#应用lambda函数进行curryingdef curry1(f): return lambda x : lambda y : f(x,y) HW02 : Higher-Order Functions base和term()应用combiner算法进行计算时受到计算顺序的影响，不能任意调换顺序 ！记得考虑特殊情况1234567891011121314151617181920212223242526272829def accumulate(combiner, base, n, term): &quot;&quot;&quot;Return the result of combining the first n terms in a sequence and base. The terms to be combined are term(1), term(2), ..., term(n).combiner is a two-argument commutative function. &gt;&gt;&gt; accumulate(add, 0, 5, identity) # 0 + 1 + 2 + 3 + 4 + 5 15 &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5 26 &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 11 &gt;&gt;&gt; accumulate(add, 11, 3, square) # 11 + 1^2 + 2^2 + 3^2 25 &gt;&gt;&gt; accumulate(mul, 2, 3, square) # 2 * 1^2 * 2^2 * 3^2 72 &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square) 19 &gt;&gt;&gt; accumulate(lambda x, y: 2 * (x + y), 2, 3, square) 58 &gt;&gt;&gt; accumulate(lambda x, y: (x + y) % 17, 19, 20, square) 16 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if n != 0: x, loc = 2, combiner(base,term(1)) while x &lt;= n: loc = combiner(loc, term(x)) x += 1 print(loc) else: print(base) 应用accumulate函数用print函数会多打印一个None，用return就没问题1234def summation_using_accumulate(n, term): y = accumulate(add,0,n,term) return y &quot;&quot;&quot;print(y)&quot;&quot;&quot; sub是减，mul是乘… 返回值可以是函数，在compose1函数中的f(x)调用可以不指明 for循环中可以自动赋给未定义变量值为0，while循环不行123456789101112131415161718192021222324252627def compose1(func1, func2): &quot;&quot;&quot;Return a function f, such that f(x) = func1(func2(x)).&quot;&quot;&quot; def f(x): return func1(func2(x)) return f def make_repeater(func, n): &quot;&quot;&quot;Return the function that computes the nth application of func. &gt;&gt;&gt; add_three = make_repeater(increment, 3) &gt;&gt;&gt; add_three(5) 8 &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1 243 &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5)) 625 &gt;&gt;&gt; make_repeater(square, 4)(5) # square(square(square(square(5)))) 152587890625 &gt;&gt;&gt; make_repeater(square, 0)(5) # Yes, it makes sense to apply the function zero times! 5 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; f = func if n == 0: return identity for i in range(n-1): f = compose1(func, f) return f Lecture 5:Environment Diagrams（程序环境示意图）Environments for Higher-Order Functions12345def apply_twice(f,x): return f(f(x)) def square(x): return x * x Higher-Order Function Example:Repeat1234567def repeat(f,x): while f(x) != x: x = f(x) return x def g(y): return (y + 5) // 3 Environments for Nested Definitions 1234def make_adder(n): def adder(k): return k + n return adder 每一个创建的函数，它自身在哪个框架中创建，他的母函数就是那个框架的函数，在寻找变量值时，沿母函数层层向上搜寻知道全局框架，最先搜索到的值便是函数调用的值[[#^a02dcd]] Local Names 在嵌套定义中，母函数的形参可以在子函数中使用；而在相对独立的函数定义中一个函数无法找到和调用在另一个函数中定义的形参。 Lambda Expressions1. lambda表达式相关 lambda表达式是一个计算结果可以用某种方式解释的函数的表达式，当square被定义为“x * x”时，square仅仅作为一个数值存在；而当square被定义为一个关于x的lambda函数，它变成了一个具有具体调用地址的函数（甚至可以不定义lambda返回函数的名称而直接赋予形参具体值） lambda：A function with formal parameter x that returns the value of “x * x” No Return!!! 只能将单个表达式作为lambda函数的主体 2. lambda与def定义函数的区别 使用lambda定义时函数名为”lambda“形式的函数，而def语句定义函数名则为编程者赋予的函数名称，如下： Self-Reference12345def print_sums(x): print(x) def next_sum(y): return print_sums(x + y) return next_sum (好难解释md)第一次调用的参数是1-&gt;n,打印1，定义next_sum函数，调用3-&gt;k，这时第一次调用的print_sums函数返回next_sum函数，而next_sum函数返回print_sums(n+k–&gt;1+3)，即返回print_sums(4)，然后先打印4… Lab02: Higher-Order Functions, Lambda Expressions, Self ReferenceQ1: WWPD Lambda the Free 这个是真整体不咋理解，感觉没明白函数定义和返回，让我们过会来求助一波chatGPT老师（bushi）123456789101112131415161718192021222324252627282930&gt;&gt;&gt; def cake():... print(&#x27;beets&#x27;) ... def pie():... print(&#x27;sweets&#x27;) ... return &#x27;cake&#x27; ... return pie &gt;&gt;&gt; chocolate = cake()beets&gt;&gt;&gt; chocolateFunction&gt;&gt;&gt; chocolate()sweets&#x27;cake&#x27;&gt;&gt;&gt; more_chocolate, more_cake = chocolate(), cakesweets&gt;&gt;&gt; more_chocolate&#x27;cake&#x27;&gt;&gt;&gt; def snake(x, y): ... if cake == more_cake: ... return chocolate ... else: ... return x + y &gt;&gt;&gt; snake(10, 20)Function&gt;&gt;&gt; snake(10, 20)()sweets&#x27;cake&#x27;&gt;&gt;&gt; cake = &#x27;cake&#x27; &gt;&gt;&gt; snake(10, 20)30 感觉这个和上面那个例子有点异曲同工，就是定义变量名并且调用函数就会返回return值，但变量名没任何用好像（）（啊看不懂看不懂学不明白烦死了）123456&gt;&gt;&gt; onethousand = print_lambda(1000)1000&gt;&gt;&gt; onethousand&gt;&gt;&gt;&gt;&gt;&gt; print_lambda&lt;function &lt;lambda&gt; at 0x000001752468AE60&gt; Q3: Lambdas and Currying 哇！感觉头一次发现到lambda到底是干嘛用的（一直觉得是个摆设），暂时的理解是用来调用未定义的参数（def和lambda如下） 应用def调用： 123456def lambda_curry2(func): def function1(x): def function2(y): return func(x,y) return function2 return function1 应用lambda调用： 12def lambda_curry2(func): return lambda x : lambda y : func(x , y) ^2f1599 Q4: Count van Count 单纯觉得这个求质数的方法很有启发性，算是第一次让我对函数封装有了相对具体的认识吧… 就是先用count_factors函数计算出某个数的公约数，然后调用count_primes函数计算在n之内的所有质数的个数，其中调用is_prime函数利用count_factors函数判定是否符合质数条件（只有两个公约数）123456789101112131415161718192021222324252627282930def count_factors(n): &quot;&quot;&quot;Return the number of positive factors that n has. &gt;&gt;&gt; count_factors(6) 4 # 1, 2, 3, 6 &gt;&gt;&gt; count_factors(4) 3 # 1, 2, 4 &quot;&quot;&quot; i, count = 1, 0 while i &lt;= n: if n % i == 0: count += 1 i += 1 return count def count_primes(n): &quot;&quot;&quot;Return the number of prime numbers up to and including n. &gt;&gt;&gt; count_primes(6) 3 # 2, 3, 5 &gt;&gt;&gt; count_primes(13) 6 # 2, 3, 5, 7, 11, 13 &quot;&quot;&quot; i, count = 1, 0 while i &lt;= n: if is_prime(i): count += 1 i += 1 return count def is_prime(n): return count_factors(n) == 2 # only factors are 1 and n 暂时粗浅理解一下函数式编程吧，就是主函数的返回值尽可能都是一个函数，而调用一个主函数定义中没有显示的参数就要应用def或者lambda语句调用12345678910111213141516171819202122232425262728293031323334353637 &quot;&quot;&quot;Returns a function with one parameter N that counts all the numbers from 1 to N that satisfy the two-argument predicate function Condition, where the first argument for Condition is N and the second argument is the number from 1 to N. &gt;&gt;&gt; count_factors = count_cond(lambda n, i: n % i == 0) &gt;&gt;&gt; count_factors(2) # 1, 2 2 &gt;&gt;&gt; count_factors(4) # 1, 2, 4 3 &gt;&gt;&gt; count_factors(12) # 1, 2, 3, 4, 6, 12 6 &gt;&gt;&gt; is_prime = lambda n, i: count_factors(i) == 2 &gt;&gt;&gt; count_primes = count_cond(is_prime) &gt;&gt;&gt; count_primes(2) # 2 1 &gt;&gt;&gt; count_primes(3) # 2, 3 2 &gt;&gt;&gt; count_primes(4) # 2, 3 2 &gt;&gt;&gt; count_primes(5) # 2, 3, 5 3 &gt;&gt;&gt; count_primes(20) # 2, 3, 5, 7, 11, 13, 17, 19 8 &quot;&quot;&quot;def count_cond(condition): return lambda x: sum(1 for y in range(1, x+1) if condition(x, y))#这种方式用lambda函数，将condition(x,y)作为参数传给lambda，lambda函数接收一个参数x，然后使用range(1, x+1)生成从1到x的数字，对于每个数字y，如果满足条件condition(x, y)，则计数加1。最后，返回计数结果的总和。def count_cond(condition): def count_f(x): i,count = 1,0 while i &lt; x: if condition(x,i): count += 1 i += 1 return count return count_f#这种方式用def定义函数(个人认为更好理解一点)，注意返回值还是要一个函数而不是直接count（报错：NoneType那个） ^ecfc38 Q5: Both Paths 关于局部变量(nonlocal)和全局变量(global) 全局变量和局部变量（global和nonlocal）1234567g = 0 def global_test(): #global g g += 1 print(g)&gt;&gt;&gt; global_test&gt;&gt;&gt; UnboundLocalError: local variable &#x27;gcount&#x27; referenced before assignment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733~~~pythondef make_counter(): count = 0 def counter(): nonlocal count count += 1 return count return counter def make_counter_test(): mc = make_counter() print(mc()) print(mc()) print(mc()) make_counter_test()~~~ ```nonlocal```声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量。- python可以设定给一个参数默认值，当该参数调用时没有值则按默认值计算，若有值输入则按输入值，例：~~~pythondef root(x, degree=2): &quot;&quot;&quot;For example &gt;&gt;&gt; root(64) 8 &gt;&gt;&gt; root(64, 3) 4 &quot;&quot;&quot; return x ** (1 / degree)~~~- [ ] 这个...真不知道该说啥，就是说一整个没看懂好吧，最后感觉上是emmmm就是往S后面加U&amp;D？~~~pythondef both_paths(sofar=&quot;S&quot;): &quot;&quot;&quot; &gt;&gt;&gt; up, down = both_paths() S &gt;&gt;&gt; upup, updown = up() SU &gt;&gt;&gt; downup, downdown = down() SD &gt;&gt;&gt; _ = upup() SUU &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; upsofar = sofar downsofar = sofar def up(): nonlocal upsofar upsofar += &#x27;U&#x27; print(upsofar) return up, up def down(): nonlocal downsofar downsofar += &#x27;D&#x27; print(downsofar) return down , down print(sofar) return up,down~~~### Q7: Lambda the Environment Diagram- [ ] 这个也理解不了一点呢~真好呢（精神状态逐渐扭曲xie），就从f3 21就看不懂了哭...~~~pythona = lambda x: 2 * x + 1def b(b,x): return b(x + a(x))&gt;&gt;&gt; x = 3&gt;&gt;&gt; b(a,x)&gt;&gt;&gt; 21~~~![](./CS61A学习笔记/Pasted%20image%2020230712213717.png)### Q8: Composite Identity Function- 这个函数名已经足够反映我此时的心理状态了好吧...就是要调用函数调用函数，不能直接返回个值，不管是什么类型，都要先定义个函数和他的返回值，再返回那个函数~~~pythondef composite_identity(f, g): def xiande(y): if compose1(f,g)(y) == compose1(g,f)(y): return True else: return False return xiande~~~### Q9: I Heard You Liked Functions...- 好帅的递归，但不会(注意最后总函数的返回值缩进) 小小总结一下：就是这种1.2.3.1.2.3...类型的循环好像都可以用这种类型的递归，即定义一个函数（如本题的conmpose1），然后函数参数分别为当前值和下一个函数值，即```compose1(f2,cycle_f(n-1))```这种形式，之后再试试呐~~~~pythondef cycle(f1, f2, f3): def cycle_f(n): if n == 0: return lambda x : x elif n % 3 == 1: return compose1(f1,cycle_f(n-1)) elif n % 3 == 2: return compose1(f2,cycle_f(n-1)) else: return compose1(f3,cycle_f(n-1)) return cycle_f~~~## *Midterm1 Review*- ```print```函数始终返回```None```，在它被当作函数调用时同时输出他的参数（以空格分开）![](./CS61A学习笔记/Pasted%20image%2020230713091350.png)- 一个验证函数在调用参数时总是沿母函数层层相上搜索的例子，如下：我觉得最重要的一步理解就是```pirate```函数里调用的```arggg```是3，而真正应用于返回函数```plunder```的参数实际上是已经定义的```square```函数，因此本质上```add```的第一项就是4的平方![](./CS61A学习笔记/Pasted%20image%2020230713100856.png) ^a02dcd~~~pythonfrom operator import add,muldef square(x): return mul(x,x) def pirate(arggg): print(&#x27;matey&#x27;) def plunder(arggg): return arggg return plunder add(pirate(3)(square)(4),1)~~~## *Decorations*- 好像就是一个可以追踪高级函数运行过程的小玩意，但我的ucb不知道为什么运行不了（好像没装上这个库）~~~pythondef trace(fn): def traced(x): print(&#x27;Calling&#x27;,fn,&#x27;on argument&#x27;,x) return fn(x) return traced @trace def square(x): return x * x @trace def sum_squares_up_to(n): k = 1 total = 0 while k &lt;= n: total,k = total + square(k),k + 1 return total&quot;&quot;&quot;&gt;&gt;&gt; square(2)Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 24&gt;&gt;&gt; sum_squares_up_to(5)Calling &lt;function sum_squares_up_to at 0x0000015003B8AE60&gt; on argument 5Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 1Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 2Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 3Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 4Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 555&quot;&quot;&quot;~~~# Lecture 6: Recursion（递归）## *Recursive functions*- 递归的基本思路：首先具备一个```基本情况(basic case)```，然后在更复杂的函数求解过程中应用自身函数不断简化所求，使其更接近```基本情况(basic case)```~~~python #求各位之和（用递归）def split(n): return n // 10, n % 10 def sum_digits(n): #basic case if n &lt; 10: return n else: all_but_last, last = split(n) return sum_digits(all_but_last) + last~~~## *Recursion in Environment Diagrams*- 对比来看，应用```while```循环需要定义参数来进行跟踪统计，而运用递归则只需要计算机分不同框架来自动区分递归的步骤（参数少） ^5ca33e~~~pythondef fact_iter(n): total, k = 1, 1 while k &lt;= n: total, k = total * k, k + 1 return totaldef fact(n): if n == 0: return 1 else: return n * fact(n-1)~~~## Verifying Recursive Functions&lt;small&gt;老师管做递归叫信仰之跃(The Recursive Leap of Faith)笑死我了哈哈哈哈哈&lt;/small&gt;- 验证递归是否符合要求的步骤：[[#^5ca33e]] 1. Verify the base case. 验证基本情况（确定有一个情况是正确的） 2. Treat``` fact``` as a functional abstraction. 将函数看作一个函数抽象功能，不考虑这个函数如何实施，只考虑它会做什么（好抽象...） 3. Assume that ```fact(n-1)``` is correct. 假设```fact(n)```递归返回的第一个值```fact(n-1)```是正确的 4. Verify that ```fact(n)``` is correct, assuming that ```fact(n-1)``` correct 5. 代代特值（bushi）## *Mutual Recursion*### &lt;small&gt;Example: The Luhn algorithm&lt;/small&gt;- 感觉需要先给未来1000%看不懂这个例子是啥的我解释一下，就是一个现在国际上很通用的验证一些卡号的方法，具体如下： 1. 从右向左，从最右面第一个数字开始乘一，右起第二个数乘二，第三个数乘三...以此类推 2. 如果经过乘法运算后所得小于十则直接保留，如果大于十就返回其所得值的每位数字之和（如2 * 8 = 16则返回1 + 6 = 7） 3. 将整个号码每位返回值相加并且取10的余数即被称为判定位 ![](./CS61A学习笔记/Pasted%20image%2020230714014717.png)- 所以这个例子应用交互递归的点就在于一位数✖1另一位数✖2，因此需要两个分别为乘一乘二的函数的返回值都是彼此以达到变换效果^756591~~~pythondef split(n): #求前几位和末位 return n // 10, n % 10 def sum_digits(n): #求各位之和，在此示例中用来求*2后超过10的各位之和 if n &lt; 10: return n else: all_but_last, last = split(n) return sum_digits(all_but_last) + last def luhn_sum(n): #乘一的返回值，交互到乘二的函数 if n &lt; 10: return n else: all_but_last,last = split(n) return luhn_sum_double(all_but_last) + last def luhn_sum_double(n): #乘二的返回值，交互到乘一的函数 all_but_last,last = split(n) luhn_digit = sum_digits(2 * last) #超过十各位相加 if n &lt; 10: return luhn_digit else: return luhn_sum(all_but_last) + luhn_digit~~~## *Recursion and Iteration*- 从迭代```while```到递归，由于迭代是一种特殊的递归形式，所以只需要找到在不同迭代步骤中始终维护和保持的状态```n```并将其作为参数 ^afb04a~~~pythondef sum_digits_iter(n): digit_sum = 0 while n &gt; 0: n, last = split(n) digit_sum += last return digit_sum def sum_digits_rec(n,digit_sum): if n == 0: return digit_sum else: n, last = split(n) return sum_digits_rec(n,digit_sum)~~~## *Order of Recursive Calls*- Cascade Function: (级联函数) 这个例子为了证明即在任何一次函数递归中，直到执行其```return```值之前，这个函数递归都不会完成（例如本例中先执行```cascade(n//10)```再```print```）；同时，任何调用都能出现在递归调用之前或者之后；最后，在完成每个递归调用时，从最后一个递归调用逐级向上返回，直到返回第一次函数调用~~~pythondef cascade(n): if n &lt; 10: print(n) else: print(n) cascade(n//10) print(n) def cascade(n): print(n) if n &gt; 10: cascade(n//10) print(n)~~~## *Example: Inverse Cascade*- 打印逆向级联~~~pythondef f_then_g(f,g,n): if n: f(n) g(n) def inverse_cascade(n): grow(n) print(n) shrink(n)grow = lambda n: f_then_g(grow,print,n//10) shrink = lambda n: f_then_g(print,shrink,n//10) ~~~# Lecture 7: Tree Recursion（树递归）&lt;big&gt;树递归即指在某函数内有不止一次的函数递归调用，每个值都能转化为树状的基本结构直接返回对应的值&lt;/big&gt;## *Tree Recursion*~~~pythondef fib(n): #计算斐波那契数列 if n === 0: return 0 elif n == 1: return 1 else: return fib(n-1) +fib(n-2)~~~&lt;small&gt;（由于计算了很多重复值导致运行速度会慢）&lt;/small&gt;## *Example: Paths*&lt;small&gt;判断从一个m行n列的表格一角走向另一个对角有多少种可能的路径&lt;/small&gt;- Thinking: 在每一个格子时都有向上和向右两种走法，而不管往哪个方向走一格，问题都可以转化为剩余```m-1```或```n-1```个格子所具有的路径数量~~~pythondef paths(m,n): if m == 1 or n == 1: return 1 else: return path(m-1,n) + path(m,n-1)~~~## *Example: Knapsack*&lt;small&gt;判断n的各位数字组合能否等于k，可能等于返回True，反之返回False&lt;/small&gt;- u1s1这个是有点没看懂的，自己的理解大概是如果n有0位不影响加减所以直接返回```True```，然后```with_last```函数每次去掉最后一位后查看包含此步骤中n的最后一位能否满足条件，而```without_last```则表示不包含此步骤中的最后一位能否满足。 综上，这个函数主题应用树递归就是在n的每一位数都提供加上这位数字和不加上这位数字两种选择，以此来包含所有可能~~~pythondef knap(n,k): if n == 0: return k == 0 else: with_last = knap(n // 10, k - n % 10) without_last = knap(n // 10,k) return with_last or without_last~~~## *Example: Counting Partitions*- 计数分区：即定义一个函数```count_partitions(n,m)```，求出在单一分区最大为```m```的情况下，在```n```中能有多少种分区的组合。例如```count_partitions(6,4)```即有如下要求和9种解：![](./CS61A学习笔记/Pasted%20image%2020230714145032.png)- Thinking：要应用树递归的基本思路，即将所有情况分成两种情况，逐渐简化为基本情况，并且简化后的情况可以用原情况表示。本例中，可以先分为分区中有4的情况和分区中最大为3的情况。而对于第一种情况而言，可以视作求2的分区，即```n-m```的可能分区情况。如此，本例转化为的递归即为```count_partitions(n-m,m)```和```count_partitions(n,m-1)```的递归数总和，代码如下~~~pythondef count_partitions(n,m): if m == 0: return 0 elif n == 0: return 1 elif n &lt; 0: return 0 else: with_m = count_partitions(n-m, m) without_m = count_partitions(n, m-1) return with_m + without_m~~~## *Example: Binary Print*- [ ] （这节没听懂一点就是说）改日再会吧...## *Implementing Functions*- 这颗主要讲了一个程序填空题的解题思路吧，大概就是先理解框架，然后代入具体示例思考在每一步应该完成怎样的操作。~~~pythondef remove(n,digit): #删除n中为digit的数字 kept, digits = 0, 0 #digits常做计数器 while n &gt; 0 : n, last = n // 10, n % 10 if last != digit : kept = kept + last * 10 ** digits #利用digits实现位数转换 digits += 1 return kept#另一种思路def remove(n,digit): kept, digits = 0, 0 while n &gt; 0 : n, last = n // 10, n % 10 if last != digit : kept = kept / 10 + last digits += 1 return round(kept * 10 ** (digits - 1))~~~## *Lab03: Recursion, Tree Recursion*### Q2: WWPD: Journey to the Center of the Earth- [ ] 这个还是有点似懂非懂，就是单纯凭理解感觉是```70km 2900km 5300km 2900km 5300km 2900km```，但是实际上好像涉及函数调用嵌套，最后还有个函数定义（？~~~pythondef crust(): print(&quot;70km&quot;) def mantle(): print(&quot;2900km&quot;) def core(): print(&quot;5300km&quot;) return mantle() return core return mantle drill = crust drill = drill() # 70kmdrill = drill() # 2900kmdrill = drill() #5300km #2900kmdrill() #5300km #2900km #Function~~~![](./CS61A学习笔记/Pasted%20image%2020230715221249.png)### Q4: Repeated, repeated- 这个算是记一下自己的解题思路吧，就是先自然用```while```循环写了，然后想办法用递归替换迭代循环吧（让我们一起高呼：这就是GPT!） 在递归执行中因为直接返回```repeated(f,n-1)```所以就不需要```repeated_g```来作为&quot;中转&quot;（其实是不知道怎么能在全局变量里定义```repeated_g```的初始值且让这个语句就在递归里执行一次），所以就相当于直接赋给初始值```f(x)```~~~python#迭代while版def compose1(f, g): &quot;&quot;&quot;&quot;Return a function h, such that h(x) = f(g(x)).&quot;&quot;&quot; def h(x): return f(g(x)) return h def repeated(f,n): def repeated_f(x): if n == 0: return x elif n == 1: return f(x) else: i, repeated_g = 1, f while i &lt; n: repeated_g = compose1(f,repeated_g) i += 1 return repeated_g(x) return repeated_f#递归版def repeated(f,n): def repeated_f(x): if n == 0: return x else: return repeated(f, n-1)(f(x)) return repeated_f~~~### Q5: Num eights- 这个的抽象程度远超我想象...本来还想用就是先定义函数做出来然后再改，但最后咋也改不出来，借鉴了一下网上的: 就是我的理解是用一个```return 0```来表示所有位数都已经判断完毕并且初始化计数器为0，然后层层向上，如果该位数是8就返回值+1~~~pythondef num_eights(x): if x == 0: return 0 if x % 10 == 8: return num_eights(x // 10) + 1 return num_eights(x // 10)~~~### Q6: Ping-pong- 这题说真的是一点思路没有，看了网上大佬的代码后也用tutor理解了好久才勉强理解，我自己的理解大概是： 引入一个判定正负方向的判定值```flag```初始值为1，把所求的第```n```个```pingpong```数转化为上一个```pingpong```数和上一个```flag```的和，而根据```flag(x)```函数的定义，```flag```最终不是1就是-1（如果满足被8整除或者含8的条件，```flag(x)```等于```-flag(x-1)```，即前一个增减方向的相反，这样起到了改变增减方向的作用）~~~pythondef pingpong(n): def flag(x): if x == 1: return 1 if num_eights(x) or x % 8 == 0: return -flag(x-1) return flag(x-1) if n == 1: return 1 return pingpong(n-1) + flag(n-1)~~~## *HW03: Higher-Order Functions, Self Reference, Recursion, Tree Recursion*### Q1: Compose- [ ] 主打一个一个都不会做...我是真没办法透彻理解这个咋过来的，充其量能说服自己的一种理解是：(读题 认清```func```是所有嵌套 可能会想明白一点) ```composer(func)```函数直接收了一个参数```func()```，表示已有的全部函数嵌套；最终```func_adder(g)```实际上要返回一个```func(g(x))```的新函数，并把它作为参数```func()```传回给```composer()```函数，也就是添加了一个新函数进入所有函数的嵌套；最终返回```func```（已有嵌套函数）和```func_adder```（添加新函数工具函数） 对于这种两参数可以借鉴一下这个例子 [[#^afb04a]]~~~pythondef composer(func = lambda x: x): def func_adder(g): h = lambda x: func(g(x)) return composer(h) return func, func_adder~~~### Q2: G Function- 哦莫，终于做出来一个，记录一下递归和迭代的不同思路 需要注意的就是返回分清是返回函数还是具体值（即```g_iter_f```和```g_iter_f()```的区别）~~~pythondef g(n): #递归 if n &lt;= 3: return n else: return g(n-1) + 2 * g(n-2) + 3 * g(n-3)def g_iter(n): #迭代 def g_iter_f(): if n &lt;= 3: return n else: i, loc = 1, 0 while i &lt;= 3: loc += i * g(n - i) i += 1 return loc return g_iter_f()~~~### Q3: Missing Digits- 感觉很有必要先来记录以下这个在面对跟数字位数有关的问题是```all_but_last = n // 10```和```last = n % 10```的思路（每次看到恍然大悟自己想都想不到这个点）- 先读题读明白，```missing_digits(n)```提取的参数本身就是一个各位数字逐渐增大的参数，所以思路是从最后一位```last```和前一位```last_last```比较，如果相差小于等于1说明这两位数字之间没缺失，大于1说明缺失了```last - last_last - 1```个数字，然后用递归继续判定前```all_but_last```位数字；注意在```return```值中可以加上每次缺失的数字个数，这种返回方式可以类比一下这个[[#^756591]] 还有就是别忘了基本条件```basic case```，否则会一直递归（报错```RecursionError: maximum recursion depth exceeded in comparison```)~~~pythondef missing_digits(n): all_but_last, last = n // 10, n % 10 if all_but_last == 0: return 0 last_last = all_but_last % 10 if last - last_last &lt;= 1: miss = 0 else: miss = last - last_last - 1 return missing_digits(all_but_last) + miss~~~### Q4: Count Change- 类比类比and类比！这个整体思路就是应用上面计数分区[[#*Example Counting Partitions*]]的思路，分先用含最大的和不含最大的m进行分类 过程中遇到了一点小问题，就是在不应用```while```循环的情况下怎么求出小于```total```的最大m（也就是2的n次幂），求助了一下chatGPT老师给出的解决方案是转化为位运算（因为2的幂总是在二进制表示中只有一位是1，其他位都是0）。例如：7的二进制是111，共3位；所以将1向左移动2位得到100，转换为十进制就是4，是小于7最大的2的n次幂~~~pythondef count_change(total): def find_largest_power_of_two(x): # 将total转换为二进制字符串并得到其长度 binary_length = len(bin(x)) - 2 # 将1左移(binary_length - 1)位得到结果 n = 1 &lt;&lt; (binary_length - 1) return n m = find_largest_power_of_two(total) def count_change_f(total, m): if m == 1: return 1 elif total &lt; 0: return 0 else: with_m = count_change_f(total - m, m) without_m = count_change_f(total, m // 2) return with_m + without_m return count_change_f(total, m)~~~### Q5: Towers of Hanoi- 过年咯！感觉还是类比计数分区那个思路[[#*Example Counting Partitions*]]好吧，太有用了！这回变成```all_but_bottom```和```bottom```了，借助```print_move```函数来打印步骤，把每一个递归都理解成两个的思路，即```all_but_bottom: start-&gt;middle bottom: start-&gt;end all_but_bottom: middle-&gt;end```就搞定！ 中间就怎么定义这个```middle```又去寻求一下老师帮助，方法类似于定义数组，定义了一个包含所有可能数值的集合```all_numbers```，然后使用集合的差集操作```all_numbers - &#123;start, end&#125;```来找到除了```start```和```end```之外的那个元素。由于集合是无序的，我们可以使用``pop()``方法随机获取其中的一个元素，这样```middle```就会等于剩下的那个值。 虽然但是最后觉得自己像个傻子因为发现了：```middle = 6 - start - end```...~~~pythondef print_move(origin,destination): print(&quot;Move the top disk from rod&quot;, origin, &quot;to rod&quot;, destination) def move_stack(n, start, end): assert 1 &lt;= start &lt;= 3 and 1 &lt;= end &lt;= 3 and start != end, &quot;Bad start/end&quot; def find_middle(start, end): all_numbers = &#123;1, 2, 3&#125; x = (all_numbers - &#123;start, end&#125;).pop() return x middle = find_middle(start, end) if n == 1: return print_move(start, end) else: all_but_bottom = move_stack(n-1, start, middle) bottom = move_stack(1, start, end) all_but_bottom = move_stack(n-1, middle, end)~~~### Q6: Anonymous factorial- OK一朝回到解放前，又一道抽象题目...直接引用一下网上博主的解释 这道题要点，把函数当做参数传入，构造call, 在call里用lambda构造这个函数的behavior，这样就解决了迭代时需要函数名的问题。主要分为两部分: 1. 第一个括号： (lambda f: lambda k: f(f, k)) 构造一个需要f函数作为参数的函数，返回值是需要k为参数的函数，返回f函数的值，并且规定了f是一个需要2个参数的函数，f自身和k 2. 第二个括号：(lambda f , k: k if k == 1 else k * f(f, k-1) ) 这部分作为第一个括号的第一个call，构造f函数的行为，需要2个参数：f, k. 返回值为k或else后的值，if给出最简式，else给出，k和k-1的关系 3. 注意环境变量的变化，写成相同的名字便于理解，实际并不相同。~~~pythondef make_anonymous_factorial(): return (lambda f: lambda n: f(f,n))(lambda f, n: n if n == 1 else n * f(f, n-1))~~~# Lecture 8: Sequences &amp; Data Abstraction（序列与数据抽象）## *Lists*- 整体感觉就是C的数组，大括号```&#123;1，2，3，4&#125;```变成中括号```[1,2,3,4]```，另外还有些小tips和示例： ~~~python digits = [1, 2, 3, 4] len(digits) = 4 #判断数组长度 from operater import getitem digits[3] &lt;--&gt; getitem(digits, 3) #提取列表中第三个数 &gt;&gt;&gt; [2, 7] + digits * 2 &lt;--&gt; add([2, 7], mul(digits, 2)) [2, 7, 1, 2, 3, 4, 1, 2, 3, 4] &gt;&gt;&gt; pairs = [[10, 20], [30, 40]] &gt;&gt;&gt; pairs[1] [30, 40] &gt;&gt;&gt; pairs[1][0] 30 ~~~## *For Statements*- ```for```循环和```while```循环的用法功能对比：~~~python def count(s, value): total, index = 0, 0 #需要定义追踪变量index while index &lt; len(s): element = s[index] if element == value: total += 1 index += 1 return total def count(s, value): total = 0 for element in s: #不需要定义追踪变量，element初始化即为0且自增 if element == value: total += 1 return total&gt;&gt;&gt; pairs = [[1, 2], [2, 2], [3, 2], [4, 4]]&gt;&gt;&gt; same_count = 0&gt;&gt;&gt; for x, y in pairs: #固定长度序列中每个元素的名称... if x == y:... same_count += 1&gt;&gt;&gt; same_count2~~~- `for ... in ...`循环用法解释：~~~python&#x27;&#x27;&#x27;in表达式从（字符串、序列等）中依次取值，又称为遍历for-in遍历的对象必须是可迭代对象&#x27;&#x27;&#x27; &#x27;&#x27;&#x27;for-in的语法结构for 自定义变量 in 可迭代对象: 循环体&#x27;&#x27;&#x27; # 字符串中取值for item in &#x27;python&#x27;: print(item) # range产生一个整数序列，也是一个可迭代对象for i in range(10): print(i)# 如果在循环体中不需要用到自定义变量，可将自定义变量写为‘_’for _ in range(5): print(&#x27;人生苦短，我用python&#x27;)~~~## *Ranges*~~~python&gt;&gt;&gt; list[range(-2, 2)]list[range(-2, 2)]&gt;&gt;&gt; list(range(-2, 2))[-2, -1, 0, 1]&gt;&gt;&gt; list[range(4)]list[range(0, 4)]&gt;&gt;&gt; list(range(4))[0, 1, 2, 3]def cheer(): for _ in range(3): #无用用空格或者下划线代替 print(&#x27;Go bears!&#x27;)&gt;&gt;&gt; cheer()Go bears!Go bears!Go bears!~~~## *List Comprehensions*~~~pythonodds = [1, 3, 5, 7, 9]&gt;&gt;&gt; [x+1 for x in odds][2, 4, 6, 8, 10]&gt;&gt;&gt; [x for x in odds if 25 % x == 0][1, 5]def divisors(n): &quot;&quot;&quot;Return the integers that evenly divide n. &gt;&gt;&gt; divisors(1) [1] &gt;&gt;&gt; divisors(4) [1, 2] &gt;&gt;&gt; divisors(12) [1, 2, 3, 4, 6] &gt;&gt;&gt; [n for n in range(1, 1000) if sum(divisors(n)) == n] [1, 6, 28, 496] &quot;&quot;&quot; return [1] + [x for x in range(2, n) if n % x == 0]~~~## *Strings*- 对数组来说，一次只能查找一个元素；而对字符串序列来说可查找多个连续字符，如下：~~~python&gt;&gt;&gt; &#x27;here&#x27; in &quot;Where is Waldo?&quot;True&gt;&gt;&gt; 234 in [1, 2, 3, 4, 5]False&gt;&gt;&gt; [2, 3, 4] in [1, 2, 3, 4, 5]False~~~## *Data Abstraction*&lt;small&gt;Defination: A methodology by which functions enforce an abstraction barrier between representation and use&lt;/small&gt;- ```wishful thinking```通过保留有理数的分子分母来输出分数的准确值~~~pythondef mul_rational(x, y): return rational(numer(x) * numer(y), denom(x) * decom(y)) def add_rational(x, y): nx, dx = numer(x), denom(x) ny, dy = numer(y), denom(y) return rational(nx * dy + ny * dx, dx * dy) def equal_rational(x, y): return numer(x) * decom(y) == numer(y) * decom(x)~~~## *Representing Rational Numbers*- 在定义一个列表如```pair = [1, 2]```后，可以通过解包```x, y = pair```或者运用元素运算选择符```x = pair[0]```来调用列表内容，再或者用```getitem(pair, 0)```~~~pythonfrom fractions import gcd #Greatest common divisor def mul_rational(x, y): return rational(numer(x) * numer(y), denom(x) * denom(y)) def add_rational(x, y): nx, dx = numer(x), denom(x) ny, dy = numer(y), denom(y) return rational(nx * dy + ny * dx, dx * dy) def equal_rational(x, y): return numer(x) * denom(y) == numer(y) * denom(x) def rational(n, d): &quot;&quot;&quot;Construct a rational number that represents N/D&quot;&quot;&quot; g = gcd(n, d) return [n//g, d//g] def numer(x): &quot;&quot;&quot;Return the numerator of rational number x.&quot;&quot;&quot; return x[0] def denom(x): &quot;&quot;&quot;Return the denominator of rational number x.&quot;&quot;&quot; return x[1]~~~## *Abstraction Barriers*- [x] 没咋看懂 放段教材（bushi哦看懂了好像...感觉就是在函数内也尽量引用高层函数，例如```square_rational```引用```mul_rational```，确定了这两个函数的对应关系，即使在更改了选择构造器签名或者更改有理数实现的情况下，因为平方(```square```)等于两原数相乘这个关系始终不变，就不需要修改这个程序在继续更多复合数据和数据抽象的示例之前，让我们考虑一下有理数示例引发的一些问题。我们根据构造函数 `rational` 和选择器函数 `numer` 和 `denom` 来定义操作。一般来说，数据抽象的基本思想是确定一组基本操作，根据这些操作可以表达对某种值的所有操作，然后仅使用这些操作来操作数据。通过以这种方式限制操作的使用，在不改变程序行为的情况下改变抽象数据的表示会容易得多。对于有理数，程序的不同部分使用不同的操作来处理有理数，如此表中所述。|该程序的一部分...|把有理数当作...|仅使用...||---|---|---||使用有理数进行计算|整个数据值|`add_rational, mul_rational, rationals_are_equal, print_rational`||创建有理数或操作有理数|分子和分母|`rational, numer, denom`||为有理数实现选择器和构造器|二元列表|列表字面量和元素选择|在上面的每一层中，最后一列中的函数强制实施抽象障碍。这些功能会由更高层次调用，并使用较低层次的抽象实现。每当程序的一部分可以使用更高级别的函数而不是使用较低级别的函数时，就会违反抽象障碍。例如，计算有理数平方的函数最好用 `mul_rational` 实现，它不对有理数的实现做任何假设。```python&gt;&gt;&gt; def square_rational(x): return mul_rational(x, x) 直接引用分子和分母会违反一个抽象障碍。12&gt;&gt;&gt; def square_rational_violating_once(x): return rational(numer(x) * numer(x), denom(x) * denom(x)) 假设有理数会表示为双元素列表将违反两个抽象障碍。12&gt;&gt;&gt; def square_rational_violating_twice(x): return [x[0] * x[0], x[1] * x[1]] 抽象障碍使程序更易于维护和修改。依赖于特定表示的函数越少，想要更改该表示时所需的更改就越少。 计算有理数平方的所有这些实现都具有正确的行为，但只有第一个函数对未来的更改是健壮的。即使我们修改了有理数的表示，square_rational 函数也不需要更新。相比之下，当选择器函数或构造函数签名发生变化后，square_rational_violating_once 就需要更改，而只要有理数的实现发生变化，square_rational_violating_twice 就需要更新。 Data Representations维护抽象障碍的目的是为了可以更改数据表示，而不用重写整个程序 数据抽象的关键思想在于通过数据的行为来判断数据类型，而不是通过如何构造它，以下是一个示例，展示了通过修改程序内容而不修改程序表达的一个例子：123456789101112131415161718192021222324252627282930313233#在这种定义里应用列表，x作为数组列表def rational(n, d): &quot;&quot;&quot;Construct a rational number that represents N/D&quot;&quot;&quot; g = gcd(n, d) return [n//g, d//g] def numer(x): &quot;&quot;&quot;Return the numerator of rational number x.&quot;&quot;&quot; return x[0] def denom(x): &quot;&quot;&quot;Return the denominator of rational number x.&quot;&quot;&quot; return x[1]#在这种定义里应用高阶函数，x作为函数def rational(n, d): def select(name): if name == &#x27;n&#x27;: return n elif name == &#x27;d&#x27;: return d return selectdef numer(x): #这里x作为一个接收有理数（即rational函数）的函数参数 return x(&#x27;n&#x27;)def denom(x): return x(&#x27;d&#x27;)#结果都是如下&gt;&gt;&gt; x, y = rational(1, 2), rational(3, 8)&gt;&gt;&gt; print_rational(mul_rational(x, y))3 / 16 对于第二种定义方式可以这样理解：1234 x = rational(3, 8) numer(x)#对于numer函数相当于： return rational(&#x27;n&#x27;) #即返回3 61A Fall Lecture12 Video 6(Dictionary) Dictionary: 把键位key和值value联系起来，没有顺序，例如：12345&gt;&gt;&gt; numerals = &#123;&#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10&#125;&gt;&gt;&gt; numerals&#123;&#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10&#125; #这个换不换顺序都有可能，但都无所谓&gt;&gt;&gt; numerals[&#x27;X&#x27;] # &#123;dictionary&#125;[&#x27;Key&#x27;]用来在dictionary中搜索10 其中有键位keys，值values，和项目items三个变量，如下调用：123456789&gt;&gt;&gt; numerals.keys()dict_keys([&#x27;I&#x27;, &#x27;V&#x27;, &#x27;X&#x27;])&gt;&gt;&gt; numerals.values()dict_values([1, 5, 10])&gt;&gt;&gt; numerals.items()dict_items([(&#x27;I&#x27;, 1), (&#x27;V&#x27;, 5), (&#x27;X&#x27;, 10)])#如果不调用具体值则会类似显示函数地址或者结构变量，具体如下：&gt;&gt;&gt; numerals.keys&lt;built-in method keys of dict object at 0x0000014567D5FFC0&gt; 还可以应用dict构造函数来创建一个dictionary，例如：1234567&gt;&gt;&gt; items = [(&#x27;I&#x27;, 1), (&#x27;V&#x27;, 5), (&#x27;X&#x27;, 10)]&gt;&gt;&gt; items[(&#x27;I&#x27;, 1), (&#x27;V&#x27;, 5), (&#x27;X&#x27;, 10)]&gt;&gt;&gt; dict(items)&#123;&#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10&#125;&gt;&gt;&gt; dict(items)[&#x27;X&#x27;]10 可以判定一个key是否在dictionary中，应用语句&#39;X in numerals，系统返回True或者False；与此同时，如果不确定一个key是否在dictionary中，可以应用numerals.get(key, 默认值)函数，赋给想判断的key一个默认值，如果在dictionary中则返回dictionary中对应的值，如果不在dictionary中则返回get函数中所赋的默认值 一些特殊的以及一些限制 可以有如下定义：12345&gt;&gt;&gt; squares = &#123;x: x * x for x in range(10)&#125;&gt;&gt;&gt; squares&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81&#125;&gt;&gt;&gt; squares[7]49 一个key只能对应一个值value，这个值不局限于数字，也可以是列表等，但是key不能是列表list、目录dictionary或者任何可变的类型 Examples: Lists(List Functions) 这节东西好多好多，包含了很多就是列表list改变的函数首先要记住的一个小tips:切片slice [a, b]包含第a个元素但不包含第b个元素，[a:]同理包含a 我先截几张图，之后把这个做个列表在shell里试一下（好多…好烦…） 关于slice notation的一些解释：总结下来，a[-1]表示列表的最后一个值，a[:-1]表示列表除最后一个值以外的所有元素，a[::-1]表示从倒着输出列表元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; a = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;g&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;m&#x27;]&gt;&gt;&gt; b = a[:] # 列表切片，表示把列表a[]的值全部正序复制到列表b[]中&gt;&gt;&gt; print(b)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;]# b = a[n:m]表示列表切片，复制列表a[n]到a[m-1]的内容到新的列表对象b[]# 当n缺省时，默认为0，即a[:m]# 当m缺省时，默认到最后，即a[n:]&gt;&gt;&gt; b1 = a[1:4]&gt;&gt;&gt; print(b1)[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; b2 = a[:3]&gt;&gt;&gt; print(b2)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b3 = a[1:] #表示除第一个元素（编号为0）以后的全部元素&gt;&gt;&gt; print(b3)[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;]# b = a[i:j:s]这种格式呢，i,j与上面的一样，但s表示步进，缺省为1，s可以取任何数字.# 所以a[i:j:1]相当于a[i:j]&gt;&gt;&gt; b4 = a[1:5:2]&gt;&gt;&gt; print(b4)[&#x27;b&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; b5 = a[:5:-1] # 从末尾倒数取值&gt;&gt;&gt; print(b5)[&#x27;m&#x27;, &#x27;l&#x27;, &#x27;k&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; b6 = a[5::-2]&gt;&gt;&gt; print(b6) # 从a[n]处倒数取值[&#x27;f&#x27;, &#x27;d&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; b7 = a[::-1] # 倒着取值&gt;&gt;&gt; print(b7)[&#x27;m&#x27;, &#x27;l&#x27;, &#x27;k&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;f&#x27;, &#x27;e&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]&gt;&gt;&gt; b8 = a[-1] #最后一个值&gt;&gt;&gt; print(b8)&#x27;m&#x27;&gt;&gt;&gt; b9 = a[:-1] #除最后一个值以外的元素&gt;&gt;&gt; print(b9)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;l&#x27;] 以下表格所有条件均为：s = [2, 3] t = [5, 6] Operation(指令释义) Example(示例操作) Result(所得结果) append: adds one element to a listNOTES: 首先注意和extend的区别：是增加一个元素，即是把t作为列表加到s；如果t作为列表被函数调用，那么对t中元素的更改会影响调用t的s s.append(t)t = 0 s = [2, 3, [5, 6]]t = 0 extend: adds all elements in one list to another listNOTES: 首先注意和append的区别：是增加全部元素，即要把t里的全部元素加到s上；同样的t之后的改变也不影响s s.extend(t)t[1] = 0 s = [2, 3, 5, 6]t = [5, 0] addition &amp; slicing: creating new lists containing existing elementsNOTES: 首先，类似于b &#x3D; a[1:]这种slice操作，所得首先是一个列表！！！(这个有坑在下面）；其次，用于a是将t作为列表与s相加，故对b[1][1]修改实际上是在对t中元素的修改，故既会影响a也会影响t a = s + [t]b = a[1:]a[1] = 9b[1][1] = 0 s = [2, 3]t = [5, 0]a = [2, 9, [5, 0]]b = [3, [5, 0]] list function: creating new lists containing existing elements t = list(s)s[1] = 0 s = [2, 0]t = [2, 3] slice assignment: replaces a slice with new valuesNOTES: 理解c[a:a] &#x3D; b就是把b变成c的第a位，其他的全部按上边的tips(含前不含后)考虑 s[0: 0] = ts[3:] = tt[1] = 0 s = [5, 6, 2, 5, 6]t = [5, 0] pop: removes &amp; returns the last elementNOTES: 既移除s的最后一位元素，同时将元素赋给t（注意是元素不是列表） t = s.pop() s = [2]t = 3 remove: removes the first element equal to the argument t.extend(t)t.remove(5) s = [2, 3]t = [6, 5, 6] slice assignment: remove elements to a list by assigning [] to a slice s[:1] = []t[0: 2] = [] s = [3]t = [] 对下面的 Lab 4: Python Lists, Data AbstractionQ2: Reverse (iteratively) 类比一下C语言里面数组指针的特殊性 上面这个是自己写的，有个很明显的缺陷就是定义数组只有4位（这个相当于占了知道示例的便宜123456789def reverse_iter(lst): n, i = len(lst), 0 # a = lst # 如果这里这样定义，在更改a中元素的同时lst的元素也会被更改 a = [0, 0, 0, 0] while i &lt; n: a[i] = lst[n - i - 1] i += 1 return a 之后这个是大佬的代码，借助了for循环的迭代用法和列表的加法顺序性质12345def reverse_iter(lst): ans = [] for x in lst: ans = [x] + ans return ans （关于for-in循环的用法详见[[#For Statements]]） Q3: Reverse (recursively) 具体思路请详见上一个[[#Examples Lists(List Functions)]]中有关list[-1]和list[:-1]的解释把握住递归的basecase+recursion的结构[[#Recursive functions]]1234def reverse_recursion(lst): if not lst: return [] return [lst[-1]] + reverse_recursion(lst[:-1]) Q5: Closer city 学一个选择返回的语句123456if distance_a &lt; distance_b: return get_name(city_a) else: return get_name(city_b)#等效于return get_name(city_a) if distance_a &lt; distance_b else get_name(city_b) Q7: Add Characters 就告诉自己一句话：别怕递归！按思路走[[#Recursive functions]]，对于字符串的基本情况记得考虑一下len(list) == 01234567def add_chars(w1, w2): if len(w1) == 0: return &quot;&quot; #OK犯病不知道为什么这里新建空字符串和返回空字符串都不行，就要我返回w1或者w2 if w1[0] == w2[0]: return add_chars(w1[1:], w2[1:]) return w2[0] + add_chars(w1, w2[1:]) Lecture 9: Functional Decomposition &amp; Debugging（功能分解与调试）Assertions assert函数为断言函数，用来检查代码是否符合已有的理解。如果函数表达式的结果为真则没有任何效果产生，如果之后的表达式结果为假则返回预先设置好的报错信息，可以去看一下之前汉诺塔那个事例中用过[[#Q5 Towers of Hanoi]] isinstance(数据, 数据类型)函数则是一个判断所给数据是否为指定数据类型的函数，是则返回True，反之返回False具体的代码实现如下：12345678910111213def fact(x): assert isinstance(x, int) assert x &gt;= 0 if x == 0: return 1 else: return x * fact(x-1)def half_fact(x): return fact(x / 2)&gt;&gt;&gt; half_fact(5)None #调用fact函数时变量2.5不符合int整数类型 Testing 调试程序能够发现程序中的错误，同时让我们能够保证某一个程序小组块的正确性，进而缩小未来可能需要的调试范围，也能够记录下程序的运行过程 Python所提供的具体的调试方案即doctest函数，具体的执行方式为python3 -m doctest filename.py，实现测试的代码模板如下：12345678def f(n): &quot;&quot;&quot;对函数功能的解释 &gt;&gt;&gt; f(1) #第一个函数验证测试示例 1 #第一个函数期待返回的结果值 &gt;&gt;&gt; f(2) 2 &quot;&quot;&quot; #...具体函数代码 Print Debugging 即应用打印过程值的方式来观察代码运行步骤，以起到检测调试代码的效果1234567891011121314151617def fact(x): # assert isinstance(x, int) # assert x &gt;= 0 print(&quot;Debug x = &quot;, x) if x == 0: return 1 else: return x * fact(x-1)def half_fact(x): return fact(x / 2)&gt;&gt;&gt; fact(2)x = 2x = 1x = 02 Interative Debugging 交互调试（Interative Debugging）再python中通常被等同于是一种叫做REPL: Read-Eval-Print-Loop(读取-求值-打印-循环)的工具，可以近似认为是python的命令行窗口，这种方式可以不用在PyCharm中不断的修改代码并运行，而是直接在命令行窗口中执行命令，具体指令为python3 -i filename.py。 Error Types 本节介绍一些常见的Python报错，用来判断自己的程序出现了什么问题 SyntaxError(语法错误) 出现此类错误表示您运行的文件中有不是有效的Python标准语法，程序中有错误语法或者错别字等 应该试图搜索缺失或多余的括号、if while等语句末尾缺失的冒号，或是开始的声明中却没有包含内容 IndentationError(缩进错误) 出现此类错误表示由于缩进不一致导致语法不正确，或者是因为用错了程序文本编辑器 应该试图搜索一下是否出现混淆空格和Tab的情况、错位情况，或者将自己的程序在一个程序编辑器中打开，还有可能是用错了空格类型（有不止一种空格类型） TypeError: ‘X’ object is not callable…(对象类型不可调用错误) 出现此类错误表示数据X的类型不能被看作函数，在函数过程中调用了一个非函数变量 应该被分配给函数的变量被分配给了非函数，或者局部变量中不包含全局变量里的同名函数 TypeError: … NoneType …(类型错误) 出现此类错误表示在程序不该使用的某处运用了None 事实上表示函数没有返回return语句 NameError or UnboundLocalError(命名错误&amp;非绑定本地错误) 出现此类错误表示Python寻找一个变量名但没找到 检查名称拼写错误，另一种不太常见的情况是在局部框架中对一个全局框架中的变量做了阴影处理（没理解，代码如下）12345678def f(x): return x ** 2def g(x): y = f(x) def f(): return y + x return f Tracebacks 程序返回的报错包括报错本身，返回错误的行数和每行都在进行着什么进程，最近的调用和错误返回将会显示在最底部 牢记基本的报错含义，依次浏览各行检查可能出错的位置。 Exceptions 编程语言中的一种内置机制用于声明和反映异常的地方（这节没听懂） Rasing Exceptions(引发异常) Assert: 最简单常见的引发报错的方式便是断言语句assert，语法为assert&lt;表达式&gt;, &lt;string&gt;，例如：assert False, &#39;Error&#39;会返回AssertionError: Error. 同时由于assert语句会减慢程序运行速度，可以使用python3 -O语句来忽略程序中的所有assert语句（相当于屏蔽了__debug__语句(会返回False) Raise: 感官上就是引发异常并抛出一个报错，格式大概是raise &lt;错误类型(如NameError, TypeError, KeyError(在dictionary中找不到对应的key), RuntimeError(超出运行时间), Exceptions等)&gt; (&#39;报错内容&#39;) Try Statements try语句用来处理异常，具体语法如下:1234try: &lt;try suite&gt;except &lt;出现异常类型&gt; as &lt;命名&gt;: &lt;except suite&gt; try语句的执行规则： 首先执行&lt;try suite&gt;，如果运行一切正常，就不执行异常语句except suite； 如果在执行&lt;try suite&gt;的过程中产生了某种异常，则执行except语句中对应异常类型的except suite语句； try语句的执行不会导致解释器停止工作，只会在特定出现异常情况下执行except操作以下是一个示例：12345678910#一种很常见的做法，当我们试图把一个名称绑定到一个值上但没有成功，就把名称绑定到特定值&gt;&gt;&gt; try:... x = 1 / 0... except ZeroDivisionError as e:... print(&#x27;handling a&#x27;, type(e))... x = 0...handling a &lt;class &#x27;ZeroDivisionError&#x27;&gt;&gt;&gt;&gt; x0 下面这个示例是为了对比以显示出try语句不会使程序停止运行的特性123456789101112131415def invert(x): y = 1 / x print(&#x27;Never print if x is zero.&#x27;) return y def invert_safe(x): try: return invert(x) except ZeroDivisionError as e: print(&#x27;handled&#x27;, e) return 0&gt;&gt;&gt; invert_safe(0)handled division by zero #这里的division by zero是原本1/0的报错0 当输入指令invert_safe(1/0)时，程序不会运行，因为操作数1/0本身遍已经产生了ZeroDivisionError异常 运算符在操作数之前计算，即当&gt;&gt;&gt; inverrrrt_safe(1/0)时，会优先出现NameError: name &#39;inverrrrt_safe&#39; is not defined 当遇到如下嵌套try语句时，经过内部try语句执行后的部分便已经变成了一个没有异常运行良好的程序，所以外层的except suite永远不会被执行(代码如下)1234567&gt;&gt;&gt; try:... invert_safe(0)... except ZeroDivisionError as e:... print(&#x27;handled!&#x27;)...handled division by zero #不会执行外部循环的handled！语句0 Example: Reduce对reduce函数的解释如下： 1234567891011121314151617181920212223242526272829303132333435363738from operator import add, mul, truediv def divide_all(n, ds): try: return reduce(truediv, ds, n) except ZeroDivisionError as e: return float(&#x27;inf&#x27;) def reduce(f, s, initial): #循环 &quot;&quot;&quot;Combine elements of s using f starting with initial &gt;&gt;&gt; reduce(mul, [2, 4, 8], 1) 64 &gt;&gt;&gt; reduce(add, [1, 2, 3, 4], 0) 10 &quot;&quot;&quot; for x in s: initial = f(initial, x) return initial def reduce(f, s, initial): #递归 &quot;&quot;&quot;Combine elements of s using f starting with initial &gt;&gt;&gt; reduce(mul, [2, 4, 8], 1) 64 &gt;&gt;&gt; reduce(add, [1, 2, 3, 4], 0) 10 &quot;&quot;&quot; if not s: return initial else: first, rest = s[0], s[1:] return reduce(f, rest, f(initial, first))&gt;&gt;&gt; divide_all(1024, [2,4,8,0])inf&gt;&gt;&gt; divide_all(1024, [2,4,8])16.0 Lecture 10: TreesBox-and-Pointer Notation 讲了一种指针表示列表元素的方法，有个闭包属性没咋听懂 Slicing 一种对已有列表进行“切片”的操作具体操作请看上面的[[#Examples Lists(List Functions)]] Processing Containing Values 一些遍历列表和目录的内置函数(稍后制表) 函数名 函数用途 示例 sum函数 sum(iterable[, start]) -&gt; value将所给的可迭代变量（如列表）中的数字与start初始值相加（没有默认为0） &gt;&gt;&gt; sum([2, 3, 4]) 9 &gt;&gt;&gt; sum([2, 3, 4], 5) 14 &gt;&gt;&gt; sum([[2, 3], [4]], []) [2, 3, 4] max函数 max(iterable[, key = func]) -&gt; valuemax(a, b, c, ...[, key = func]) -&gt; value输出所给的可迭代变量（如列表）中最大的数字，当给出key function时，调用这个函数来计算最大值 &gt;&gt;&gt; max(range(5)) 4 &gt;&gt;&gt; max(0, 1, 2, 3, 4)4&gt;&gt;&gt; max(range(10), lambda x: 7 - (x-2) * (x-4))3 all函数 all(iterable) -&gt; bool当所提供的可迭代对象（如列表）中所有元素都为True值或列表为空时返回True &gt;&gt;&gt; [x &lt; 5 for x in range(5)] [True, True, True, True, True] &gt;&gt;&gt; all([x &lt; 5 for x in range(5)])True&gt;&gt;&gt; all(range(5))False Trees本质上来说，Tree实际上是一种列表嵌套的表示，即将列表作为其他列表中的元素，称之为数据类型的闭包属性(closure property) 首先介绍了Tree的两种理解方式吧~ 第一种是递归描述(recursive description -&gt; wooden trees): 即每一个树结构都有一个根标签(root label)和若干个枝干(branches)，同时每一个枝干都可以视作为一个子树结构，一个没有枝干的树结构便称之为叶(leaf) 第二种则是亲缘描述(relative description -&gt; family trees): 即树结构上的每一个位置都可以视作一个节点(node)，每个节点所对应的标签(label)都可以是任何值，而每一个节点同时也作为其他节点的父节点或者子节点(parent&#x2F;child) 接下来，是如何让python定义出一个树结构，如果仅用概念抽象表示的话，树应该是这样的1234&gt;&gt;&gt; tree(3, [tree(1), ... tree(2, [tree(1), ... tree(1)])])[3, [1], [2, [1], [1]]] 紧接着，我们来实际在python下通过编写函数来实现构建Tree的过程 首先我们从构造函数Tree， 选择器函数label和 branches 组成。12345678910def tree(label, branches = []): for branch in branches: #引入branch遍历branches列表中的元素 assert is_tree(branch), &#x27;Branches must be trees&#x27; #运用断言函数判断branches中的每一个元素是否也为Tree return [label] + list(branches) #返回时将label值转化为列表，并重新构建一个列表递归除label以外的branches def label(tree): #返回Tree的第一个值，即root label return tree[0] def branches(tree): #返回Tree除第一个以外的值，即branches return tree[1:] 由上方Tree的定义知，只有当树有一个根标签并且所有分支也是树时，树才是结构良好的。is_tree 函数应用于构造函数tree以验证所有分支是否结构良好。1234567def is_tree(tree): if type(tree) != list or len(tree) &lt; 1: #验证一个tree是否不是列表或者是否没有root label return False for branch in branches(tree): if not is_tree(branch): #借助branch遍历branches的每一个元素（枝干）是否为Tree return False return True 同时用is_leaf函数验证Tree是否有分支12def is_tree(tree): return not branches(tree) 具体运行情况如下：12345678910111213&gt;&gt;&gt; t = tree(3, [tree(1), tree(2, [tree(1), tree(1)])])&gt;&gt;&gt; t[3, [1], [2, [1], [1]]]&gt;&gt;&gt; label(t)3&gt;&gt;&gt; branches(t)[[1], [2, [1], [1]]]&gt;&gt;&gt; label(branches(t)[1])2&gt;&gt;&gt; is_leaf(t)False&gt;&gt;&gt; is_leaf(branches(t)[0])True Tree ProcessingExample: Printing Trees","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://binisalegend.github.io/tags/Python/"}]},{"title":"Missing-Semester学习笔记","slug":"Missing-Semester学习笔记","date":"2023-11-08T02:28:04.000Z","updated":"2023-11-08T02:30:28.711Z","comments":true,"path":"2023/11/08/Missing-Semester学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本文是一些零散的如命令行、Git、vim的学习笔记","text":"本文是一些零散的如命令行、Git、vim的学习笔记 1. 课程概览与shell使用shell教材部分 shell根据空格分割命令并进行解i析，如果要传入的参数中包含空格，一种方式是应用单双引号，另一种方法是应用转义字符\\进行处理（My\\ Photos） 课程视频部分在shell中导航教材部分 shell中的路径是被分割的目录，在Linux和MacOS中使用 / 分割，而在Windows上是 \\ pwd：获取当前工作目录 cd：切换目录 . 表示当前目录， .. 表示上级目录(在使用cd和ls命令时都可以用) ls：查看指定目录下含有哪些文件 大多数的命令都可以接受标记选项，通常以-&lt;命令字母&gt;的形式表示，例如：123456missing:~$ ls --help-l 使用较长格式列出信息missing:~$ ls -l /home总用量 4drwxr-xr-x 29 binisalegend binisalegend 4096 8月 11 00:05 binisalegend 其中，d表示missing是一个目录，而后面的字母三个为一组。rwx、r-x、r-x分别表示文件所有者(missing)、用户组(user)以及其他所有人所具有的权限：即只有missing作为文件所有者具有可写(write)权限，用户组和其他访问者均只有可读(read)和可执行(execute)权限 其他命令：mv -&gt; 重命名或移动文件、cp -&gt; 拷贝文件、mkdir -&gt; 新建文件夹 如果想了解一个函数或者是指令的输入输出形式和工作信息，可以man &lt;指令&gt;(manual的缩写)，并用q退出 课程视频部分 cd ~可以直接返回到home目录下，cd -可以快速返回到上一步所在的目录 rm &lt;文件路径&gt;：只能删除单个文件；rmdir &lt;文件目录路径&gt;： 删除一个目录(dictionary) 类似mkdir my photos这样的指令会创建两个文件夹分别问my和photos，如果想要创建一个名为my photos的文件夹则需要用双引号引用mkdir &quot;my photos&quot;或者使用转义空格mkdir my\\ photos 在程序间创建连接教材部分 &lt; 文件名 和 &gt; 文件名 可以将程序的输入输出重定义到文件，具体如下：12345678missing:~$ echo hello &gt; hello.txtmissing:~$ cat hello.txthellomissing:~$ cat &lt; hello.txthellomissing:~$ cat &lt; hello.txt &gt; helloooootxtmissing:~$ cat hellooooo.txthello 可以借助 | 将一个程序的输出与另外一个程序的输入联系起来，例如：12missing:~$ ls -l / | tail -n1 #第一个命令输出所包含全部文件夹的详细信息，第二个命令则输出文件中的最后&lt;number&gt;行drwxr-xr-x 2 root root 4096 12月 18 2022 work 课程视频部分 &gt; 相当于在进行一个覆盖操作，而 &gt;&gt; 则是在进行追加操作，具体演示如下：![[Pasted image 20230812001054.png]] 吐了吐了…老是看到老师在讲课的时候突然命令行里就能出现上一步的命令内容，查了半天发现最后就是一个上键…直接人傻掉，不过也顺便查到了很多常用的linux快捷键：1234561. Ctrl + L：清空终端中所有的内容并返回当前的目录2. Ctrl + C：强制中断某个程序的执行3. Ctrl + D：结束键盘输入（不知道和上面那个有啥区别）4. !!：重复执行上一步的命令5. Ctrl Shift C/V：复制粘贴6. Ctrl + A：快速回到当前行最左一个字符 | 被称作”pipe characater”(管道字符)：将程序的输出放在左侧，将程序的输入放在右侧。这也可以对前面的ls -l / | tail -n1进行解释，即ls -l产生了一个输出，而tail -2则是一个需要输入的命令 一个功能全面又强大的工具教材部分 对于类Unix系统，根用户(root user)几乎不受任何限制，需要应用sudo(super do)命令来执行。而有一些操作是只有根用户才能够进行的，例如向sysfs文件中写入内容 课程视频部分 /sys目录中存放着电脑的各种内核参数，只有root用户才能对这些内核参数进行更改，除去sudo命令之外，我们也可以应用sudo su进入root命令行界面来进行操作与更改 课后练习 touch &lt;新文件名&gt;：本质上是改变一个文件的时间戳（修改时间），也可以新建一个文件 如果直接访问一个文件夹要用完整的路径例如/home/binisalegend/missing/semester，但是实际上发现好像./semester就可以 ~~写入文件的时候可以使用&gt;&gt;来写入文件，暂时看起来的作用是换行 rm -rf &lt;文件路径&gt;：删除文件 在执行文件遇到权限不足的情况时可以用ls -l &lt;文件名&gt;来查看文件权限，然后用 chmod [权限名称] &lt;文件名&gt; 来更改文件权限，其中可读权限为4、可写权限为2、可执行权限为1，即如果想分别设置所有者、用户和其他人的权限为全部、可读可写、可读，则语句为 chmod 764 semester。具体相关细节详见以下：![[capture-2023-08-11-20-57-14.jpg]] 之后的这个问题很有意思，相当于把smester文件执行的内容输出中的一条拷贝到last-modified文件中，具体命令如下：1./semester | grep last-modified &gt; last-modified.txt 可以理解成./semester是运行这个文件，用 | 让后面的grep last-modified同时执行，即注意grep命令抓取last-modified所在的输出并将其添加到last-modified.txt文件中 2. shell工具和脚本 这节教材没看明白(听课一开始也似懂非懂 所以直接听到啥记点啥) shell脚本 赋值语句的表示即为foo=bar，而访问变量中存储的数值的语法即为$foo。值得注意的是，在bash种如果输入命令foo = bar是不能正确执行命令的，因为系统会调用foo并把=和bar作为函数的参数。这是本人第一次遇到在语句中增添空格会导致程序执行失败的例子，务必多加小心 同时要注意双引号&quot;&quot;和单引号&#39;&#39;的区别，即双引号中会访问变量实际存储的数据值，而单引号则会全部保留原有的数据格式(变量不会被转义)，演示如下：1234~/missing$ echo &quot;Value is $foo&quot;Value is bar~/missing$ echo &#x27;value is $foo&#x27;Value is $foo 一种在权限不足的情况下重新尝试命令的方法是运用 !! 命令，即可以在执行某个命令系统提示”Permission denied”后，使用sudo !!来快速运用sudo权限来再一次执行命令 在Linux中Vim文本编辑器中，想要对文本进行修改可以使用”Esc“或者”Ctrl + 【“ 快捷键进入编辑模式（我的不知道为什么好像要再按一下A才能开始编辑），其中-w为保存命令，-wq为保存并退出编辑器 在bash脚本中有很多特殊的参数来表示参数，错误代码和相关变量，其中一些如下： $0 - 脚本名 $1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。 $@ - 所有参数 $# - 参数个数 $? - 前一个命令的返回值 $$ - 当前脚本的进程识别码 $_ - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 使用echo $?检查错误命令时，输出0表示一切正常没有错误，输出1表示前面的命令语句出现了问题，其中true后echo $?返回始终为0，false后始终返回1(这个感觉有点奇怪好像Linux里面true和false是小写) 在bash中也有”或”和”与”运算符，它们都属于短路运算符。其中||或运算符在符号前语句没有0错误代码时(即echo $?返回不为0，语句有问题)便会执行符号后的语句，反之，如果符号前语句错误代码为0，则符号后语句会被短路不会被执行，同时如果错误代码均不为0则不输出且错误代码返回1；而&amp;&amp;与运算符则只在前后错误代码均为0时才会执行语句。示例如下：![[Pasted image 20230813222634.png]] 可以使用分号在一行中打印多个语句，不管执行什么都会全部执行所有语句：12&gt;&gt;&gt; false ; echo &quot;This will always print&quot;This will always print 我们可以以变量的形式获取一个命令的输出，这种方式通常被称作命令替换(command substitution), 例如：![[Pasted image 20230813232317.png]] 其中，有一些点值得注意：在扩展字符串的时候记得用双引号而不是单引号，原因详见2.2；同时在调用的时候要使用$ &lt;变量名称&gt;，可以类比一下C语言中格式化赋予变量值的操作。 ^1f484b 同时，还有一种相对冷门的类似特性被称为进程替换(process substitution)。其通过&lt;(&lt;命令语句&gt;)来将执行命令的结果保存到一个临时文件中，同时可以将两个命令所得结果进行串联，例如cat &lt;(ls) &lt;(ls ..)会打印当前文件目录和上级文件目录中的全部内容名称 下面是一组应用命令替换和进程替换的例子：1234567891011121314#/missing/example.shecho &quot;Starting program at $(date)&quot; # date会被替换成日期和时间echo &quot;Running program $0 with $# arguments with pid $$&quot;for file in &quot;$@&quot;; do grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null #grep用于在某个文件中中搜索子字符串 # 如果模式没有找到，则grep退出状态为 1 # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息 if [[ $? -ne 0 ]]; then # -ne表示不等于 echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fi # fi表示循环语句结束done ^4dd971 程序运行后得到： 1234~/missing$ ./example.sh mcd.shStarting program at 2023年 08月 14日 星期一 18:12:03 CSTRunning program ./example.sh with 1 arguments with pid 20563File mcd.sh does not have any foobar, adding one 当我们需要提供形式类似的参数时，可以应用shell的通配(globbing)，它可以基于文件扩展名展开表达式，其中主要包含通配符 * 和 ? 以及大括号 &#123;&#125; 。其中 ?用来匹配一个任意字符，而 * 可以匹配任意个字符；而大括号 &#123;&#125; 可以展开一系列包含一段公共子串的指令，这种方式在批量移动和转换文件时非常方便。以下是一些示例：1234567891011121314151617181920212223convert image.&#123;png,jpg&#125;# 会展开为convert image.png image.jpgcp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath# 会展开为cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath# 也可以结合通配使用mv *&#123;.py,.sh&#125; folder# 会移动所有 *.py 和 *.sh 文件mkdir foo bar# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件touch &#123;foo,bar&#125;/&#123;a..h&#125; # ..表示省略中间的部分，注意不要随意添加空格touch foo/x bar/y# 比较文件夹 foo 和 bar 中包含文件的不同diff &lt;(ls foo) &lt;(ls bar) #流程替换，相当于将两个输出共同存放到一个临时文件中进行储存比较# 输出# &lt; x# ---# &gt; y 同时，脚本并不一定只有在bash中才能使用，我们也可以将其写在诸如python等文件中，通过shebang来为内核提供去运行脚本所需的编辑器位置，这时我们通常要在文件开头第一行使用env命令，通过环境变量搜索来进行定位，例如#!/usr/bin/env python。应用这种方式我们就可以使用任意语言来运行程序了。 shell工具 有时我们在man一个函数时由于其雕有了Linux的官方文件，导致其通常会列出该函数的所有用法，显示过于冗长。因此我们可以应用一个tldr &lt;函数名&gt;来相对更简洁的获取函数的具体应用方式。 在shell中，我们可以借助find命令在仅提供一定模糊信息的情况下来寻找一个文件(夹)所在的位置。其中，-name 用来指定所寻找的文件名；-type 用来指定所寻找的文件类型(如d表示文件夹。f表示文件等)；-path用来指定在何位置路径寻找(可以用* ？等符号来指定有一定相同之处的多个路径)；-mtime用来指定修改时间(如-1表示最后一天修改的文件内容)等。同时，在执行结束find语句后可以应用 -exec 直接执行一些相关的命令。例如find . -m &quot;*.tmp&quot; =exec rm &#123;&#125; \\ 即寻找所有扩展名为tmp格式的文件并且删除。PS: 省流简化版：fd &quot;.*py&quot; 还有另一个查找文件的命令locate &lt;文件名&gt;，会输出所的文件的绝对路径，即简历路径下该文件的索引。同时还可以应用sudo updatedb命令来更新数据库。 在试图获取文件内容时，我们可以应用 grep &lt;要搜索的字符串&gt; &lt;文件名&gt; 函数来执行这个操作，系统会输出包含这个字符串的行；同时我们也可以用 grep -R &lt;要搜索的字符串&gt; &lt;文件目录&gt; 来令程序在整个目录中遍历搜索。还有很多选项如：-C (注意是大写) ：获取查找结果的上下文；-v 将对结果进行反选，也就是输出不匹配的结果。举例来说， grep -C 5 会输出匹配结果前后五行。 同时还有一系列的获取文件内容的方式，例如 rg(ripgrep) &lt;搜索内容&gt; &lt;文件名或者搜索路径&gt; 等，其中rg会以更为清晰明了的形式(颜色突出)展现搜索结果，包括文件名、搜索内容所在的行数 我们还有一系列的来查找执行过的命令的方法，一种常用的方式便是使用上箭头，另一种方式则是应用history &lt;搜索的命令数&gt;命令，同时也可以利用管道结合grep来具有目的性的搜索我们所执行过的指令，即 history &lt;命令数&gt; | grep &lt;相关字符串&gt; 。我们也可以采用 Ctrl + R快捷键来对命令历史记录进行回溯搜索，在按下快捷键后可以通过输入相关字符串来进行精确搜索 自己配置了一个zsh环境，个人感觉很好用吧(至少对于我这种喜欢漂亮窗口字体的人来说很好用)，同时也提供了一系列命令提示和代码高亮的功能，具体配置方法可以看下这几个帖子：zsh 简单介绍 - LiuChengloong - 博客园 (cnblogs.com)使用 Zsh 作为 Ubuntu 的默认 Shell (regding.github.io) 最后是一些相对零散的用来进行快速的列表导航的小工具，例如 ls -R 可以快速产生文件夹内的文件结构，应用 tree 可以以更清楚的方式来展示文件夹内的各种关系等。 课后练习 Linux中以 . 开头的文件为隐藏文件，可以使用 ls -all (ls -a) 命令来显示全部隐藏文件。同时常用的几个命令有：-g 不显示文件的所有者，--human-readable (-h) 可以将文件的大小按照”MB KB GB”这样易读的形式显示出来，-lt 将文件按照访问时间排序并输出详细信息，ls --color=auto 可以根据文件类型显示出不同的颜色(如果在zsh中安装了相关的插件就不需要了)。 首先，这个题一定要用到前面的命令替换[[#^1f484b]]，即以变量的形式获取一个命令的输出，在本题中如 echo &quot;$(pwd)&quot; 可以获取当前的地址。着重理解一下下面这条语句：1cd &quot;$(cat &quot;$HOME/marco_history.log&quot;)&quot; 其中 cd 后以及 cat 后的 &quot;&quot; 均表明要进入的目录是后面这一段（需要执行引号内的命令——双引号），$() 表示命令执行后的内容将会以变量形式调用。还有另一种感觉很神奇的思路：12345678 #!/bin/zsh marco()&#123;export MARCO=$(pwd) &#125; polo()&#123; cd &quot;$MARCO&quot; &#125; 自己理解的大概思路是定义一个储存当前地址的环境变量 NARCO ，然后直接调用 这个其实个人不太理解，从网上查了一下相关的先理解一下题示代码吧，包括[[#^4dd971]]这里也有一样的东西，就是那个 2&gt; 和 &gt;&amp;2 ，原题示代码和相关知识点理解如下：12345678910#!/bin/env zshn=$(( RANDOM % 100 ))if [[ n -eq 42 ]];then echo &quot;Somethong went wrong!&quot; &gt;&amp;2 echo &quot;The error was using magic numbers&quot; exit 1fiecho &quot;Everything went according to the plan&quot; 每个文件在执行后都会产生至少三个文件描述符，分别是：0–标准输入(stdin) 1–标准输出(stdout) 2–标准错误(stderr) 举例来说，假如一个文件夹内只有一个文件hello1.txt，当输入命令 ls &#123;hello1,hello2&#125;.txt 就会报错 ls: 无法访问 &#39;hello2.txt&#39;: 没有那个文件或目录\\nhello1.txt ，这时我们可以使用命令 ls &#123;hello1,hello2&#125;.txt &gt;right.txt 2&gt;wrong.txt ，这样终端中就不会输出内容(因为返回值都重定向到相应的文件中了)，而 cat 两个文件内容分别为 hello1.txt 和 ls: 无法访问 &#39;hello2.txt&#39;: 没有那个文件或目录 。 而 &amp; 是一个描述符，如果1和2前面不加&amp;，会被zsh视作一个普通文件。在这种情况下，(1)&gt;&amp;2 就表示将标准输出重定向到标准错误中去，如果标准错误被定义到例如某个log文件，那么标准输出也被定义到那个log文件中去，终端上看不到任何信息。然后我们可以在理解源代码的基础上思考如何解题了。又是经典的有思路但一行代码写不出来…. 首先要明确的是在一个脚本文件中可以运行另一个脚本并且将其运行结果进行重定向。然后我们可以引入一个计数器 count 初始化为0，应用 echo &gt; out.log 命令清除已有的日志；接下来，因为我们要让程序运行到直到随机数产生42才结束，故我们设置一个无限循环，在循环中让程序不断运行，并将其标准输出和错误都重定向到out.log文件中，当运行出现错误即 $? -ne 0 时推出新循环，返回count。于是我们得出了以下程序，注意zsh中循环的语法，可以替换为for，until等语句：12345678910111213#!/bin/env zshecho &gt; out.logcount=0while true;do ./example1.sh &amp;&gt;&gt; out.log if [[ $? -ne 0 ]];then cat out.log echo &quot;Example1 went wrong after running $count times!&quot; break fidone 这个就不多bb了好吧，直接解释代码就行了，代码如下：1~/missing find . -type f -name &quot;*.html&quot; | xargs -d &#x27;\\n&#x27; tar -cvzf html.zip 管道前面的部分都很好理解，xargs 通俗理解就是可以将一个命令转化传给另一个命令，-d 后面可以指定一个定界符；对于 tar 的解释可以查看这个帖子tar中的参数 cvf,xvf,cvzf,zxvf的区别_tar xvf_想要一百块的博客-CSDN博客，重要的内容如下： 参数： 12345-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 12345-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 –delete 从存档中删除 注意是两个减号。下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 3. 编辑器(Vim)当这一节开始时，我开始意识到，前面的一个我看似理解的指令 vim ~/.zshrc 实际上便是用vim编辑器来编辑一个文件，而此时请自动忽略前面所有关于vim中快捷键的内容，包括切换模式等，她们都是在我不了解vim的时候擅自使用后产生的一些自我理解，忘掉他们！Then we start…PS: 以下内容大部分都可以通过 vimtutor 来进行练习 Vim的哲学Vim的思路是，在进行编程时将手从键盘移动到鼠标是一种极其繁琐费时的操作，所以在Vim中所有操作都可以通过键盘来实现。因为用的不太熟练，也不明白原理，所以把可能每次都需要配置一下的命令记录在这里，可以把Esc和Ctrl键重定义到CapsLock键（借用了这位大佬的思路将 Caps Lock 映射为 Escape 和 Ctrl | weirane’s blog (ruo-chen.wang)）： 1234#将CapsLock定义为Ctrlsetxkbmap -option ctrl:nocaps#将CapsLock定义为Escxcape -e &#x27;Control_L=Escape&#x27; 编辑模式vim编辑器中通常处在标准模式(normal)，还有一系列其他的模式如插入模式(insert): 用来编辑插入代码(i)、替换模式(replace): 用于覆盖文本，将前面的代码向前推(R)、一般可视化模式(visual)(V)、可视化行模式(visual-line)(shift + V)、可视化块模式(visual-block)(Ctrl + V)、命令行模式(command-line)(:)等。(返回normal模式时按下Esc) 基本操作这其中的一大部分操作是通过命令行模式(command-line)来实现的，即在标准模式下按下 : 后输入命令。可以将其类比成上两节中的shell，只不过这个命令行窗口属于vim。命令行窗口有一系列可执行的命令，例如： 1234567:q(quit) :qa 退出 退出所有窗口:w(write) 保存:wq 保存并退出:help &lt;command&gt; 显示对command的帮助文档:e &lt;filename&gt; 打开要编辑的文件:ls 打开现在已经打开的文件列表（缓存）:sp 将同一个文件(缓冲区)在上下两个窗口中打开 Vim接口作为编程语言的一些特性vim正常情况下处于标准模式，在标准模式下，有很多快捷键可以让我们很方便快捷的对文件进行移动、检索、编辑等一系列操作，具体的一些实例如下：(救命心态真的会崩太多了沃日) 移动命令123456789101112h j k l: 左下上右移动光标w: 将光标移动到下一个单词b: 将光标向前移动到单词开头e: 将光标移动到单词末尾0 $: 将光标移动到行首和行末^: 将光标移动到一行中第一个非空字符Ctrl + U/D: 将整个页面向上或向下翻动gg/G: 移动到整个文件的第一行和最后一行L M H: 将光标移动到当前显示界面的最下方/中间和最上方f/F&lt;字符&gt; t/T&lt;字符&gt;: 寻找到在当前光标所在位置之前/之后的第一个所求字符，f在其之上，t在其之前/后/: 进行搜索 使用N/n分别进行向上和向下的查找%: 用来找到如中括号等符号所对应的另一半 编辑命令123456i：插入命令，在当前位置切换到Insert模式，可以插入字符O/o：在光标所在行上/下新建一行，并切换到输入模式x：删除光标所在当前字符r/R + &lt;替换字符&gt;：用替换字符对一个或多个字符进行替换u/Ctrl+R：撤销，分别等同于Ctrl+Z和Ctrl+Shift+Z~：可以将小写字母转换为大写字母(可结合可视化模式使用) 以下的四个常用命令都可以结合可视化模式(Visual Mode)来进行，分别用v、V和Ctrl+V来进入基本、行和可视化块模式，并结合移动键来更便捷的实现选中操作。123d + &lt;移动命令&gt;：删除(如dw表示删除一个单词，de表示删除到这个单词的末尾，dd表示删除整行)c + &lt;移动命令&gt;：基本和上面命令效果相同，只是删除之后进入插入模式y&amp;p + &lt;移动命令&gt;: 操作方式与上面相同，分别表示复制和粘贴 计数命令以上命令都可以结合数字来确定一个命令执行的次数。例如4j表示向下移动四行，3e向前移动三个单词，7dw表示删除7个单词等。有用的一点是vim中左侧标出了其他行与当前的差值行数，就可以根据这个应用&lt;number&gt; j/k来进行快速导航了。 修饰命令修饰符主要有 i 和 a ，分别表示“在内“和”周围“的含义。以下是一些示例：123ci( : 改变当前括号内的内容di[ : 删除方括号内的内容da&#x27; : 删除一个单引号字符串，包括周围的单引号 demo示例 可以借助 G 命令快速跳转文件的最后一行以添加新的内容 借助 / 搜索命令可以快速跳转到你想编辑的位置 e 移到词末，w 向前移动一个单词，$ 移到行末等命令在定位并修改一些细小错误中非常有用 . 可以重复执行刚刚进行过的编辑命令等 4. 数据整理^cd331a 破防了破防了家人们谁懂啊，真的这节课就感觉一个字没听懂我真的服辣(50分钟的课我听了37分钟我甚至不知道我该从哪里记起)，没办法，放链接吧…视频链接：Lecture 4: Data Wrangling (2020) - YouTube教材链接：数据整理 · the missing semester of your cs education (missing-semester-cn.github.io) 哦莫，Java课讲这个了，这下不得不听了（睡），移步那边吧~[[Java程序设计笔记#^b2609e]] 5. 命令行环境任务控制(Job Control)结束进程当我们在命令行环境中按下 Ctrl + C，shell会为我们打断一个正在进行的进程。深层来讲，终端会向程序发送一个 SIGINT --&gt; signal interrupt 信号告诉程序自行停止。我们可以通过 man signal 指令来查看这些信号以及其对应的数字表示符和简短的描述。我们可以使用以下代码来简单验证一下两个信号指令 SIGINT 和 SIGQUIT ： 123456789101112#!/usr/bin/env pythonimport signal, timedef handler(signum, time): print(&quot;\\nI got a SIGINT, but I am not stopping&quot;)signal.signal(signal.SIGINT, handler)i = 0while True: time.sleep(.1) print(&quot;\\r&#123;&#125;&quot;.format(i), end=&quot;&quot;) i += 1 当我们按下 Ctrl + C 时，代码会捕获SIGINT指令并且返回语句，但是计数程序并不会停止运行；而当我们再次按下 Ctrl + \\ 时，程序并不会捕获到SIGQUIT指令，指令生效后程序会有如下提示并且立即停止：![[Pasted image 20230826232551.png]]而对于如下情况，当我们按下 Ctrl + Z 时，相当于终端发送了一个 SIGTSTP(Terminal Stop) 信号让正在运行的进程停止，但这个程序停止在后台并且可以通过 fg 让它在前台继续运行和 bg 让它在后台继续运行（也就是说可以通过 Ctrl + Z 和 bg 命令一起使用来让一个运行中的进程在后台运行![[Pasted image 20230826233231.png]] 暂停和后台执行进程jobs 命令可以显示出当前正在运行和后台运行或者暂停的进程数并将它们标号，可以通过 命令 + %&lt;命令编号&gt; 来对某个进程进行操作(调用最近的进程也可以用 $!)在进程命令后加 &amp; 符号也可以让一个进程直接在后台启动运行，这样我们就可以继续在shell的窗口进行一系列其他的操作然而，进入后台的进程依然是这个终端的子进程，也就是在关闭终端的时候这个进程也会被终止，如果想要避免这种情况可以在进程命令前加上 nohup 指令来实现我们也可以用 kill &lt;-SIGHUP&gt; / &lt;-STOP&gt; %&lt;命令编号&gt; 来终止一个进程 终端多路复用(Terminal Multiplexers)像 tmux 这样的终端多路复用器可以让我们分出多个终端窗口，这样我们可以同时与多个shell对话进行交互。 tmux 有三个基本思想分别是 “Sessions Windows Panes –&gt; 会话 窗口 窗格”在shell中直接输入 tmux 命令就可以新建一个tmux会话( 可以通过 tmux new -t &lt;窗口名&gt; 命令来新建一个会话并给tmux会话进行命名)，看起来和我们平时使用的zsh没有什么不同，但我们可以在其中运行一些相关的进程，并通过 Ctrl + B 后再按下 D 来返回到原本的zsh窗口，在zsh中使用 tmux a(ttach) -t &lt;tmux会话名称&gt; 命令来返回到刚刚的tmux会话，也可以在tmux中使用 exit 命令或者是 Ctrl + D 快捷键来彻底退出当前的tmux会话在一个tmux会话中，我们可以使用 Ctrl + B 再按下 C(create) 来新建一个窗口，这个操作相当于tmux为我们新建了一个与shell的对话窗口，我们可以在新的窗口中执行一系列其他命令。同时，我们还可以用 Ctrl + B 再按下 P(privious) || N(next) || &lt;窗口编号&gt; 来进行窗口之间的切换同时，我们可以用 Ctrl + B 再按 &quot; 或者 % 来新建一个窗格，实现类似于上下和左右分屏的效果，可以使用 Ctrl + B 加上上下左右箭头键在一系列窗格中切换。使用 Ctrl + B 再按 Z 可以切换当前面板在全屏和普通模式， Ctrl + B 加上空格键可以在不同窗格排布中切换 别名(Aliases)alias是一种相当于可以自定义快捷键的的指令，可以为一个长命令设置一个别名，它的语法如下： 12alias aliad_name=&quot;command_to_alias arg1 arg2&quot;#注意等号两边没有空格 alias命令可以在很多种情况发挥作用，除了直接定义像 alias gs=&quot;git status&quot; 这样的别名以外，我们还可以对一些我们容易打错的命令来使用它，例如 alias sl=ls ，包括对一个命令进行更加细致的规划如 alias mv=&quot;mv -i&quot; 等等。我们也可以用 alias &lt;别名&gt; 来查看一个别名代表了什么具体内容 配置文件(Dotfiles)很多程序的控制都是通过被称为点文件(Dotfiles)来控制的，例如 ~/.vimrc ~/.zshrc 等， 他们通常是隐藏文件，ls 并不会显示他们我们可以通过对这些文件的编辑和修改来修改相关的配置，例如添加上一小节的alias到bashrc文件中就可以在每次启动bash时都执行相关的命令 (这部分没弄懂)我们还可以通过建立一个dotfiles文件夹来整理所有的配置文件，通过符号链接将他们链接到他们需要的位置，并将其传递到如Github这样的云端，以便我们可以在各种设备上配置我们的终端 远端设备(Remote machines)我们通常使用ssh(safe shell)来远程连接服务器，ssh最基本的运行格式是 1ssh &lt;用户名&gt; @ &lt;主机IP地址&gt; (需要远程执行的命令) 当然，使用这种方式需要我们每次链接都输入密码，这显然有些不太方便，我们可以通过SSH密钥来解决这个问题，首先我们需要让主机产生SSH密钥，然后将产生的密钥传递给远程主机，以我自己的虚拟机为例，具体命令如下： 1234ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519cat .ssh/id_ed25519.pub | ssh &lt;用户名&gt; @ &lt;主机IP地址&gt; tee .ssh/authorized_keys# 我们还可以用以下命令来保存密钥的密码ssh-copy-id &lt;用户名&gt; @ &lt;主机IP地址&gt; 执行完以上命令后，我们就可以直接通过ssh命令连接主机而不用每次都输入密码了我们还可以用一些和本身命令行相近的命令来使他们在ssh使用中生效，例如复制文件命令 123456# tee命令：cat 本地文件 | ssh &lt;用户名&gt; @ &lt;主机IP地址&gt; tee 远端文件# scp命令：scp 本地文件路径 &lt;用户名&gt; @ &lt;主机IP地址&gt;: 远端文件路径#以下是shell原本的命令 做个对照cp notes.md notes.md 如果我们想复制大量文件，则可以使用另一个更好的命令 rsync 1ryscp -avP . &lt;用户名&gt; @ &lt;主机IP地址&gt;:&lt;文件夹名&gt; 我们还可以通过配置文件进行对ssh的自定义配置，文件及其地址为 ~/.ssh/config，例如我们可以通过以下配置来自定义远程主机名，这样我们就不需要在每次连接时输入繁琐的主机名和地址 1234Host &lt;自定义主机名&gt; HostName 主机IP地址 User 用户名 IdentityFile SSH密钥地址 同时，我们在远程连接的主机中如果展开了一个tmux，我们可以在其中运行程序执行命令，并且退出主机远程连接，当我们重新连接时一切都不会有变化 6. 版本控制(Git)版本控制系统是用来追踪源代码或者其他文件或文件夹集合的更改工具，他们有助于追踪某个文件集的修改历史纪录，同时他们也能促进团队协作，因为可以有很多人共同协作更改某个文件集。同时，我们可以查看自己程序的不同版本来对比所出现的问题，可以查看有谁对某个东西提交了更改并且我们自己也可以对这些文件集进行修订；在多种版本控制工具中Git已经成为了最被大众所接受的工具之一 Git的数据模型这一部分主要讲述了Git的工作机制，主要通过关联快照和历史记录建模，以及对象内存寻址的运行机制来实现，这一部分具体请看官方教程文档（中文文档地址：版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)） Git的命令行接口基础 首先我们可以使用git init命令来初始化一个文件夹使其变成一个Git仓库，当我们执行命令以后，系统会在该文件夹中新建一个名为.git的隐藏文件夹用来储存本地磁盘中的存储库(repository)数据 git help &lt;命令名&gt;可以对某个特定命令给出具体解释，类似Linux的 man 命令 当我们输入 git status 命令时可以看到当前仓库的（快照）状态，Untracked files 表示该文件经过了改动或者是新建的，即Git在对比过已有的系统快照后发现了不同，没有进行记录，这时我们可以使用 git add &lt;文件名/文件夹名&gt; 来将这个未被追踪的文件添加到系统快照中接下来，我们可以使用 git commit &lt;-m &quot;备注&quot;&gt; 来将我们所做的改动提交到暂存区中，注意既可以用 -m 命令来在后面直接添加提交备注，也可以跳转到提交界面添加备注，在提交成功后终端会显示提交的信息以及该快照的哈希值（一个Git用来记录文件上传信息的16位数字），我们可以使用 git cat-file -p &lt;hash numbers&gt; 来获取刚刚commit的信息内容（git log 也可以获取暂存日志虽然，这个好像可以输出上传文件中的内容） git add :/ 可以将所有的未追踪文件都添加到系统快照中，git commit -a 可以将所有没有被追踪的文件都添加到缓存区中（原谅某个笨比一次次打超长的文件名…） git log 可以用来获取版本历史纪录，但是老师说这个扁平化的看起来很烦，推荐了一个 git log --all --graph --decorate 来让版本更新记录图标化显示（虽然命令很长且我没看出什么区别，但我相信zsh插件会记住它的） 通常Git会默认创建一个 master 分支作为库中代码开发主要分支，代表着项目的最新快照版本(即最后一次commit)。我们可以将 master 视作一个指向当前提交的指针，当我们继续添加提交时，这个指针也会发生变化来指向新的提交；而在log中提示的 HEAD 则通常表示你现在正在处于的提交状态（通常是最近的提交，如果需要切换可以使用 git check &lt;parts of hash numbers&gt; ，这会将当前工作目录的状态切换回你所指向的提交时的状态，我们可以在最新状态之前对文件或者目录进行修改，但是在返回master目录时checkout会提示报错，此时可以用 -f 命令来强制执行） git checkout &lt;文件名&gt; 是对checkout命令的另一种使用，他会丢弃掉当前对文件所做的一切更改并且将当前文件的状态返回到 HEAD 快照所在的状态 git diff (&lt;hash numbers&gt; &lt;hash numbers&gt;) &lt;文件名&gt; 命令可以查看修改前后的不同之处，包括在不同工作目录下对文件修改前后的不同之处 分支和合并 使用 git branch &lt;新建分支名&gt; 可以查看现有的分支或者新建一个分支，这个新建的分支会指向当前提交的内容，例如如果我们新建一个名为cat的分支，我们再次应用 git log --all --graph --decorate 命令时就会看到当前HEAD仍然会指向原有的master分支，但是在后面会新建一个cat分支（使用 git checkout &lt;分支名&gt; 可以切换到新的分支，同时会发现此时HEAD指向了我们新建的分支，所显示的内容是master分支的最新提交内容） git commit 中可以应用 :x 命令来快速上交暂存备注 git branch -vv 以非常详细的方式展现已有的分支信息 不理解这个为什么不能早点教，害我一直看着很长一段log发愁：git log --all --graph --decorate --oneline 可以在一行中显示暂存日志，基本上是只显示哈希码和后面的暂存提交备注 当我们在一个分支中对某个程序进行了修改，再使用 git checkout &lt;分支名&gt; 切换回其他分支时会发现发刚刚作出改动的内容并不会显示在当前的工作目录中，这样我们就可以实现在并行的开发线中来回跳转 可以应用 git branch &lt;分支名&gt; ; git checkout &lt;分支名&gt; 来实现新建一个分支并且跳转到新建的工作表目录中去，简化版命令是 git check -b &lt;分支名&gt; （盲猜-b全拼是-branch） 当我们在多个分支工作目录中对代码进行改动后，我们同通常会需要将功能进行合并，这是我们可以先切换回master分支中，应用 git merge &lt;分支名&gt; ... 来将不同分支中的内容进行合并，指向master的指针HEAD会指向master和cat，前后对比图如下：![[Pasted image 20230903202528.png]]在执行合并操作的时候，Git可能会对一些合并不是太灵敏，这时会出现合并冲突问题（merge conflict），这是需要我们手动在文件中进行符合我们预期的修订后重新add更改，然后执行 git merge --continue 命令继续执行合并操作![[Pasted image 20230903210606.png]] 远程操作实际上，对于Git的远程操作主要是为了能够和他人一起协作，以及将自己的本地储存库上传到像GitHub、gitee等云端仓库 git remote 命令可以查看当前所有已经连接的远程仓库 git remote add &lt;远程连接名&gt; &lt;远程仓库http地址&gt; 可以远程连接一个新的仓库 git push &lt;远程连接名&gt; &lt;local branch&gt; : &lt;remote branch&gt; 用来将本地仓库推送到远程仓库中去，当我们仅将一个本地分支推送到基本固定的一个远程仓库分支时，可以使用 git branch --set-upstream-to=&lt;远程仓库名&gt;/&lt;分支名&gt; 可以配置一个固定的本地和远程分支连接，这样下次我们只需要使用 git push 即可完成推送工作 git clone &lt;URL&gt; &lt;要复制到的文件夹&gt; 可以从远端仓库下载内容到本地 git fetch 可以从远端获取对象、索引、推送记录等信息，检索对远端存储库的更改并且将这些信息保存到本地计算机中；同时还有一个命令 git pull 可以等同于命令 git fetch; git merge ，即从远端拉取内容并且与本地分支进行合并 撤销操作git commit --amend 可以重新编辑提交的内容和信息git restore 可以撤销在工作区中的很多操作git checkout &lt;文件名&gt; 可以丢弃在某个文件中所做的修改 一些高级一点的操作git clone --shallow 可以用于当我们要下载一个内容较大的仓库，这样我们就不会保存一系列版本历史记录信息，能更快地从远程仓库拉取到我们本地git add -p &lt;文件名&gt; 让我们可以以交互式的方式来选择具体上传什么，例如我们可以选择只对一处更改进行上传并添加快照；git diff --cached 可以让我们查看到即将上传的修改是什么git blame 可以让我们查看到谁对某行或者某个文件做出了修改，以及相关的一些信息git stash 可以使我们返回到上一个操作我们所处的工作目录状态，暂时移除工作目录下的修改内容；再使用一次 git stash &lt;Filename&gt; 就会取消对文件修改的隐藏操作git bisect: 通过二分查找搜索历史记录，比如跳转到某个时间的提交快照这个个人感觉很有用，可以通过配置 .gitignore 文件来忽略某些文件，例如一些系统文件、程序编译文件等，通过添加文件名或者类似 *.exe* 这类东西来使在查看 git status 时忽略他们 笨狗的小记：如何上传本地文件到github&#x2F;gitee库 初始化：git init：初始化，将一个新文件夹变成git可管理的仓库 连接github库：git remote add github &lt;Github库的https链接&gt;连接gitee库：git remote add gitee &lt;gitee库的https链接&gt; 可以使用 git remote -v 查看已经连接的远程仓库 本地文件修改上传：git status：查看当前文件夹修改的状态 git add &lt;文件名&gt; or &lt;文件路径&gt;：将新增或者删减文件上传到本地暂存库 git commit -m &quot;备注信息&quot;：改动内容上传到本地库 将本地仓库拉取到GitHub：git push -u &lt;远程仓库名称&gt; master：拉取本地库 Tips: git branch：查看库中的分支(前面带*的表示现在正处于的branch) git check &lt;分支名&gt;：切换到其他的分支 可以通过配置 .git/config 文件，通过添加URl来配置远程仓库","categories":[],"tags":[{"name":"杂技学习","slug":"杂技学习","permalink":"https://binisalegend.github.io/tags/%E6%9D%82%E6%8A%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java程序设计学习笔记","slug":"Java程序设计学习笔记","date":"2023-11-07T15:58:22.000Z","updated":"2023-11-08T03:32:08.051Z","comments":true,"path":"2023/11/07/Java程序设计学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/07/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本篇文章是BIT人工智能专业的限选课Java语言程序设计相匹配的学习笔记","text":"本篇文章是BIT人工智能专业的限选课Java语言程序设计相匹配的学习笔记 Class1如果一个类被声明为 public 那么当前文件名必须与其相同，这并不是说java程序中只能包含一个类，只是只能包含一个共有类 public classJava程序从 main 开始执行，且 main 方法声明必须是共有且静态的 public staticSystem(类名).out(类字段).println(标准输出对象方法)() 可以直接打印一个空行 转义字符 字符 转义字符 字符 \\\\ 反斜杠 \\f 换页 \\b 退格 \\t 跳出一个Tab \\r 回车 \\n 换行 \\&quot; 双引号 \\&#39; 单引号 Java类中的核心包以 java 开头（无需引用即可直接使用，如 System），扩展包以 javax 开头，第三方包以反写网址开头(如 com.exanple表示 www.example.com 的包) 以下是一个包含多个类的程序，以此演示调用静态和实例类型类的不同1234567891011121314151617181920212223242526272829/** MultipleClassesJavaProgram.java */class Class1&#123; public int outputInt(int x) &#123; return 1024 + x; &#125;&#125;class Class2&#123; public static void printInfo() &#123; System.out.println(&quot;调用Class2的printInfo方法&quot;); &#125;&#125;public class MultipleClassesJavaProgram&#123; public static void main(String[] args) &#123; Class1 c1 = new Class1(); Class2.printInfo(); int v1 = c1.outputInt(6); System.out.println(&quot;调用了Class1的main方法&quot;); System.out.printf(&quot;%d\\n&quot;, v1); System.exit(0); &#125;&#125; 即静态类可以直接调用类函数，而实例类需要先实例化一个变量，再对变量进行赋值操作（可以看一下[[CS61B学习笔记#^9a36d4]] Class2Lesson3: Java程序设计语法基础 利用关键词 final 声明常量相当于 public 一个 const 类型变量，如果常量仅在本类使用就要定义为 private 类型 enum 为枚举类型，具体调用方法有 &lt;枚举变量&gt;.&lt;变量名&gt; = &lt;枚举变量&gt;.枚举元素 (如Size s = Size.SMALL) 或 Size t = Size.valueOf(&quot;SMALL&quot;) ，也可以通过类似 MyEnum &lt;变量名&gt; : MyEnum.values() 来遍历枚举中的元素 JOptionPane.showInputDialog 可以在显示的输入框中显示我们想显示的内容，同时可以使用 JOptionPane.showMessageDialog(Component parentComponent, Object message, String title, int messageType) 来控制输出形式，具体的可以看看官方文档 数据类型转化中精度问题： Integer.parseInt() 可以将字符串类型变量转化为整型变量，而 String.valueOf(variable) 则可以将变量转化为字符串类型，结合 write 方法可以将内容输出到终端 Java中可以直接将 String + 其他类型变量 ，最终输出的是一个 String 类型变量 Lesson4: Java中的方法 在调用类似 Math 库时可以使用 import static java.lang.Math.*; 命令，使得在代码中只写静态方法名而省略函数名 对于较大数的运算可以考虑用 BigInteger 变量，相比于 double BigDecimal 能避免精度丢失问题注意 BigInteger 的运算方式要调用 .add .multiply 等方法来进行 在Java中将一个方法放入类中，相当于C语言中定义一个函数，具体的语法格式为12345访问权限 [static] 返回值类型 方法名(参数列表)&#123; return 表达式&#125; 生成随机数的一个惯用语句：Random ran = new Random(System.currentTimeMills());,这个语句使用当前时间作为“种子”来生成随机数 从JDK5.0开始，Java支持可变参数，基本代码如 &lt;variables class&gt;... &lt;variables name&gt;,注意当函数具有多个参数时，可变参数只能放在所有参数的最后（放前面识别不出来结束）在调用可变参数方法时系统自动为可变参数创造一个数组，在函数中以数组形式调用可变参数 对于 System.out.println() 可以输出不同类型参数，实际上调用了 write(String.valueOf(&lt;variable&gt;)) 来将不同变量转化为String类型，再由write方法输出到终端 看PPT突然发现读取输入的另一种方式 int x = Integer.parseInt(args[0]); 可以直接读取第一行的数据（尤其是对于只有一个数输入的情况很好用） 在这里就已经能发现引用类内方法的迹象了 Class ClassName = new Class() ,具体的解释在[[#^bea8b9]] 计算机不能精确的比较浮点数，因此在执行 0.00001 == 0.00000000000001 时会返回true，因此应该比较其差的绝对值是否在某个范围之内 Math.Abs(i-j) &lt; 1e-10 Lesson5: Java中的类和对象 Java中的类和对象可以理解成每个类都是为了某些特定对象而服务的方法集，在一个类中封装了面向一类对象的处理方法，而面向用户只开放特定的简单接口 编写类的方法如下：1234public/private class class_name&#123; public/private &lt;variable class&gt; variable_name; public/private &lt;return value variable class&gt; function_name(parameter List)&#125; 调用一个自定义类可以使用 Class class_name = new Class() 的语法，在调用类中的具体方法或者变量时使用 class_name.&lt;variable_name&gt;() ^bea8b9 我们在定义一个原始类型的变量时Java会要求立刻显式初始化变量，并且JDK会直接为该变量分配内存，如 int value = 100; ,而当我们声明一个对象类型的变量时系统不会立刻为变量分配内存，而是会让这个对象类型变量初始化为null，即 Class obj = null; ，如果一个对象变量不引用一个真实存在的已定义对象，就必须初始化为null 在对象类型变量的赋值上，对于像如下这种类型的赋值，相当于把other类的指针也指向了obj类型的地址，因此当我们更改other类中的方法或者变量时，会导致obj类型中的变量同时发生改变，这个可以和[[CS61B学习笔记#^14da37]]类比着看123456789101112131415public class test&#123; public static void main(String[] args) &#123; MyClass obj = new MyClass(); MyClass other = obj; other.x = 19; System.out.println(obj.x); &#125;&#125;class MyClass&#123; public int x = 0; private int y = 19;&#125;&gt;&gt;&gt; 19 相似的，在判断两个对象类型变量是否相等时尽量不要用 == ,这样比较的是两个对象的地址是否相同（对于上面那个情况是可以的，但是如果是重新new了一个对象变量就不行了），尽量使用 .equals() 方式来比较(代码在这里ObjectEquals) 对于这个 .equals() 的调用有点没看懂，讲义里写道有重写(override)和重载(overload)两种方式: 重写方式在方法前要加上 @Override 表示此方法是重写 Object 基类的的同名方法（这种以“@”打头的标记被称为“Annotation”），在方法中的对象类型参数为 Object 类型；而如果直接重载 .equals() 方法就不需要附加 @Override 标记，同时由于重载中 .equals() 的父类已经是最顶层的 Object 类，所以参数类型为当前方法所处的类名在代码的这一部分：123 public MyTestClass (int initValue)&#123; Value = initValue;&#125; 以上位于类中的定义被称作类的构造方法（也被称作构造函数），构造方法的名称与类相同，没有返回值；同一个类可以有很多个构造函数，具体的构造函数由参数来区分，并且可以通过 this 来进行相互调用 可以在类中直接使用 &#123;&#125; 将一个字段包裹起来，直接作为这个类的一个字段，作为类的“初始化块”，前面加上 static 就是静态初始化字段 在类中可以定义静态字段 static int total_employee_id，在调用时需要以类名为前缀进行调用（用对象变量也行但不推荐） 代码在这里TestStaticInitializeBlock extends 表示继承，在定义一个类 class &lt;class_name&gt; extends &lt;father_class_name&gt; 表示一个类继承了一个父类的属性，在执行当前新定义类之前一定会先执行父类的初始化；同时，静态初始优先于所有的初始，因此静态初始化模块会优先执行 super 关键字代表当前对象的父类型特征，可以和 this 类比来看，当子类构造方法第一行中没有 super 定义时系统会自动加上无参数的 super() 方法，详细的解释可以看这个帖子Java中super关键字及super()的使用 ^1f05af 类的静态方法只能访问类的静态成员，静态初始化块只执行一次，同时创建子类型的对象时，父类型中的静态初始化块也会被执行 Java中提供了一系列的包装类（引用类型，可以创建相应对象），简单来说就是把基本变量类型首字母大写，具体作用是为基本数据类型提供了一些方法和字段，可以使用 import package.class 来引用一个包，也可以在文件前使用 package &lt;包的路径(把/换成.)&gt; 语句来将类加入到指定的包中在对上述这种进行将类放入自定义包中操作的文件进行编译时，使用 javac -d 文件相对路径 文件名.java 命令，系统会自动按照 package 语句中的路径创建文件夹并将 .class 文件放在文件夹中，但注意执行可执行文件时需要在根目录执行类似这样 java Try.test.Hello 的命令才能偶正确运行 学到了一个新的类：StringBuffer / StringBuilder 可以直接用 .append() .insert() .delete() 来对字符串进行一系列操作 Class3Lesson6: Java程序设计中的字符串 上来就是老生常谈好吧：String 类型比较相同不能使用 == ,用string自带的判定方式 .equals() 来进行判断（Java自带的内存压缩机制导致相同的变量可能被指向同一个地址，而如果 new 一个变量会导致指向一个全新分配的地址，== 比较的不是元素值而是地址，所以会返回 false） compareTo :使用字典法进行比较,返回0表两字串相等,小于返回负值,大于返回正值 这些方法记录在这，用的时候自己查吧(bushi): regionMatches: 比较两字串的某一部分是否相等 startsWith和endsWith: 查询字符串是否以某字符串开始或结尾 indexOf和lastIndexOf: 在字串中查找字符或子串 操作函数 功能函数 功能描述 .substring(StartIndex, EndIndex) 查找字符串中某一段的内容(经典含前不含后) str1.concat(str2) 将str2接到str1后 .replace(OldChar, NewChar) 将旧字符替换为新字符 .trim() 去除头尾空格 .toUpperCase() .toLowerCase() 大小写转换 .getChars(srcstart, srcend, string, strIndex) 获取从指定位置起的子串复制到字符数组中 4. StringBuffer/StringBuilder类的常用使用方法：StringBuilder 相较 StringBuffer 有速度优势 构造方法：StringBuffer string = new StringBuffer(String str) 操作函数 功能函数 功能描述 .capacity() 不另外分配内存情况下 StringBuffer 还能存放的字符个数 .ensureCapacity(int capacity) 明确 StringBuffer 的最小容量 .setLength(int length) 指定 StringBuffer 变量的长度 .charAt(int index) 返回 StringBuffer 中位于 index 位的字符 .setCharAt(int index, char ch) 替换 StringBuffer 中位于 index 位的字符为 ch .getChars(int IndexOfPrevious, int length, char[] str, IndexOfNew) 将 StringBufffer 中的字符片段拷贝到字符数组中 .reverse() 倒转 StringBuffer .append(char[]/String str) 在 StringBuffer 后加上一段字符串 .insert(int index, string/char[] str) 从第 index 位开始插入字符串 .deleteCharAt(int index) &amp; delete(int StartIndex, int EndIndex) 删除 StringBuffer 中的某一个(段)字符 Lesson7: Java中的正则表达式^b2609e PS：当初听[[Missing-Semester学习笔记]]里面[[Missing-Semester学习笔记#^cd331a]]数据整理这一节的时候一点都没听懂，倒是没想到现在还是得学hhh正则表达式：对字符串本身具有特性的形式化表达，用来描述字符串“模式”正则表达式主要由普通字符和元字符(meta character)组成 字串字面量匹配(literal)/abc/匹配“abc”字符串(但不会匹配到像&quot;a bc&quot;的字符串，空格会影响到字串匹配)，但是这样的方式只会匹配到文档中最前面的那个匹配字符串，在命令中选择global模式 /abc/g 可以匹配文档中全部匹配字串 “元字符”匹配 元字符指正则表达式中具有一些特殊含义的字符，主要有 \\ . * + - &#123;&#125; [] ^ $ | ? () : ! = 等，例如 . 代表任意一个单个字符，* 代表任意一段字串 当我们想把元字符当作普通字符使用时，就需要使用 &#39;\\&#39; + 元字符 来对元字符进行转义 其他的特殊字符 要匹配的字符 在正则表达式中应该写… Tab \\t 回车，换行 \\r(代表回车)，\\n(代表换行)，\\r\\n(代表回车换行) ESC \\e ASC码字符 如0xA9要写作:\\xA9 Unicode字符 如4e00要写作：\\u4e00 3. 定义可选字符集合 使用 [ 和 ] 定义字符串中某个位置（注意是单个位置）的“候选字符集合” 例如 [aeiou] 表示搜索这五个字符; gr[ea]t 表示搜索 gret 和 grat，即在第四位是e或a的字符 同时使用 - 可以定义一个字符区间，如 [0-9] 可以表示10个数字，[A-Z] 表示26个大写字母 特例：[50-99] 真实的意义并不表示50-99这个数字区间，而是相当于 [5][0-9][9] 实际上就是0-9的区间；如果要表示50-99则应该分位进行搜索，即 [5-9][0-9] 定义例外字符集合 使用 ^ 定义在某文档中排除的字符，如 see[^mn] 表示排除掉以mn结尾的单词，[^a-z] 表示排除掉所有小写字母 处理特殊的字符对于 ] - ^ \\ 包围在 [] 中有时候需要进行转义，如 /var [[(] [0-9] [\\])]/ 表示数字由 [] 或 () 包围（后边的 ] 为了不与可选字符集合边界混淆需要进行转义） 字符集合的缩写 浅总结一下：小写 d w s 分别表示数字、数字和大小写、空白(包括空格、Tab、回车（\\r）和换行（\\n）)，大写的 D W S 就表示非前面说的字符 处理重复的“贪婪量词” * 表示指定字符重复0次或n词，+ 表示指定字符出现1次或n次，? 表示指定字符出现0次或一次。(注意：如果不加括号的话贪婪量词都只作用于紧跟着的前一个字符) 指定次数的重复使用 &#123;min, max&#125; 来指定重复次数，其中min必填且最小为0，而max可选 如 \\d&#123;4,&#125; 表示最小四位的的数字字串，\\d&#123;4&#125; 表示4位数字字串 注意默认情况下系统会自动匹配尽可能多的字符，而可以使用一种叫“Lazy Expression”的表达方式使其匹配尽可能少的字符—*? &#123;min, max&#125;? +? ??(其实就是重复量词后面加个？) 分组() 把若干个字符当作一个整体进行处理 多选一 使用 | 从多个选项中选择一个进行匹配，左边的选项具有高优先级。如 w(ie|ei)rd 匹配weird和wierd 字符串的开头与结尾 使用 ^ 来指定起始字符，如 ^\\d+[a-z]* 表示以至少一个数字开头，后面接任意个数的小写字母 使用 $ 来指定结束字符，如 ^\\d\\-[a-z]+$ 表示至少以一个小写字母为结尾的字符串，如 5-adfjk!!要注意的是正则表达式默认引擎都是singleline，即对于所行文本只会匹配最开头和最结尾的字符；想要匹配多行首尾字符则需要切换Multline anchors模式!! 处理单词的边界 使用 \\b 和 \\B 来代表单词的边界和非单词的边界，如匹配段落中的所有单词可以使用 \\b\\w+\\b 反向引用 可以使用 \\1 \\2 ... 来引用前面出现过的已经被 () 分组的字符组 由于一般正则表达式引擎都只能处理9个反向引用，我们使用 ?: 来指定某字符组不参与反向引用；如 (?:orange) and (peach) to \\1 会匹配到 orange and peach to peach 而不是 orange and peach to orange 断言 可以使用 ?= 给字符串加上条件判断以影响匹配进程，要注意的点是，?= 后的正则表达式并不会出现在匹配字符串中，他们只用来影响匹配进程 同时，使用判断后能够回到起点的断言，可以对一个字符串根据多个标准进行判断 可以使用 ?! 表示一个“否”断言，如 ?!.*4321 表示不包含4321的字串 使用 ?&lt;= 和 ?&lt;! 可以明确告知正则引擎进行断言回退，如 /(?&lt;=base)ball/ 表示如果发现了ball，就应回退检查其前面是不是base，若是则匹配 Java中对正则表达式的编译(pattern)和匹配(matcher)方法 在 String 类中，matches() 方法可以验证字符串是否符合指定的正则表达式，replaceAll() 方法可以将符合正则表达式的字符串替换为指定的字符串，split() 可以以正则表达式进行分割 如果某正则表达式需要用很多次，则可以先调用java.util.regex包中的 Pattern 类的 compile 方法得到一个“编译后”的 Pattern 对象，再调用其 matcher 方法得到一个 Matcher 对象，对 Matcher 对象调用它的 matches() 方法进行正则表达式验证，模板如下12345678 Pattern expression = Pattern.compile(&quot;...&quot;);String str1 = &quot;...&quot;Matcher matcher = expression.matcher(str1);while (matcher.find()) System.out.println(matcher.group()); Lesson8: Java中的继承、抽象类与接口 继承 指既具有父类的一切特性，同时又具有自己的独有特性，通常称为 IS_A 关系 继承的语法：class &lt;child class&gt; extends &lt;parent class&gt; &#123;&#125;，其中parent class和super class通常指某一类的直接上级，而base class通常指公共的基类 子类自动拥有父类声明为 public 和 protected 的成员，这也是继承特性的体现之一（下附继承条件下类的访问权限表） 声明 访问权限规则 public 外界自由访问 private 外界不可访问 protected 同一包中的子类、派生于同一父类的包的子类都可以访问 default 如果不指明任何权限，默认同一包中的类可以访问 使用继承类时，其实系统都会默认在第一行有一个 super(),而我们可以在第一行使用 super(variables) 来调用父类中参数匹配的其他功能；但无论如何，子类的构造方法在运行之前，必须调用父类的构造方法。 具体可以康康这个[[#^1f05af]] 以 final 声明的类不允许覆盖和更改，可以更加方便的用于多线程环境中 父类与子类之间的关系可以有以下三种： Extends(扩充): 子类中定义的方法在父类中没有同名方法 Override(覆盖&#x2F;重写): 子类和父类定义了完全一样的方法在“+”运算中，当一个变量和String类型变量执行操作时，系统会自动隐式调用其 toString() 方法将其转化为字符串类型变量；默认情况下该方法返回 &lt;class name&gt; + hashnode，而如果需要其输出其他有意义信息则可以在当前类中重写该 toString() 方法 注意一定要和父类方法一模一样！！否则就是重载(overload)了 Overload(重载): 子类和父类的方法名相同，但两者的参数类型或数不一样 抽象类 有abstract修饰的类称为抽象类;在方法前加上abstract就形成了抽象方法 抽象类只定义了什么方法应该存在，不能创建对象，必须派生出一个子类，并在子类中实现其未实现的方法之后，才能使用new关键字创建对象；抽象方法只有方法声明，没有实现代码。例： 1234abstract class person&#123; public abstract String getDesCription();&#125; 抽象类中可以包含非抽象方法和静态变量，即包含抽象方法的类一定是抽象类，但是抽象类中的方法不一定都是抽象方法 抽象类的三种类型 直接定义抽象方法 继承一个抽象父类，但没有包含所有父类中的抽象方法（如果包含了所有抽象方法就可以作为一个子类创建对象了，不再是抽象类） 实现了一个接口，但没有完全包含该接口所包含的抽象方法 抽象类的使用抽象类不能直接创建对象，通常用来引用子类对象，语法格式如下：&lt;abstract class&gt; &lt;abstract class variable&gt; = new &lt;child class from abstract class&gt; 抽象类的作用在我们进行程序设计时，可以先思考项目需要实现什么功能，这些功能步骤就相当于是抽象的行为，即抽象类；然后我们可以再通过继承方法，实现对应更为细致功能的类，以此实现模块化的程序设计 接口 定义一个接口使用关键字 interface，实现一个接口采用关键字 implements;接口的成员函数自动成为public的，数据成员自动成为static和final的。 接口使用语法：接口类型 接口类型的变量 = new 实现了接口的具体类型(); 接口的扩充：使用 extends 继承来扩充已有接口并实现一个新的接口；需要注意的是，实现子接口的类，必须实现“父”“子”接口所定义的所有方法，才能被实例化（即new出一个对象） 接口中定义常量：1234public interface ArrayBound&#123; public static final int lower_bound = 0; public static final int upper_bound = 0;&#125; 以这种方式定义的接口常量，只要被一个类声明实现，就可以直接使用这些常量(变量必须被初始化) 接口可以理解为，面向符合该接口设定类的一组需求 接口与抽象类的区别： 抽象类是一个不完全的类；接口则只表明类有哪些外部特征但不涉及具体实现细节 接口不具备继承特点，只是承诺了外部可调用的方法 一个类可以包含多个接口，但是只能继承一个父类 Lesson9: Java程序设计之多态 多态(polymorphism)：指相同的一条语句在不同的类中进行不同的解释，在不同的运行环境中能够运行出不同的结果 多态的最本质特征即父类（或接口）变量可以引用子类对象（或实现了接口的类），即将子类对象当作基类对象来使用，可以让更一般的对象容纳更具体化的对象：1Parent p = new child(); 基类变量与子类变量之间的赋值 子类对象可以直接赋给基类对象变量 基类对象赋给子类对象变量需要进行变量类型转换，语法为 &lt;child class variable&gt; = (child class)&lt;base class&gt;；可以使用 classA instanceof classB 来判断一个对象是否能转换成指定的类型，转换失败会抛出 ClassCastException 异常 当子类和父类具有同名方法，并且让一个父类变量引用一个子类变量时，具体调用哪个方法取决于对象本身的类型是父类还是子类 如果父类和子类中具有相同的字段，子类中访问方法会访问子类本身的方法，父类中的方法会被隐藏（如果确实需要访问使用 super 关键字）；而如果子类被当作父类使用时则会调用父类中的方法 当多个类实现同一接口中的方法时，针对这些类所创建的对象调用接口所定义的方法时，会分别调用相应的类的具体实现代码。同时，编译器在编译上述代码时采取“滞后绑定”(late bind)方法，即编译器在编译时并不知道调用了哪个方法如果没有进行强制转换，编译器会将所有都识别为父类的方法和字段值，因此在TestPolymorphism示例中输出的 value 值都是父类的100，而当我们进行强制转换后，经反编译我们可以看出编译器会进行 checkcast 操作识别出字符串值的具体归属 使用多态最大的好处即修改程序或是扩充系统时修改代码较少，且对其他代码部分的影响较小面向对象编程的思想就是，先构思过程，再细化每个过程涉及的相关数据，最后再针对具体数据完善对应的操作 小专题之快速幂和矩阵快速算法 快速幂算法基本步骤： 将指数n表示为其二进制形式。例如，将n表示为二进制数 $n &#x3D; b_k * 2^k + b_{k-1} * 2^{k-1} + … + b_1 * 2 + b_0$，其中 $b_i$ 表示二进制位的值（0或1），k 是二进制位数。 初始化一个变量 result 为 1，用于存储最终的计算结果。 从最高位开始，从左向右遍历二进制位。对于每一位 $b_i$，进行以下操作： 如果 $b_i$ &#x3D; 1，将 result 乘以底数（要求的数的幂），即 result &#x3D; result * base。 将底数 base 自乘一次，即 base &#x3D; base * base。 继续遍历下一位，重复步骤3，直到遍历完所有二进制位。 当遍历完所有位后，result 就包含了底数的n次幂的值。 快速幂代码示例1234567891011121314private static int FastNthRoot(int num, int sqrt)&#123; int base = num; int result = 1; while (sqrt &gt; 0) &#123; if ((sqrt&amp;1) == 1) &#123; result *= base; &#125; base *= base; sqrt = sqrt &gt;&gt; 1; &#125; return result;&#125; 矩阵快速乘法(斐波那契数列)： 使用矩阵来表示斐波那契数列关系式 F(n) = F(n-1) + F(n-2) 如下：$$\\begin{bmatrix}F(n) \\F(n-1)\\end{bmatrix}&#x3D;\\begin{bmatrix}1 &amp; 1 \\1 &amp; 0\\end{bmatrix}\\times\\begin{bmatrix}F(n-1) \\F(n-2)\\end{bmatrix}$$ 利用快速幂算法计算矩阵 $\\begin{bmatrix}1 &amp; 1 \\1 &amp; 0\\end{bmatrix}$ 的n-1次幂，结果矩阵的第[0][0]项就是斐波那契数列的第n项 小专题之位运算相关 位运算符号概览 符号 描述 运算规则 &amp; 与(且)运算 两位都为1时才返回1 | 或运算 两位都为0时才返回0 ^ 异或运算 两位相同为0，不同为1 ~ 取反运算 0变1，1变0 &lt;&lt; 左移运算 各二进位全部左移若干位，高位丢弃，低位补0 &gt;&gt; 右移运算 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 2. 按位与 &amp; 运算符 例如：3 &amp; 5 = 0011 &amp; 0101 = 0001, 故 3&amp;5 返回1 用途 清零：将各位与0进行相与操作，均返回为0 判断奇偶：只需根据二进制末位是0还是1来判断，即 if((a&amp;1)==0) 来判断是不是偶数(1的前几位都是0只有最后一位能产生效果) 按位或 | 运算符 例如：3 | 5 = 0011 | 0101 = 0111, 故 3|5 返回7 异或 ^ 运算符 交换律、结合律、自反性均成立 用途 与0相异或值不变 交换两个数(代码示例如下)123456789void Swap(int &amp;a, int &amp;b)&#123; if (a != b) &#123; a ^= b; b ^= a; a ^= b; &#125;&#125; 左移 &lt;&lt; 右移 &gt;&gt; 运算符 左移相当于各二进制位全部左移若干位，左边的位丢弃，右边补0；如 a = 10101110; a = a &lt;&lt; 2 执行操作后相当于 a = 10111000若舍弃的高位不含1，则每左移一位都相当于该数乘2 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃；如 a = a &gt;&gt; 2 执行操作后相当于 a = 00101011(a &gt; 0) 或 a = 11101011(a &lt; 0)操作数每右移一位相当于该数除二 Class4Lesson10: 泛型程序设计 泛型类 使用泛型的目的：限制集合能接收的数据类型，并且避免了类型转换的需要。语法一般为如 ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;(); 相关术语 ArrayList&lt;E&gt; 定义了一个泛型类型，E 称为“类型变量”或“类型参数” ArrayList&lt;Integer&gt; 称为“参数化的类型”，Integer 称为“实际类型参数”。 ArrayList 称为泛型类型 ArrayList&lt;E&gt; 的“原始类型(raw type)” 使用泛型可以减少类的数目，同时能在编译中检查代码中的类型错误 注意：Java7后语法变为：ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); 泛型对象具有自动装箱特性，即如 ArrayList&lt;Integer&gt; IntList = new ArrayList&lt;&gt;(); IntList.add(3); 实际上是按照 IntList.add(Integer.valueOf(3)); 来进行的；int n = IntList.get(0) 将被按照 int n = IntList.get(0).intValue() 来执行。因此在使用泛型类时应尽可能明确数据类型，防止在循环中过多出现装拆箱现象 泛型使用须知： 泛型参数必须是引用类型而不能是基本数据类型，即只能为 Double String Integer 等 不能定义泛型化数组 像 Pair&lt;String&gt;[] strPair = new Pair&lt;String&gt;[10] 是不可接受的 泛型类型不能直接创建实例 泛型类不能继承自 Throwable 类(Java中所有错误或异常的超类)，所以我们也不能直接捕获或抛出泛型类型的异常对象 不能定义静态 static 泛型成员 从泛型类中派生子类 不允许基类中具有泛型参数，即 class MyChild extends MyClass&lt;String&gt; 可以编译但 class MyChild extends MyClass&lt;T&gt; 是错误的 如果继承自泛型类的子类不指定实际类型参数，则泛型参数类型默认为 Object 泛型方法 泛型方法的定义123456789 class ArrayAlg &#123; public static &lt;T&gt; T getMiddle(T[ ] a) &#123; return a[a.length / 2]; &#125; &#125; String[] names = .../*下面的两句代码等价，编译器能自动推断传入参数的实际类型*/ String middle = ArrayAlg.&lt;String&gt;getMiddle(names); String middle = ArrayAlg.getMiddle(names); 泛型类同样可以接收 ... 定义的可变参数类型 泛型的多态特性 泛型多态特性实例12345678910 public class GenericPolymorphism &#123; public static void main(String[] args) &#123; List&lt;Number&gt; nums=new ArrayList&lt;Number&gt;(); nums.add(2); nums.add(3.14); for (Number number : nums) &#123; System.out.println(number.getClass()); &#125; &#125;&#125; 一个值得注意的点是，ArrayList&lt;Number&gt; 对象可以直接赋值给 List&lt;Number&gt; 变量 add() 方法奏效的原因是因为 Integer 和 Double 类都是 Number 类的子类 List&lt;Number&gt; 不是 List&lt;Integer&gt; 的基类型，所以","categories":[],"tags":[{"name":"Java语言学习","slug":"Java语言学习","permalink":"https://binisalegend.github.io/tags/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]}],"categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://binisalegend.github.io/tags/Python/"},{"name":"杂技学习","slug":"杂技学习","permalink":"https://binisalegend.github.io/tags/%E6%9D%82%E6%8A%80%E5%AD%A6%E4%B9%A0/"},{"name":"Java语言学习","slug":"Java语言学习","permalink":"https://binisalegend.github.io/tags/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]}