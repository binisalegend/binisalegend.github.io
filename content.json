{"meta":{"title":"Binisalegend的博客","subtitle":"","description":"","author":"Binisalegend","url":"https://binisalegend.github.io","root":"/"},"pages":[{"title":"锅中冰","date":"2023-11-08T05:01:42.000Z","updated":"2023-11-08T05:06:51.531Z","comments":true,"path":"about/index.html","permalink":"https://binisalegend.github.io/about/index.html","excerpt":"","text":"就读院校: 北京理工大学(Beijing Institude of Technology) 学院专业: 计算机学院-人工智能 Github主页: https://github.com/binisalegend 爱好: 羽毛球 古筝 篮球 旅行 吃吃吃 联系方式: &#50;&#52;&#52;&#x36;&#x34;&#55;&#57;&#48;&#48;&#x32;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109;"}],"posts":[{"title":"数据结构与算法","slug":"数据结构与算法","date":"2023-11-08T06:15:52.000Z","updated":"2023-11-08T06:19:41.075Z","comments":true,"path":"2023/11/08/数据结构与算法/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"本文是BIT大二上数据结构与算法课程的课程笔记","text":"本文是BIT大二上数据结构与算法课程的课程笔记 int swap(int &amp;a, int &amp;b) 为C++中的引用概念，本质上仍是取外部变量的地址，对变量赋 alias 后引用外部变量值，但是函数过程中对参数的更改不影响外部变量的值，而直接引用变量指针函数内直接调用地址，对原数据的状态保留不友好在C++中定义一个类之后，在类中可以定义 public 和 private 类型变量，其中 public 类型中可以直接进行外部访问，但注意当直接定义函数时，外部引用需要先使用 &lt;class&gt; variable 定义一个外部变量，再通过 variable.function 来调用类中的动态类型函数，或者应用 class *variable = new class() 后，再使用 variable-&gt;function 来调用函数；我们也可以在public中定义 static int 函数，这样在外部调用时就可以不用定义变量，直接使用 class::function 就可以调用函数 跳表：上图上代码 12345678910111213141516171819/* 如果存在 x, 返回 x 所在的节点， 否则返回 x 的后继节点 */ find(x) &#123; p = top; while (1) &#123; while (p-&gt;next-&gt;key &lt; x) &#123; p = p-&gt;next; &#125; if(p-&gt;next-&gt;key == x)&#123; return p-&gt;next; &#125; else if (p-&gt;down == NULL) &#123; return p-&gt;next; &#125; else p = p-&gt;down; &#125;&#125; 遍历一个 vector 类型数组的几种方法，主要用到的是 for (auto element : vector)，其他具体方法可以看这篇帖子C++中vector容器中元素输出（遍历）的5种方式 串的模式匹配算法：KMP算法基本想法是不移动原子串，移动要查找的模式串；定义一个 next 数组表示前后缀相同子串最长的长度12345678910111213141516171819202122int j = 0, k = -1;next[0] = -1;while (j &lt; S.length)&#123; if (k == -1 || S[j] == S[k]) &#123; j++; k++; if (S[j] != S[k]) &#123; next[j] = k; &#125; else &#123; next[j] =0 next[k]; &#125; &#125; else &#123; k = next[k]; &#125;&#125; 二叉树遍历方式转化： 后序遍历的最后一个字符一定是二叉树的根节点 根节点将中序遍历分成左右两子树 树相关知识点： 节点的度：节点拥有的子树数目，叶子结点的度为0 树的度：树中节点度的最大值","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://binisalegend.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++中的STL容器","slug":"C++中的STL容器","date":"2023-11-08T06:15:33.000Z","updated":"2023-11-08T07:14:38.224Z","comments":true,"path":"2023/11/08/C++中的STL容器/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/C++%E4%B8%AD%E7%9A%84STL%E5%AE%B9%E5%99%A8/","excerpt":"**C++ 标准模板库 (STL, Standard Template Library)**：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).","text":"**C++ 标准模板库 (STL, Standard Template Library)**：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators). 示例： 算法：sort(a.begin(), a.end()) 容器：priority_queue&lt;int&gt; pque 仿函数：greater&lt;int&gt;() 迭代器：vector&lt;int&gt;::iterator it = a.begin() 1 前言STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 往往 更顺利。 不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。 接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。 2 常用容器2.1 内容总览打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。 顺序容器 array vector deque forward_list list 关联容器 set map multiset multimap 无序关联容器 unordered_set unordered_map unordered_multiset unordered_multimap 容器适配器 stack queue priority_queue flat_set flat_map flat_multiset flat_multimap 字符串 string (basic_string&lt;char&gt;) 对与元组 pair tuple 2.2 向量 vector#include &lt;vector&gt; 连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。 2.2.1 常用方法构造vector&lt;类型&gt; arr(长度, [初值]) 时间复杂度：$O(n)$ 常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）. 123456vector&lt;int&gt; arr; // 构造int数组vector&lt;int&gt; arr(100); // 构造初始长100的int数组vector&lt;int&gt; arr(100, 1); // 构造初始长100的int数组，初值为1vector&lt;vector&lt;int&gt;&gt; mat(100, vector&lt;int&gt; ()); // 构造初始100行，不指定列数的二维数组vector&lt;vector&lt;int&gt;&gt; mat(100, vector&lt;int&gt; (666, -1)) // 构造初始100行，初始666列的二维数组，初值为-1 构造二维数组的奇葩写法，千万别用： 1234vector&lt;int&gt; arr[100]; // 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图vector&lt;int&gt; arr[100](100, 1); // 语法错误！vector&lt;int&gt; arr(100, 1)[100]; // 语法错误！vector&lt;int&gt; arr[100] &#123;&#123;100, 1&#125;, 这里省略98个 ,&#123;100, 1&#125;&#125;; // 正确但奇葩，使用列表初始化 尾接 &amp; 尾删 **.push_back(元素)**：在 vector 尾接一个元素，数组长度 $+1$. **.pop_back()**：删除 vector 尾部的一个元素，数组长度 $-1$ 时间复杂度：均摊 $O(1)$ 123456789// init: arr = []arr.push_back(1);// after: arr = [1]arr.push_back(2);// after: arr = [1, 2]arr.pop_back();// after: arr = [1]arr.pop_back();// after: arr = [] 中括号运算符和一般数组一样的作用 时间复杂度：$O(1)$ 获取长度.size() 获取当前 vector 的长度 时间复杂度：$O(1)$ 12for (int i = 0; i &lt; arr.size(); i++) cout &lt;&lt; a[i] &lt;&lt; endl; 清空.clear() 清空 vector 时间复杂度：$O(n)$ 判空.empty() 如果是空返回 true 反之返回 false. 时间复杂度：$O(1)$ 改变长度.resize(新长度, [默认值]) 修改 vector 的长度 如果是缩短，则删除多余的值 如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变） 时间复杂度：$O(n)$ 2.2.2 适用情形一般情况 vector 可以替换掉普通数组，除非该题卡常。 有些情况普通数组没法解决：$n\\times m$ 的矩阵，$1\\leq n,m\\leq 10^6$ 且 $n\\times m \\leq 10^6$ 如果用普通数组 int mat[1000010][1000010]，浪费内存，会导致 MLE。 如果使用 vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))，完美解决该问题。 另外，vector 的数据储存在堆空间中，不会爆栈。 2.2.3 注意事项提前指定长度如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 .push_back(). 因为 vector 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。 12345678// 优化前: 522msvector&lt;int&gt; a;for (int i = 0; i &lt; 1e8; i++) a.push_back(i);// 优化后: 259msvector&lt;int&gt; a(1e8);for (int i = 0; i &lt; a.size(); i++) a[i] = i; 当心 size_t 溢出vector 获取长度的方法 .size() 返回值类型为 size_t，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$. 12vector&lt;int&gt; a(65536);long long a = a.size() * a.size(); // 直接溢出变成0了 2.3 栈 stack#include &lt;stack&gt; 通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。 2.3.1 常用方法 作用 用法 示例 构造 stack&lt;类型&gt; stk stack&lt;int&gt; stk; 进栈 .push(元素) stk.push(1); 出栈 .pop() stk.pop(); 取栈顶 .top() int a = stk.top(); 查看大小 &#x2F; 清空 &#x2F; 判空 略 略 2.3.2 适用情形如果不卡常的话，就可以直接用它而不需要手写栈了。 另外，vector 也可以当栈用，vector 的 .back() 取尾部元素，就相当于取栈顶，.push_back() 相当于进栈，.pop_back() 相当于出栈。 2.3.3 注意事项不可访问内部元素！下面都是错误用法 1234for (int i = 0; i &lt; stk.size(); i++) cout &lt;&lt; stk[i] &lt;&lt; endl;for (auto ele : stk) cout &lt;&lt; stk &lt;&lt; endl; 2.4 队列 queue#include &lt;queue&gt; 通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。 2.4.1 常用方法 作用 用法 示例 构造 queue&lt;类型&gt; que queue&lt;int&gt; que; 进队 .push(元素) que.push(1); 出队 .pop() que.pop(); 取队首 .front() int a = que.front(); 取队尾 .back() int a = que.back(); 查看大小 &#x2F; 清空 &#x2F; 判空 略 略 2.4.2 适用情形如果不卡常的话，就可以直接用它而不需要手写队列了。 2.4.3 注意事项不可访问内部元素！下面都是错误用法 1234for (int i = 0; i &lt; que.size(); i++) cout &lt;&lt; que[i] &lt;&lt; endl;for (auto ele : que) cout &lt;&lt; ele &lt;&lt; endl; 2.5 优先队列 priority_queue#include &lt;queue&gt; 提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。 2.5.1 常用方法构造priority_queue&lt;类型, 容器, 比较器&gt; pque 类型：要储存的数据类型 容器：储存数据的底层容器，默认为 vector&lt;类型&gt;，竞赛中保持默认即可 比较器：比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义 12priority_queue&lt;int&gt; pque1; // 储存int的大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque2; // 储存int的小顶堆 对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。 其他 作用 用法 示例 进堆 .push(元素) que.push(1); 出堆 .pop() que.pop(); 取堆顶 .top() int a = que.top(); 查看大小 &#x2F; 判空 略 略 进出队复杂度 $O(\\log n)$，取堆顶 $O(1)$. 2.5.2 适用情形持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小&#x2F;最大的元素，元素数量 $n$，插入操作数量 $k$. 每次插入后进行快速排序：$k\\cdot n\\log n$ 使用优先队列维护：$k\\cdot\\log n$ 2.5.3 注意事项仅堆顶可读只可访问堆顶，其他元素都无法读取到。下面是错误用法： 1cout &lt;&lt; pque[1] &lt;&lt; endl; 所有元素不可写堆中所有元素是不可修改的。下面是错误用法： 12pque[1] = 2;pque.top() = 1; 如果你恰好要修改的是堆顶元素，那么是可以完成的： 123int tp = pque.top();pque.pop();pque.push(tp + 1); 2.6 集合 set#include &lt;set&gt; 提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。 集合三要素 解释 set multiset unordered_set 确定性 一个元素要么在集合中，要么不在 ✔ ✔ ✔ 互异性 一个元素仅可以在集合中出现一次 ✔ ❌（任意次） ✔ 无序性 集合中的元素是没有顺序的 ❌（从小到大） ❌（从小到大） ✔ 2.6.1 常用方法构造set&lt;类型, 比较器&gt; st 类型：要储存的数据类型 比较器：比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义 12set&lt;int&gt; st1; // 储存int的集合（从小到大）set&lt;int, greater&lt;int&gt;&gt; st2; // 储存int的集合（从大到小） 对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。 遍历可使用迭代器进行遍历： 12for (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); ++it) cout &lt;&lt; *it &lt;&lt; endl; 基于范围的循环（C++ 11）： 12for (auto &amp;ele : st) cout &lt;&lt; ele &lt;&lt; endl; 其他 作用 用法 示例 插入元素 .insert(元素) st.insert(1); 删除元素 .erase(元素) st.erase(2); 查找元素 .find(元素) auto it = st.find(1); 判断元素是否存在 .count(元素) st.count(3); 查看大小 &#x2F; 清空 &#x2F; 判空 略 略 增删查时间复杂度均为 $O(\\log n)$ 2.6.2 适用情形 元素去重：$[1,1,3,2,4,4]\\to[1,2,3,4]$ 维护顺序：$[1,5,3,7,9]\\to[1,3,5,7,9]$ 元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。 2.6.3 注意事项不存在下标索引set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。下面是错误用法： 1cout &lt;&lt; st[0] &lt;&lt; endl; 元素只读set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. 下面是错误用法： 12cout &lt;&lt; *st.begin() &lt;&lt; endl; // 正确。可读。*st.begin() = 1; // 错误！不可写！ 不可用迭代器计算下标set 的迭代器不能像 vector 一样相减得到下标。下面是错误用法： 12auto it = st.find(2); // 正确，返回2所在位置的迭代器。int idx = it - st.begin(); // 错误！不可相减得到下标。 2.7 映射 map#include &lt;map&gt; 提供对数时间的有序键值对结构。底层原理是红黑树。 映射：$$\\begin{matrix}1&amp;\\to&amp;2\\2&amp;\\to&amp;2\\3&amp;\\to&amp;1\\4&amp;\\to&amp;5\\&amp;\\vdots\\end{matrix}$$ 性质 解释 map multimap unordered_map 互异性 一个键仅可以在映射中出现一次 ✔ ❌（任意次） ✔ 无序性 键是没有顺序的 ❌（从小到大） ❌（从小到大） ✔ 2.7.1 常用方法构造map&lt;键类型, 值类型, 比较器&gt; mp 键类型：要储存键的数据类型 值类型：要储存值的数据类型 比较器：键比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义 12map&lt;int, int&gt; mp1; // int-&gt;int 的映射（键从小到大）map&lt;int, int, greater&lt;int&gt;&gt; st2; // int-&gt;int 的映射（键从大到小） 对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。 遍历可使用迭代器进行遍历： 12for (map&lt;int, int&gt;::iterator it = mp.begin(); it != mp.end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; &#x27; &#x27; &lt;&lt; it-&gt;second &lt;&lt; endl; 基于范围的循环（C++ 11）： 12for (auto &amp;pr : mp) cout &lt;&lt; pr.first &lt;&lt; &#x27; &#x27; &lt;&lt; pr.second &lt;&lt; endl; 结构化绑定 + 基于范围的循环（C++17）： 12for (auto &amp;[key, val] : mp) cout &lt;&lt; key &lt;&lt; &#x27; &#x27; &lt;&lt; val &lt;&lt; endl; 其他 作用 用法 示例 增 &#x2F; 改 &#x2F; 查元素 中括号 mp[1] = 2; 查元素（返回迭代器） .find(元素) auto it = mp.find(1); 删除元素 .erase(元素) mp.erase(2); 判断元素是否存在 .count(元素) mp.count(3); 查看大小 &#x2F; 清空 &#x2F; 判空 略 略 增删改查时间复杂度均为 $O(\\log n)$ 2.7.2 适用情形需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(map&lt;string, int&gt; mp) 2.7.3 注意事项中括号访问时默认值如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。 12345map&lt;char, int&gt; mp;cout &lt;&lt; mp.count(&#x27;a&#x27;) &lt;&lt; endl; // 0mp[&#x27;a&#x27;]; // 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了cout &lt;&lt; mp.count(&#x27;a&#x27;) &lt;&lt; endl; // 1cout &lt;&lt; mp[&#x27;a&#x27;] &lt;&lt; endl; // 0 不可用迭代器计算下标map 的迭代器不能像 vector 一样相减得到下标。下面是错误用法： 12auto it = mp.find(&#x27;a&#x27;); // 正确，返回2所在位置的迭代器。int idx = it - mp.begin(); // 错误！不可相减得到下标。 2.8 字符串 string#include &lt;string&gt; 顾名思义，就是储存字符串的。 2.8.1 常用方法构造构造函数：string(长度, 初值) 123string s1; // 构造字符串，为空string s2 = &quot;awa!&quot;; // 构造字符串，并赋值awa!string s3(10, &#x27;6&#x27;); // 构造字符串，通过构造函数构造为6666666666 输入输出C++ 123string s;cin &gt;&gt; s;cout &lt;&lt; s; C 12345string s;char buf[100];scanf(&quot;%s&quot;, &amp;buf);s = buf;printf(&quot;%s&quot;, s.c_str()); 其他 作用 用法 示例 修改、查询指定下标字符 [] s[1] = &#39;a&#39;; 是否相同 == if (s1 == s2) ... 字符串连接 + string s = s1 + s2; 尾接字符串 += s += &quot;awa&quot;; 取子串 .substr(起始下标, 子串长度) string sub = s.substr(2, 10); 查找字符串 .find(字符串, 起始下标) int pos = s.find(&quot;awa&quot;); 数值与字符串互转（C++11） 源 目的 函数 int &#x2F; long long &#x2F; float &#x2F; double &#x2F; long double string to_string() string int stoi() string long long stoll() string float stof() string double stod() string long double stold() 2.8.2 适用情形非常好用！建议直接把字符数组扔了，赶快投入 string 的怀抱。 2.8.3 注意事项尾接字符串一定要用 +=string 的 +&#x3D; 运算符，将会在原字符串原地尾接字符串。而 + 了再 &#x3D; 赋值，会先生成一个临时变量，在复制给 string. 通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。 123456789// 优化前: 15139msstring s;for (int i = 0; i &lt; 5e5; i++) s = s + &quot;a&quot;;// 优化后: &lt; 1ms (计时器显示0)string s;for (int i = 0; i &lt; 5e5; i++) s += &quot;a&quot;; .substr() 方法的奇葩参数一定要注意，C++ string 的取子串的第一个参数是子串起点下标，第二个参数是子串长度。 第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。 .find() 方法的复杂度该方法实现为暴力实现，时间复杂度为 $O(n^2)$. 不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法 2.9 二元组 pair#include &lt;utility&gt; 顾名思义，就是储存二元组的。 2.9.1 常用方法构造pair&lt;第一个值类型, 第二个值类型&gt; pr 第一个值类型：要储存的第一个值的数据类型 第二个值类型：要储存的第二个值的数据类型 1234pair&lt;int, int&gt; p1;pair&lt;int, long long&gt; p2;pair&lt;char, int&gt; p3;// ... 赋值老式 1pair&lt;int, char&gt; pr = make_pair(1, &#x27;a&#x27;); 列表构造 C++11 1pair&lt;int, char&gt; pr = &#123;1, &#x27;a&#x27;&#125;; 取值直接取值 取第一个值：.first 取第二个值：.second 123pair&lt;int, char&gt; pr = &#123;1, &#x27;a&#x27;&#125;;int awa = pr.first;char bwb = pr.second; 结构化绑定 C++17 12pair&lt;int, char&gt; pr = &#123;1, &#x27;a&#x27;&#125;;auto &amp;[awa, bwb] = pr; 判同直接用 == 运算符 123pair&lt;int, int&gt; p1 = &#123;1, 2&#125;;pair&lt;int, int&gt; p2 = &#123;1, 3&#125;;if (p1 == p2) &#123; ... &#125; // false 2.9.2 适用场景所有需要二元组的场景均可使用，效率和自己定义结构体差不多。 2.9.3 注意事项无 3 迭代器简介3.1 迭代器是什么？不搞抽象，直接举例。 对于一个 vector，我们可以用下标遍历： 12for (int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; endl; 我们同时也可以用迭代器来遍历： 12for (vector&lt;int&gt;::iterator it = a.begin(); it != a.end(); ++it) cout &lt;&lt; *it &lt;&lt; endl; a.begin() 是一个迭代器，指向的是第一个元素 a.end() 是一个迭代器，指向的是最后一个元素再后面一位 上述迭代器具有自增运算符，自增则迭代器向下一个元素移动 迭代器与指针相似，如果对它使用解引用运算符，即 *it，就能取到对应值了 3.2 为何需要迭代器？很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。 迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。 例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了： 12for (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); ++it) cout &lt;&lt; *it &lt;&lt; endl; 3.3 迭代器用法对于 vector 容器，它的迭代器功能比较完整，以它举例： .begin()：头迭代器 .end()：尾迭代器 .rbegin()：反向头迭代器 .rend()：反向尾迭代器 迭代器 + 整型：将迭代器向后移动 迭代器 - 整型：将迭代器向前移动 迭代器 ++：将迭代器向后移动 1 位 迭代器 --：将迭代器向前移动 1 位 迭代器 - 迭代器：两个迭代器的距离 prev(it)：返回 it 的前一个迭代器 next(it)：返回 it 的后一个迭代器 对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的） 3.4 常见问题.end() 和 .rend() 指向的位置是无意义的值 对于一个长度为 10 的数组：for (int i = 0; i &lt; 10; i++)，第 10 位是不可访问的 对于一个长度为 10 的容器：for (auto it = a.begin(); it != a.end(); ++it)，.end 是不可访问的 不同容器的迭代器功能可能不一样 迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。 删除操作时需要警惕 为什么 3 没删掉？ 12345vector&lt;int&gt; a&#123;1, 2, 3, 4&#125;;for (auto it = a.begin(); it != a.end(); ++it) if (*it == 2 || *it == 3) a.erase(it);// a = [1, 3, 4] 为啥 RE 了？ 1234vector&lt;int&gt; a&#123;1, 2, 3, 4&#125;;for (auto it = a.begin(); it != a.end(); ++it) if (*it == 4) a.erase(it); 建议：如无必要，别用迭代器操作容器。（遍历与访问没关系） 4 常用算法4.1 内容总览打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。 （很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的） 算法库 Algorithm count() find() fill() swap() reverse() shuffle() C++11 unique() sort() lower_bound() &#x2F; upper_bound() max() &#x2F; min() max_element() &#x2F; min_element() prev_permutation() &#x2F; next_permutation() 数学函数 cmath abs() exp() log() &#x2F; log10() &#x2F; log2() pow() sqrt() sin() &#x2F; cos() &#x2F; tan() asin() &#x2F; acos() &#x2F; atan() sinh() &#x2F; cosh() &#x2F; tanh() asinh() &#x2F; acosh() &#x2F; atanh() C++11 ceil() &#x2F; floor() round() C++11 数值算法 numeric iota() C++11 accumulate() gcd() C++17 lcm() C++17 伪随机数生成 random mt19937 random_device() 4.2 swap()交换两个变量的值 用法示例 12template&lt; class T &gt;void swap( T&amp; a, T&amp; b ); 1234567int a = 0, b = 1;swap(a, b);// now a = 1, b = 0int arr[10] &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;swap(arr[4], arr[6]);// now arr = &#123;0, 1, 2, 3, 6, 5, 4, 7, 8, 9&#125; 注意事项 这个 swap 参数是引用的，不需要像 C 语言一样取地址。 4.3 sort()使用快速排序给一个可迭代对象排序 用法示例 12template&lt; class RandomIt, class Compare &gt;void sort( RandomIt first, RandomIt last, Compare comp ); 默认排序从小到大 123vector&lt;int&gt; arr&#123;1, 9, 1, 9, 8, 1, 0&#125;;sort(arr.begin(), arr.end());// arr = [0, 1, 1, 1, 8, 9, 9] 如果要从大到小，则需要传比较器进去。 123vector&lt;int&gt; arr&#123;1, 9, 1, 9, 8, 1, 0&#125;;sort(arr.begin(), arr.end(), greater&lt;int&gt;());// arr = [9, 9, 8, 1, 1, 1, 0] 如果需要完成特殊比较，则需要手写比较器。 比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\\star$： 若 $a\\star b$，则比较器函数应当返回 true 若 $a\\not\\star b$，则比较器函数应当返回 false 注意：如果 $a&#x3D;b$，比较器函数必须返回 false 12345678910111213bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)&#123; if (a.second != b.second) return a.second &lt; b.second; return a.first &gt; b.first;&#125;int main()&#123; vector&lt;pair&lt;int, int&gt;&gt; arr&#123;&#123;1, 9&#125;, &#123;2, 9&#125;, &#123;8, 1&#125;, &#123;0, 0&#125;&#125;; sort(arr.begin(), arr.end(), cmp); // arr = [(0, 0), (8, 1), (2, 9), (1, 9)]&#125; 4.4 lower_bound() &#x2F; upper_bound()在已升序排序的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。找不到则返回尾迭代器。 lower_bound(): 寻找 $\\geq x$ 的第一个元素的位置 upper_bound(): 寻找 $&gt;x$ 的第一个元素的位置 怎么找 $\\leq x$ &#x2F; $&lt; x$ 的第一个元素呢？ $&gt;x$ 的第一个元素的前一个元素（如果有）便是 $\\leq x$ 的第一个元素 $\\geq x$ 的第一个元素的前一个元素（如果有）便是 $&lt;x$ 的第一个元素 返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。 用法示例 12template&lt; class ForwardIt, class T &gt;ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T&amp; value ); 1234vector&lt;int&gt; arr&#123;0, 1, 1, 1, 8, 9, 9&#125;;vector&lt;int&gt;::iterator it = lower_bound(arr.begin(), arr.end(), 7);int idx = it - arr.begin();// idx = 4 我们通常写成一行： 12345vector&lt;int&gt; arr&#123;0, 1, 1, 1, 8, 9, 9&#125;;idx = lower_bound(arr.begin(), arr.end(), 7) - arr.begin(); // 4idx = lower_bound(arr.begin(), arr.end(), 8) - arr.begin(); // 4idx = upper_bound(arr.begin(), arr.end(), 7) - arr.begin(); // 4idx = upper_bound(arr.begin(), arr.end(), 8) - arr.begin(); // 5 4.5 reverse()反转一个可迭代对象的元素顺序 用法示例 12template&lt; class BidirIt &gt;void reverse( BidirIt first, BidirIt last ); 12345vector&lt;int&gt; arr(10);iota(arr.begin(), arr.end(), 1);// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10reverse(arr.begin(), arr.end());// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 4.6 max() &#x2F; min()返回最大值 &#x2F; 最小值的数值 用法示例 12int mx = max(1, 2); // 2int mn = min(1, 2); // 1 在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了： 1234567// Before C++11int mx = max(max(1, 2), max(3, 4)); // 4int mn = min(min(1, 2), min(3, 4)); // 1// After C++11int mx = max(&#123;1, 2, 3, 4&#125;); // 4int mn = min(&#123;1, 2, 3, 4&#125;); // 1 4.7 unique()消除数组的重复相邻元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。 例如：$[1,1,4,5,1,4]\\to[1,4,5,1,4,\\underline?]$，下划线位置为返回的迭代器指向。 12template&lt; class ForwardIt &gt;ForwardIt unique( ForwardIt first, ForwardIt last ); 用法示例 单独使用 unique 并不能达成去重效果，因为它只消除相邻的重复元素。但是如果序列有序，那么它就能去重了。 但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\\to[1,2,4,5,\\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase. 最终，给 vector 去重的写法便是： 123vector&lt;int&gt; arr&#123;1, 2, 1, 4, 5, 4, 4&#125;;sort(arr.begin(), arr.end());arr.erase(unique(arr.begin(), arr.end()), arr.end()); 4.8 数学函数所有函数参数均支持 int &#x2F; long long &#x2F; float &#x2F; double &#x2F; long double 公式 示例 $f(x)&#x3D;\\lvert x\\rvert$ abs(-1.0) $f(x)&#x3D;e^x$ exp(2) $f(x)&#x3D;\\ln x$ log(3) $f(x,y)&#x3D;x^y$ pow(2, 3) $f(x)&#x3D;\\sqrt x$ sqrt(2) $f(x)&#x3D;\\lceil x\\rceil$ ceil(2.1) $f(x)&#x3D;\\lfloor x\\rfloor$ floor(2.1) $f(x)&#x3D;\\left&lt;x\\right&gt;$ rount(2.1) 注意事项 由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。 原文地址：https://codeforces.com/blog/entry/107717 $\\lfloor\\frac{a}{b}\\rfloor$ 别用：floor(1.0 * a / b) 要用：a / b $\\lceil\\frac{a}{b}\\rceil$ 别用：ceil(1.0 * a / b) 要用：(a + b - 1) / b （$\\lceil\\frac{a}{b}\\rceil&#x3D;\\lfloor\\frac{a+b-1}{b}\\rfloor$） $\\lfloor\\sqrt a\\rfloor$ 别用：(int) sqrt(a) 要用：二分查找 https://io.zouht.com/7.html $a^b$ 别用：pow(a, b) 要用：快速幂 https://io.zouht.com/18.html $\\lfloor\\log_2 a\\rfloor$ 别用：log2(a) 要用：__lg （不规范，但是这是竞赛）&#x2F; bit_width（C++20 可用） 4.9 gcd() &#x2F; lcm()（C++17）返回最大公因数 &#x2F; 最小公倍数 12int x = gcd(8, 12); // 4int y = lcm(8, 12); // 24 如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 __gcd(). 当然，gcd &#x2F; lcm 函数也挺好写，直接写也行（欧几里得算法）： 1234567891011int gcd(int a, int b)&#123; if (!b) return a; return gcd(b, a % b);&#125;int lcm(int a, int b)&#123; return a / gcd(a, b) * b;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://binisalegend.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"强化学习笔记","slug":"强化学习笔记","date":"2023-11-08T05:18:58.000Z","updated":"2023-11-08T06:25:31.643Z","comments":true,"path":"2023/11/08/强化学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"这个是自己学着玩的（bushi","text":"这个是自己学着玩的（bushi 强化学习概念介绍简单理解来说是一种通过试错来确定完成某项任务的最佳步骤的方法，其学习系统没有办法像一些机器学习一样被告知应该做出什么样的行为，需要通过不断尝试来发现如何实现奖赏值的最大化；当前行为不仅影响即时奖励，同样会影响下一步包括最终可能获得的奖励Concept：找到一个最佳策略 policy ,可以让本体 agent 在特定环境 environment 中，根据当前状态 state,做出行为 action, 从而获得最大回报 Return 机器狗强化学习实例(RoomDog.py)学习链接：一个简单的强化学习例子来理解Q-learning 强化学习Q-Learning算法学习笔记 应用算法: Q-Learning算法术语：state(状态)，action(行为) 丢！终于看懂怎么转化矩阵了，如下： 首先，简单思路是有几个房间，矩阵就有几行几列 可以将行列分别理解成 state 和 action，即例如从房间4去房间2就可以用矩阵元素[4, 2]的状态来表示 在路径连通与否的表示上，如果从A能到B，则[A,B]就表示为0，反之为-1；特别的，如果B是最终要到达的目的地，此时AB连通就应表示为一个较大的奖赏值R像题目中的房间联通情况 可以表示为 贝尔曼方程：}其中$Q(s, a)$表示当前的状态和行为，$Q(\\widetilde{s},\\widetilde{a})$表示下一过程的状态和行为,$\\gamma$表示位于0 1之间的折扣系数，表示模型的远见程度，$\\gamma$越小表示当下的Reward奖励函数越比未来的重要 Q-Learning的算法步骤 设置γ参数和R矩阵的环境奖励 初始化矩阵Q为0 对于每一个状态(1) 随机选择一个状态(2) do (while unreached the goal)a. 在当前状态所有可能的行动中选择一个b. 使用这个可能行动然后分析到达下一个状态c. 基于所有在当前状态下可能的行动获得最大值Qd. 理由贝尔曼方程计算当前状态下的Q","categories":[],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://binisalegend.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"}]},{"title":"大二上小学期程设解题思路","slug":"大二上小学期程设解题思路","date":"2023-11-08T05:14:46.000Z","updated":"2023-11-08T05:17:19.653Z","comments":true,"path":"2023/11/08/大二上小学期程设解题思路/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%B0%8F%E5%AD%A6%E6%9C%9F%E7%A8%8B%E8%AE%BE%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/","excerpt":"这是BIT大二上小学期开设的程序设计方法与实践课程，主要涉及到数据结构和算法基础，本人把自己的代码存放于此作为备份，同时每道题记录自己的思路和注意点，也欢迎大家进行批评指正","text":"这是BIT大二上小学期开设的程序设计方法与实践课程，主要涉及到数据结构和算法基础，本人把自己的代码存放于此作为备份，同时每道题记录自己的思路和注意点，也欢迎大家进行批评指正 本文涉及到的代码存放于Programming-Methods-and-Practice&#x2F;code · 郭忠滨&#x2F;Road-To-CSAI 感受算法魅力这章没有太多真正的算法，主要是灌输一些类算法的思想，例如二进制、栈思想、双指针等等 1. 猜数字看人品 解题思路：这道题感觉就是栈思想的初步展现吧，通过Tom回复或高或低，记录当前状态下可能正确值的最大和最小值。即不用记录下每个数据，只需要维护 too low 回复时的最大值，too high 回复时的最小值，当回复为 right on 时判断当前值是否位于最小最大值之间即可 代码实现由于仅仅判断第二个单词 high low on 就能够判断回复，所以可以定义两个字符数组，仅使用 strcmp 函数比较第二个字符输入即可；同时，由于可能有多组游戏进行，在每组游戏结束后一定要重置变量；最后，题目要求输入0之后程序立刻终止，故 scanf 输入数字语句要放到循环末尾，避免输入0后程序依然等待Tom的回复 2. 摘桃子 解题思路 + 代码实现这题首先要明确的是对于每一天能摘下的桃子只有当天和前一天的，以及有多少棵树就需要计算到 树的数量+1 天才能够算出摘下桃子的总数；当天的桃子数在计算完当天能摘下的桃子数量之后直接更新成剩下的桃子数量，继续计算下一天能摘下的桃子数量即可具体思路方面，当时做的时候什么算法都不会就闷头疯狂分类讨论，具体如下： Basic Case：分第一天的桃子是否能全部摘下，更新第一天的桃子数量为 0 或者 b[0] - v Recursion：分类讨论前一天剩下的桃子数量 b[n-1] 和今天的桃子数量 b[n] 相对于每天最多能摘下数量 v 之间的关系： b[n-1] &lt; v &amp;&amp; b[n] &lt; v ：分总计大于v或者总计小于v讨论 b[n-1] &gt;= v ：当日能摘数直接为v，b[n] 不变（因为前一天剩下的已经烂了） b[n] &gt;= v ：当日能摘数直接为v，前一天还没摘完 b[n] 就不变（上一种情况），前一天摘完了就更新成 b[n] + b[n-1] - v 3. 达拉崩吧的酒宴 解题思路这题的思路我自己理解是先拿具体的数字来试，比如6、7这样的，然后在稍微大一点的数字试验时，可以发现最基本的思路就是两个中有一个有毒，另一个就是安全的。比如1-10，就可以1-4、3-6、5-8这样每两组()包括最后的9.10都有两个数的重合,就可以再加一组判断两个的，这样就可以联想到二进制的问题，即都转化为二进制，每一位为1的都由一只小白鼠试验；只要对应位数的小白鼠死了，就说明这只小白鼠对应的位数是1。这样，最终就是根据酒的桶数转化为二进制最大位数是多少，就需要几只小白鼠。划分依据即为log2 代码实现有什么好实现的想明白log2就十行代码（bushi 4. 北湖挖坑 解题思路 这个本来我是直接用for循环遍历所有行的，就是如果碰到了高度高于当前行高度的说明被挡住了，但是这种做法时间复杂度直奔 O(n^2) ，可能优化一下能擦边过反正我是TLE 于是打羽毛球之前求助了一波浩哥，在当时看感觉很神奇，现在看来这道题就是最一开始灌输栈的思想，也许是当时不会C++所以只能做简单的出入栈，好像如果用C++调那个 deque 直接秒了具体思路是：设置一个变量 location 用于存放某个位置的高度(注意是变量而不是数组即可)，首先将第一个位置高度赋给 location ，进入循环后读取每个位置的高度 height。如果该位置高度高于 location 存储的值（如1 2、3 4、6 7 8、10 11），则说明当前高度与存储高度差需要被填补，所需填补次数为 height - location ，并将当前的 location 更新为 height 的值；反之，说明当前湖面处于下陷状态（如2 3、4 5 6、8 9 10、11 12），这时就不需要被填补，只需要把当前的 location 更新为 height 即可。 代码实现需要注意的点有：首先不能先当然直接开始循环，因为初始化的 location 和 height 都无法和输入数据的第一个变量相匹配，应该要在循环外先将变量初始化为第一块的高度；同时，在遍历完所有长度的高度后，还需要额外比较最后一块的高度，因为最后一块如果不是最大高度就始终需要被填补，因此最终需要填补的次数还要再加上 MaxLength - height_last 的值 5. 北湖深坑 解题思路这道题用到了双指针，相当于判定并记录两边的高度比较，如果有一个“凹下去的坑”就可以蓄水（我是真的看不明白NND）之所以不能从同一个方向遍历，是因为如果单方向一直下降，就会导致循环一直进行；而双指针则可以判定出某一个位置一定比最高点低，而当遍历到下一个高于最低点的时候就可以根据两者之间的高度差判断出蓄水量 代码实现双指针实现代码（希望我未来的某一天能看懂吧）123456789101112131415161718192021222324252627282930while (In &lt; Out)&#123; deep = height[Out]; while (height[In] &gt;= height[Out] &amp;&amp; In != Out) &#123; if (height[Out] &lt;= deep) &#123; tot_store += deep - height[Out]; &#125; else &#123; deep = height[Out]; &#125; Out--; &#125; deep = height[In] ; while (height[In] &lt; height[Out] &amp;&amp; In != Out) &#123; if (height[In] &lt;= deep) &#123; tot_store += deep - height[In]; &#125; else &#123; deep = height[In]; &#125; In++; &#125;&#125; 字符串处理、枚举本章主要讲了一些遍历枚举，以及像 strcpy strcmp strchr 等字符串函数的应用 6. A+B(I) 解题思路最一开始的时候看到这道题确实没经验，想着都转化成十进制加完再换回来只处理对齐不就行了，最后写完直接收获TLE被浩哥提醒2的100000次方还是太过荒谬于是开始重写（），当然这道题思路对了以后对下面那道超级恶心的升级版有不小的帮助首先当然是从末尾开始加，每一位的所得值其实可以看作是当前位置上两数相加再加上前一位的进位，当然写上去肯定不是这么写，最终位数显示应该是上面所得结果取余2的结果，而保留下的进位则是结果整除2后的所得计算过程中还有一个需要注意的点是所给两个二进制数的首位均为1的情况，这样会最后比原来数多出一位，记得单独讨论 代码实现 这题开始就涉及到了很多字符串操作了，特别注意 int 和 char 类型混合输入时要及时用 getchar() 吃掉输入末尾的回车 要引入一个通用变量 carry_bit 用来记录进位，这个变量可以从最后一位一直应用到结果位首，每一次遍历后的进位都用它记 剩下没啥好说的，个人认为这题就是只要你别怕累敢写就行 7. A+B(II) 解题思路这题是我所写行数最多的一道题，没有之一题目主要的难点我认为有两点：小数点对齐和位数保留问题可能我还需要感谢自己当初不会一些高级的算法，直接建了4个数组分别存两个数的整数和小数部分：但一开始还是想得太简单了，认为 scanf(%s.%s) 就能帮我分开整数部分和小数部分（现在想起这不是纯痴心妄想凭什么.不会被当字符存进去），后来咨询chatGPT使用了 strchr 函数在字符串输入中搜索小数点，将小数点所在位置替换为结束符 0 然后分别 strcpy 到两个数组里，具体代码看下面计算过程思路相对简单，即从小数部分开始遍历，carry_bit 记录进位，具体加法实施参照上面那个简单的计算过程完成，接下来才是这道题恶心的小数点对齐和删除前导0问题。对于小数点对齐，我才去的策略是找到最长的那个整数长度（因为小数部分长度是固定的，不可能再比最长的小数部分长或者短了就），然后有数输数没数打空格但是实际操作发现其实结果并不一定是最长的那个整数部分，因为有可能加完前面有没用的前导0，这时我采取判断是否为无用0的策略，若是就替换为空格，这样结果字符数组的长度就一定是三个字符数组最长的那个，可以作为基准还要注意不能想当然都输出小数点（如果两个加数都是整数就没有，这个需要设置flag在输入时判断有没有小数点），以及注意保留小数点前紧挨着的那个0（如 0.5 不能输出成 .5） 代码实现 字符数组搜索（小数点）后分区保存代码1234567891011121314151617char input1[10000]; scanf(&quot;%s&quot;, input1); // 读取整个输入字符串，包括小数点 char *decimal_point1 = strchr(input1, &#x27;.&#x27;); // 查找小数点的位置 if (decimal_point1 != NULL) &#123; *decimal_point1 = &#x27;\\0&#x27;; // 将小数点替换为字符串结束符 strcpy(number1_int, input1); // 复制整数部分到number1_int strcpy(number1_fra, decimal_point1 + 1); // 复制小数部分到number1_fra &#125; else &#123; strcpy(number1_int, input1); flag1 = 1; &#125; 判断是否为前导0并替换为空格代码1234567891011121314151617181920212223//删除结果里的垃圾0 if (result_int[length_int_result-1] == &#x27;0&#x27;) &#123; for (int search = length_int_result - 1; search &gt;= 0; search--) &#123; //判断是否为0.5这种情况，就不能删除这个0 if ((search == 0 &amp;&amp; result_int[1] == &#x27; &#x27;) || (result_int[0] == &#x27;0&#x27; &amp;&amp; length_int_result == 1)) &#123; break; &#125; //判断是前导0 if (result_int[search] == &#x27;0&#x27; &amp;&amp; result_int[search-1] == &#x27;0&#x27;) &#123; result_int[search] = &#x27; &#x27;; &#125; //判断前导0结束 else if (result_int[search] == &#x27;0&#x27; &amp;&amp; result_int[search-1] != &#x27;0&#x27;) &#123; result_int[search] = &#x27; &#x27;; break; &#125; &#125; &#125; 8. 发言统计 解题思路这题就是学了二维数组动态内存分配（虽然后面都屈服直接建最大值了），再算的话就是 strcmp 比较字符相同了 代码实现 二维数组动态内存分配代码1234567// 使用动态内存分配来存储多个字符串 char **loc = (char **)malloc(n * sizeof(char *)); for (int i = 0; i &lt; n; i++) &#123; loc[i] = (char *)malloc(10 * sizeof(char)); scanf(&quot;%s&quot;, loc[i]); &#125; 9. 解谜游戏 解题思路NND这个直接用上DFS（深度优先搜索，请看第五章），也不知道为什么要出在这，对我当时幼小的心灵造成了极大的创伤… 不过也算是从这道题开始我后面的题目都尽量将函数功能封装 具体思路上，就是我们发现某一行亮着的灯完全可以由按它正下面的灯来熄灭掉，也就是只要我们确定了第一行的灯亮灭情况，后续的按键方法就已经确定了，只需要判断最后能不能将灯全部熄灭即可 所以，我们可以开始封装功能函数了，首先是按下按钮状态变化函数 change() 和控制周边关联灯的亮灭情况的函数 convert()；接下来，我们需要一个转存函数 Unload()，用于在每次遍历中将全部密码锁情况转存到另一个数组中，避免因为一次遍历影响到后面的搜索；接下来是根据第一行按键情况遍历后面按键情况所需按键次数，并判断最后是否能使灯全部熄灭的函数 TimCalculation ，按下亮灯的下一行对应的灯，并最后判断最后一行是否还有亮着的灯即可（因为前面的灯一定都熄灭了）；最后是遍历第一行可能按键情况的DFS主函数 FirstLineCondition ，对于每一个灯都有按或不按两个选项（不按的选项可以通过按两次但是不加按键次数来替代情况），遍历完每个灯的两个情况再继续遍历下一个灯的情况，在遍历完第一行的所有灯之后进入 TimCalculation 函数开始计算和验证并更新最小按键次数 代码实现 首先要注意在获取输入时每一行末都需要 getchar() 吃空格 在 change() 和 convert() 函数参数传递过程中因为 change() 需要通过指针来影响按键状态在全局中的变化，所以在 convert() 函数传递参数记得要用 &amp;square[row][column] 来传入具体按键位置的地址，以及及时判断关联按键位置是否合法 10. 肥宅快乐串 解题思路这题的代码回头看去感觉写的依托答辩巨乱就，感觉其实思路并不难首先好像不能直接嵌套循环遍历所有字符搜索，时间复杂度太高了（虽然对于这道题只有一个用例过不去），于是参考讨论区大佬的思路换成每十个字符遍历一次，查看与fattyhappy的差异有几个字符，如果完全相同就直接换相同的字符；如果相差一个字符就在当前遍历字符左右（注意还有左哦！） 搜索有没有该位置上缺的那个字符；如果相差两个字符就直接看它俩换了是不是fattyhappy；有两个位置以上不相同就直接下一种 代码实现相同的点是还是要记得每次遍历后验证要把字符转存到一个新数组里，防止因为一次的交换影响后续遍历（或者换完如果不符合条件再换回来）（这题真别看代码 太抽象了 我都不想仔细再看一遍） 贪心、排序这章主要应用贪心算法，快排、归并排序等方法，因为我还是用C写的所以还学了 qsort 函数对结构、数组中某一元素进行排序的函数方法 11. 排兵布阵 解题思路这题感觉数学知识更多，首先是确定排队最终的纵坐标是所有纵坐标的中位数（我也不会解释，反正人家都说是中位数到一组数的距离之和最小）；对于横坐标我的理解过程是这样的，首先要找到一个类似基准点的东西，让所有横坐标都向这个基准点靠拢，并根据他们的横坐标排序来判断具体有多靠近这个基准点；这样我们就可以先按原本的横坐标进行排序，然后定义一个新的数组储存原本的坐标减去循环变量，这样相当于记下了每个变量相对于自己位置到目标点的距离，再对这个新的数组进行排序取中位数，最后算曼哈顿距离之和就好 代码实现按结构变量中的某一元素进行排序的 cmp 函数12345//为qsort函数准备的排序函数int cmpx( const void *a ,const void *b) &#123; return ((*(solider *)a)).x - ((*(solider *)b)).x;&#125; 12. 任务安排 解题思路这个题就是最经典的贪心问题，没有任何变式直接就是套公式具体算法就是先按结束时间进行从小到大排序，然后从头开始遍历，看下一个任务的开始时间是否在预存任务的结束时间之后，如果是则可完成任务数+1且预存任务更新为当前任务 代码实现贪心算法基本代码示例1234567891011qsort(loc, n, sizeof(loc[0]), cmp); int second = 0, first = 0; for (second = 1; second &lt; n; second++) &#123; if (loc[second].start &gt;= loc[first].end) &#123; count++; first = second; &#125; &#125; 13. 搬砖 解题思路这个题用到了归并排序，感觉跟二分搜索有类似之处：二分搜索是通过二分大小寻找一个符合条件的值，归并排序则是利用递归不断二分确定小部分的顺序排列最后进行合并归并排序的具体思路实现主要体现在归并排序主函数 Mergesort()，排序后合并数组函数 Merge()以及将排序后函数重新放到原数组的 copy() 函数。（我当时看了好多讲解都没看懂原理，感觉这个虽然是java代码但是讲的很清楚图解排序算法(四)之归并排序 - dreamcatcher-cx - 博客园 (cnblogs.com)） 代码实现Mergesort 函数是归并思路的体现，具体来说就是完成了两步工作：分成两半+排完拼回来12345//分两半 count += MergeSort(a, left, middle); count += MergeSort(a, middle + 1, right);//拼起来 count += Merge(a, loc, left, middle, right); Merge 函数则是完成了将两个排序好的数组拼起来的工作，具体来说可以理解成给两个数组分别设置一个指针，指针所在的数组元素较小的一方进入新数组，并且该数组指针向前移动，继续比较，注意要加上指针与临时数组位置的差值；如果另一个数组已经为空，就直接按顺序排入新数组即可；最后记得调用 copy 函数重置原数组 14. 水晶球 解题思路 感觉这道题理清思路后代码还是相对比较好实现的 首先由于最后我i们要输出制作水晶球石头的编号，所以可以建立一个结构数组，直接在输入中储存这块石头的编号 要明确的一点是，一块水晶能制作出水晶球的大小，取决于它三条边中最短的那条边，所以我们就很有必要在结构变量储存边长时直接把每块石头的三条边长短进行排序后再储存（如a最短边，b中等边，c最长边）因此我们在比较单个水晶石的时候，直接找出所有水晶石中，最短边大小最长的那块石头记录即可（可以结合在输入里直接维护最大值，少循环一次） 而在比较合并后是否有更大的水晶，我们需要明确，只有当最长边与第二长边相同结合而成的水晶，才有可能使最短边变长进而扩大水晶球半径。因此，我们可以考虑先优先按最长边从大到小排序，再按第二长边，以此类推操作结束后，能合并且有效的水晶石就会相邻，只需要遍历一次即可。 需要注意的是，合并以后之前的最短边有可能比第二长边长，所以要重新比较后再确定此时的水晶球半径，进而判断是否需要更新最大可制作半径 特别提醒！！一开始进行边长先排序再储存时一定要设置临时变量！！不然会导致后面排序的时候使用了已经排序过的变量 代码实现对结构元素进行优先级排序时的 cmp 函数1234567891011121314151617int cmp(const void *a, const void *b)&#123; SideLen *c = (SideLen *)a; SideLen *d = (SideLen *)b; if (c-&gt;c != d-&gt;c) &#123; return d-&gt;c - c-&gt;c; &#125; else if (c-&gt;b != d-&gt;b) &#123; return d-&gt;b - c-&gt;b; &#125; else &#123; return d-&gt;a - c-&gt;a; &#125;&#125; 15. 卡牌游戏 解题思路以下以n&#x3D;6举例，首先我们可以先分两种大情况：1在手牌中 1在牌堆里 1. 当1在手上时：我们所期待的牌堆位置是234560，这样我们只需要n&#x3D;6次即可将牌堆替换成期望的格式，那么此时我们只需要计算牌堆中在期待位置之后的牌的位置与期待位置的差值（因为如果一张牌在期待位置之前，它们会更早的到我们手牌中），并取它们中的最大值max_dis，在这个最大值max_dis所代表的操作次数后我们就可以保证所有的牌在我们需要使用它的时候都在我们手上，此时的总需要操作数即为 max_dis+n（如牌堆是003020，此时max_dis便是2与期待位置的差值4，所需次数为4+6&#x3D;10） 2.当1不在手上时：我们在这种情况下将561234视为我们的期待情况，此时我们可以再细分成两种情况，即1后的数字是否排成像1234这样的连续数字 如果1后面符合1234这样的排列，我们则比较1前面的数字是否都在期待位置之前（注意是之前！因为仔细观察可以看出此时的期待数列并不能直接放牌，只有在期待位置之前才能在我们需要放这张牌的时候确保手里有）。如果有任何一个数字在期待位置上或者之后，就说明如果直接跟在后面放牌，至少有一张牌我们在需要时手里没有，所以我们就需要把1拿出来再重新开始放牌（因为1后面符合排列所以1后面的都能满足”需要时手里有“），此时所需次数为 1的位置 + n（如牌堆为046012，期待位置是345612，4在期待位置上，如果直接放3我们接下来手里没4，所以要把1拿出来才能开始，所需次数为5+6&#x3D;11）；如果所有的数字都在期待位置之前，这样我们就可以直接放牌，所需次数就变成 n - 最后一个数（如牌堆为406012，期待位置是345612，直接放3每个数字都能顶出来，所需次数为6-2&#x3D;4）。 如果1后面不符合1234这样的排列，就直接表示我们不能在后面直接跟着放牌了，那么我们至少需要把1顶出来以后再放牌（即最小次数是 1的位置+n）。这时我们比较1后面的数是否在期待位置之后，如果没有任何一个数在期待位置之后，这样我们把1拿出来以后直接开始放1即可，后面所需都能顶出来，所需次数就是当前最小值 1的位置+n（如601304，期待位置是561234，把1拿出来直接放，所需次数为3+6&#x3D;9）；如果1后有数字在期待位置之后，我们只需要计算牌堆中在期待位置之后的牌的位置与期待位置的差值，并取它们中的最大值max_dis，在这个最大值max_dis所代表的操作次数后我们就可以保证所有的牌在我们需要使用它的时候都在我们手上，此时的总需要操作数即为 max_dis+n+1的位置（如601002，最大差值为2到期待位置的距离2，所以需要次数为2+3+6&#x3D;11） 代码实现没啥好说的 别怕累 简单数据结构这一章已经开始应用栈、队列的相关知识了，但是由于我还没有强迫自己用C++，所以这一章我在数据结构的使用上还是大部分使用了自建数组和头尾指针来进行数据结构的相关操作（像出入栈、进出队），也不知道未来还会不会再使用自建数据结构了，但是也做一个记录叭 16. 括号匹配 解题思路说起来好笑，这题原始思路竟然是我和舍友一起在华莱士店边炫边想出来的hhh一开始我们想的思路是把左右括号转换成1和-1，通过找加起来为0的就行。后来发现当然没这么简单，首先需要判断是否有根本没法匹配的字符串，一开始我以为只有 )()( 这样的，即第一和最后一个分别是右左括号，最后发现还可以这样 ()))(() 也是无法匹配的…. 借鉴了一下大佬的思路解决了，即右括号只有在没有左括号的时候才会计数，如果有左括号存在就直接抵消，最后如果左右括号数均不为零就说明这个字符串匹配不了。这是我觉得这道题转化过程中最妙的一环（详见代码部分）同时我们可以建立两个数组，储存等效有n个括号的字符串有几个，这样就可以匹配直接计数了 代码实现抵消储存括号机制代码12345678910111213141516171819202122for (long long t = 0; t &lt; len; t++)&#123; if (loc[t] == &#x27;(&#x27;) &#123; left++; &#125; else &#123; if (left &lt;= 0) &#123; right++; &#125; else &#123; left--; &#125; &#125;&#125;if ((left != 0) &amp;&amp; (right != 0))&#123; continue;&#125; 17. 看楼房 解题思路一开始以为这个和前面的[[#4. 北湖挖坑]]很像，做起来发现受到颜色判断的影响差距还是很大的有一个需要注意的点是，一开始本来想用 hashset 哈希函数来判断某个颜色是否出现过的，但是后来运行过程中发现有可能出现的情况是某一种颜色出现了两次但是只有一次被挡住了，但是这个颜色依然存在，所以就不能简单地通过 true false 来判断颜色了于是换个思路，用一个数组 hashset[color] 来记录一种颜色对应出现的次数每次循环都加一，再单独设置一个变量 count ，只要出现一种没出现过的颜色就加一，然后判断是否挡住了前面的楼房，如果被挡住了对应颜色的楼房数量就减一；这时再判断该颜色是否为0，如果为0说明这种颜色彻底没了，count--，并且去掉被挡住的楼房（出栈，用 stacksize-- 来实现）；最后让该遍历楼房入栈，记录下当前位置能看到的颜色 count 数量 代码实现自定义栈结构和出入栈操作示例代码1234567891011121314151617181920212223242526272829for (int i = 0; i &lt; n; i++)&#123; //判断颜色是不是重复的 if (hashSet[building[i].color] == 0) &#123; count++; &#125; hashSet[building[i].color] += 1; //看不见的楼房出栈 while (StackSize &gt; 0 &amp;&amp; Stacks[StackSize - 1].height &lt; building[i].height) &#123; if (hashSet[Stacks[StackSize - 1].color] &gt; 0) &#123; hashSet[Stacks[StackSize - 1].color] -= 1; if (hashSet[Stacks[StackSize - 1].color] == 0) &#123; count--; &#125; &#125; StackSize -= 1; &#125; Stacks[StackSize].color = building[i].color; Stacks[StackSize].height = building[i].height; color_nums[i] = count; StackSize++;&#125; 18. 填坑 I 解题思路这题大半夜写的，看了一个佬的思路直接秒了两道（向无名大佬致敬）总体思路就是，计算每个位置的高度与最高值差值取余2的值（(max - height[i]) % 2），如果当前所得值与前一个位置所得值相同，就直接让前一个位置出栈，相当于两个相邻的是一样的高度（或者能用１Ｘ２石头补齐），如果最后栈空或者栈长为1就说明一定可以填平 代码实现这个学到了一个读取到文件终止条件 while (scanf(&quot;%lld&quot;， &amp;n) != EOF) 就可以读取到文件终止啦，现在还只有在乐学特定题目中有用还是基本的出入栈自定义指针操作，可以用栈长来替代 19. 填坑 II 解题思路看完佬思路秒掉的第二题，再次感谢佬（bushi这个几乎可以直接照搬上面那道题的代码来做简单改动，这次题目限制了只能水平放了，所以代码情况中需要加上一些限制条件：首先基本思路上是这次我们就不能通过取余的方式来判断能否填平了（因为没法竖着放补上高度），所以就要直接比高度，高度相同才能出栈；其次，不能有“凹下去”的位置，即如果满足当前高度与前一块高度相同，还要继续判断再前面一块是否比当前高度低，如果低就直接不可能填平；最后，这次最后不能只简单判定栈长为1就可以了，必须要剩下的那块是最高高度才可以（这样才可以补周边的，如果不是最高的就没法填平） 代码实现就注意一下可以边输入边维护最大值叭（） 20. 选举 解题思路这题感觉是最荒谬的一题…一开始做完了没觉得有问题就是有两个过不了，自己把用例扒出来加了两个特例过了，最后发现是题目表述有问题直接改题了….感觉改完题就有点没意思，我也懒得改代码了，就直接按照原思路记记叭首先对本族最有利的投票方式当然是投给离自己最近且还没投票的异族人，这样既可以票出去一个人还可以让对面少一票。于是想到了记录每一个种族有多少票，即一开始统计一共有多少个冬马族和雪菜族人，在有一族人死完之前一直循环投票，如果输入是D族人：则先判定X族是否有票数，如果X有票说明它早就应该死了活不到现在，直接族人数量减一，X族的票数减一；如果X没有票说明D成功活下来了，入栈且D族票数加一。以此类推 代码实现在具体代码实现方案上还有许多细节，首先要建立两个储存族人顺序的数组 race[] loc[] ，即在第一次遍历中入栈的族人进入到另一个数组中，这样就可以重新保存第二轮的投票顺序，再第二轮投票开始之前清空原数组，改为从另一个数组向原数组转存活下来的族人，以此类推，但是每一族剩下的票数是可以一直留存的 查找、搜索从这章开始逼自己用C++写了，所以可能会调用 map deque queue vector 这些C++标准库这章主要是讲BFS（广度优先搜索）、DFS（深度优先搜索）、 21. 成语接龙 解题思路基本思路就是应用队列进出，如果第一个字符和上一个字符相同，并且该字符未被使用过，前一个字符出队，新字符入队；当搜索到结束成语时返回 代码实现感觉这道题思路并不难，只是代码具体实现上需要用到不少之前没用过的语法，需要注意的点如下： queue &lt;变量类型&gt; 队列名 可以直接建立一个队列，不需要再设置头尾指针进行出入队操作，只需要访问C++库函数如 .front() .push() .pop() .empty() 等 应用 scanf 可以使用 %*d 来忽略一个变量的输入 map &lt;key, value&gt; 是一个key与值一一对应的结构变量，在本题中由于只需要记录成语的头尾字符，所以可以用第一个字符作为key值一一对应到该成语的结尾字符，具体绑定代码为 &lt;map变量名&gt;[key].push_back(value) auto i: &lt;变量名&gt; 相当于令i在后续变量值中进行搜索，如搜索map类型变量所有key值为…的绑定值 22. 地下城与勇士 解题思路首先建立二维数组存储所有位置的情况，随后应用bfs光度搜索。还是借助队列，当队列不为空时设置变量等于队首，出队，判断其朝四个方向分别移动一步的情况，是否超出边界或者撞墙；如果遇到怪兽，应用 time % k == 0 判断怪物在当前时间是否存在。如果符合要求则入队，继续循环。需要注意的点是，由于怪物仅在k时间会消失且每一秒都必须前进，所以可能需要走“回头路”，故不能简单判断某一位置是否走过 代码实现 首先对于迷宫前进问题，可以建立向两方向前进的数组分别为 dx[4] = &#123;1, -1, 0, 0&#125;; dy[4] = &#123;0, 0, 1, -1&#125; ，这样就可以使用循环遍历朝四个方向前进的情况，步数 + 1 本题在应用 bool 类型变量判断一个位置是否经过时需要建立三维数组，采用这种方式即 already[x][y][time % k] == true ，这样就可以包含走回头路等怪兽消失的情况，也能包含初始点 S 之后也可以走的情况 由于每秒都必须走，所以可以直接用time来替代走过的步数 23. 带旋转的数独游戏 解题思路这题主打一个一开始一点不会，一点思路都没有那种…首先既然需要判断共16个4X4的小数独的旋转情况，就可以先判断小数独四条边的情况，通过旋转次数和四条边在旋转后的相对位置，应用dfs来判断16X16数独每条边是否符合要求，同时可以给4X4小数独进行编号，通过编号也可以推断出小数独的位置，从而进行最后的旋转方式输出 代码实现这题主要是代码的实现问题，需要推断不同变量之间的关系，具体如下： 将A-F转化为10-16，这样在判断最后的边是否符合要求时就可以直接通过边长总和是否为120来判断 通过16X16数组中数据的相对位置和4X4数组位置，推算出每个小数组四条边长的计算公式，如Part_Map[i][j][1] = Map[4*i-3][4*j-3] + Map[4*i-3][4*j-2] + Map[4*i-3][4*j-1] + Map[4*i-3][4*j]; 对16个4X4数组进行1-16编号，这样可以通过编号判断出该小数独在第几行第几列 应用dfs算法遍历16个小数独的旋转方式（转0-3次），累加记录当行数值之和，如果一行遍历结束后符合该行数值和等于120则清空记录数值，开始记录下一行 遍历完全部小数独以后，调用check函数判断列是否符合要求，这时需要根据旋转次数判断位于同一列上的数是之前定义的小数独的哪一条边，检验其和是否为120，若满足条件则更新此时所需的最小的旋转次数和小数独的旋转情况 最后在输出每个数独的具体旋转次数时可以通过遍历每个小数独之前dfs后的旋转次数来输出， 即 while(FinalTurn_cnt[i][j]--) 输出一次当前小数独所在的行列 24. 绳子切割 解题思路这题比较抽象的地方是它不告诉你要多长的绳子问你最多有几根，而是告诉要几根绳子问最长是多长，最终看讨论区找到思路用二分搜索具体思路大概是先找到一个中间长度，判断这个长度的绳子能不能剪出所要求的长度，能就继续搜索更长的一半，不能就搜索长度更短的一半 代码实现 首先要考虑一下干脆没法剪的情况，即绳子总长也小于要求的根数 之后就是二分搜索模板代就完了，循环遍历一直搜 ，记得考虑一下边界 25. 进圈 解题思路这个题跟[[#22. 地下城与勇士]]思路很像，就是记录每个位置的信息，通过建立队列出入队，向四个方向移动的数组遍历可能的移动情况。不同的是，这道题没有怪兽（bushi）但是可以在一秒之内在同一个方向移动k步，所以也需要遍历在一个方向上走了几步，并判断是否走过、撞墙或者超出边界 代码实现 由于输出的是最短需要时间，所以可以建立一个结构存放到达每个位置所需要的时间，每遍历一次行走时间+1，而同一方向的步数可以走最多k步 剩下就是同样的bfs, queue 建立队列，符合条件入队，遍历所有的情况直到队空就行，模仿一下[[#22. 地下城与勇士]]就行 动态规划这章主要就是动态规划相关的内容，其实感觉总结之前并不是太能理解，很多都是参考其他大佬的思路写完也是云里雾里，总体来说好像是找到状态转移方程，并且用内存换时间，相较于递归时间较快，因为每运行一次都会记录下生成的数据，在之后的遍历过程中就可以直接使用而不是再进行一次遍历了！！注意注意！！一定记得 dp[i][j] 中是有 i 个物品可供选择，背包最大承重为 j，而不是第 i 个物品！！切记！！ 26. 篮球练习 解题思路首先这道题感觉最容易想到的一定是递归，我一开始也是这么做的，本地运行没有问题，但是乐学上会TLE，没办法既然是在动态规划的专题那确实需要用动态规划做，于是乎开改。思路其实大体相同，就是能走到某一个点的方案数，是能走到它上面和左面点的方案数之和，如果这两个点中有小黑子防守的点则不算，一直搜索到要走的终点即可一开始使用递归做的时候我想的是如果在递归过程中遇到防守点位，就直接不算他；但是后来发现这种方式在我计算最上面一行和最左面一行会很难办，因为如果从起点到某个位置出现防守点，之前均有一种到法，出现以后就不可能到这个点。咨询了王总之后发现可以直接将防守点设置为0，初始化起点为1，然后一视同仁加就完了，这样就很好地解决了首行首列的问题 代码实现 只需要注意在应用bool数组判断某个点是否为防守位置时要先判断在不在范围内，如果不在会导致无效内存引用 同时，因为最后像 “20 20 19 19” 这样输入得出的路径数并不小，所以输出最终结果的数组记得要开 long long 27. 方向标 解题思路这题也是弄了很久都没搞懂，拖了好几天才问别人差不多搞明白了大体思路就是，对于每一个箭头所在的位置，都可以先判断一下其相对于上一行左点和右点的位置：如果在左点之左或是右点之右（例如上一行是 2 6，当前箭头在1 或 7这样的）就只有一种摆放方式（即6-&gt;1 或 2 -&gt;7），所以对于当前行的起始点的方案数量就要加上上一行的方案数（即 dp[i][left/right] += dp[i-1][j]）；而如果箭头的位置在上一行左右点之间（如上一行 2 6，当前行为4），那么以上一行的左右点为起始点就都可以（即 2-&gt;4, 6-&gt;4），所以就要左右两端点的方案数量都加上上一行的方案数量。最后遍历最顶端一行；所有位置的方案数量即可 代码实现不知道放啥，自己看代码叭 28. 考试 解题思路这个就是最标准的背包问题，我一开始不理解的是我想使用贪心算法，就是我把题目价值按从大到小排序，优先做价值高的题目做，如果时间还在要求之内就继续按价值搜索题目做。但是最后发现只能过三分之二的用例，看书以后发现好像是贪心算法最后可能会剩下位置，而剩下的位置利用价值远低于本来可以应用的价值，所以导致无法保证是最优解所以，没办法了，我开始学背包问题该咋做： 大概思路还是遍历，先初始化第一道试题，小于第一道试题所需时间的所给时间放不下，所以得分为0，大于第一套题所需时间的总时间得分就赋成第一道题的分数 然后循环开始，比较总时间和一道题所需时间，所给时间在0到较小值的情况分数不会增加，直接与做上一个数量的题的分数一致；对于时间大于等于做题所需时间小于总时间的情况，则比较做上一个数量题的分数和减去本题所需时间情况下做上一个数量题的分数加上本题分数的大小，取其较大值 感觉要说服自己的一点是，要为有N道题目、时间为T的所有情况均赋值，记录他们所得分数的情况 代码实现因为这道题是标准的背包问题，直接放代码，大部分背包问题都需要开二维数组记录某一情况下的结果值，为后续的遍历保留结果1234567891011121314151617181920212223242526long long CalculateMaxScore(int que_num, int total_time)&#123; int jMax = min(question[0].time-1, total_time); for (int i = 0; i &lt;= jMax; i++) &#123; score_rem[1][i] = 0; &#125; for (int i = question[0].time; i &lt;= total_time; i++) &#123; score_rem[1][i] = question[0].score; &#125; for (int i = 1; i &lt; que_num; i++) &#123; jMax = min(question[i].time-1, total_time); for (int j = 0; j &lt;= jMax; j++) &#123; score_rem[i+1][j] = score_rem[i][j]; &#125; for (int j = question[i].time; j &lt;= total_time; j++) &#123; score_rem[i+1][j] = max(score_rem[i][j], score_rem[i][j-question[i].time] + question[i].score); &#125; &#125; return score_rem[que_num][total_time];&#125; 29. 一道简单的背包题 解题思路这题一开始始终没弄明白如何表示能“恰好”放入背包，后来和大佬交流了一下其实就可以当作是普通的背包问题，特殊的点只在取余单位背包大小所得相同的物品其实可以看作是一种情况（举例来说，如果 V &#x3D; 5，那么对于8和13两种情况来说其实是等同的，因为想要恰好装下都需要取余 V 结果为2的物品大小来填补），所以就可以直接记录取余之后的值，并判断当前背包容量情况下的取法情况；而 MethodCount[i][j] = MethodCount[i-1][j] 语句则相当于记录背包问题中不取新增物品的情况，并在最后与取新增物品的情况数相加得到当前背包体积下所涵盖的情况 代码实现 取余背包问题代码123456789101112131415161718long long CalculateTotalMethods(int n, int V)&#123; MethodCount[0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; MethodCount[i][j] = MethodCount[i-1][j]; &#125; for (int j = 0; j &lt; V; j++) &#123; int k = (j + p[i] % V) % V; MethodCount[i][k] = (MethodCount[i-1][j] + MethodCount[i][k]) % MAX; &#125; &#125; return MethodCount[n][0] - 1;&#125; 30. 有一个人前来买瓜 解题思路这题感觉也很抽象，大概是因为我还是不太明白背包问题的整体思路叭… 看到讨论区里有大佬说是相当于背包问题加了个条件，试一下（）首先先遍历所有的瓜数量 i ，再从0开始遍历所有可能给出的最大瓜总重量 j， 然后从500开始向下遍历所有可能给出的成熟度最小值 k，分别判断当前可获得价值是否大于等于0（初始化记得均为-1）和遍历当前重量加上新增瓜重量是否小于最大值，则当前遍历下的最大价值即为 max(dp[j][k] + g[i], dp[j+w[i]][min(k+v[i], 500)])，个人感觉这一步就跟标准背包问题那个比较不加这个物品和加了这个物品剩余容量存之前的物品数加起来的价值哪个大有异曲同工之处 代码实现 这题理论上来看是一个三维的背包问题，但是建立三维数组分别存三个变量和最大买瓜价值会TLE，所以只能用二维数组 dp[weight][maturity] = value 来分别对应三个值，最后通过遍历符合条件的所有 dp[][] 来确定最大可能获得价值 个人感觉代码里 min(k+v[i], 500) 其实就是给出过要求成熟度的最大值为500，所以如果成熟度比500都大就没有意义了，相当于肯定能符合这个要求，所以直接按500算找最大值就行 感觉一开始我建立结构存四个变量的想法应该也能实现，但是最后参考的建三个数组 w[i] v[i] q[i] 相对调用更为简便 最后的遍历求最大可获得价值感觉有点绕，代码放下再来梳理一下叭123456789101112long long ResultOutput(int w, int v)&#123; long long result = -1; for (int i = 0; i &lt;= w; i++) &#123; for (int j = v; j &lt;= 500; j++) &#123; result = max(result, dp[i][j]); &#125; &#125; return result;&#125; 通过最后多次输入给出的实际最大总重和最小总成熟度，遍历所有总重小于要求和成熟度大于要求组合情况，比较他们所得最大价值并输出最大的 result 结语写到这里，大二上半学期小学期程序设计方法与实践的课程记录就结束啦。回首望去，三周全部工作就是坐在电脑前思考每节课后的题目，倒也不失是一种新的感受。也许未来的很长一段时间，我都很难再会面对这种纯粹的生活，但是每天与电脑上奇奇怪怪的代码打交道，一定会是我也许数年后的主旋律叭…再近一点，也希望这一篇记录，能为我今年后续数据结构与算法设计课程打下一点基础，这也是我使用Obsidian记录真正迈入计算机领域的第一篇完结文章，特此记录其打开了我未来CSAI学习之路的大门 记于2023.9.10","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://binisalegend.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Python学习笔记","slug":"Python学习笔记","date":"2023-11-08T05:14:00.000Z","updated":"2023-11-08T05:18:14.911Z","comments":true,"path":"2023/11/08/Python学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://binisalegend.github.io/tags/Python/"}]},{"title":"CS61A学习笔记","slug":"CS61A学习笔记","date":"2023-11-08T02:40:09.000Z","updated":"2023-11-08T03:32:44.884Z","comments":true,"path":"2023/11/08/CS61A学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/CS61A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本文是伯克利CS61A课程的配套学习笔记","text":"本文是伯克利CS61A课程的配套学习笔记 Lecture 3 : Control（函数控制）HW01 : Variables &amp; Functions, Control 可以给函数重新命名，或者理解为将一个函数的功能赋给另一个函数123456789from operator import add, sub def a_plus_abs_b(a, b): &quot;&quot;&quot;Return a+abs(b), but without calling abs.&quot;&quot;&quot; if b &gt;= 0: h = add else: h = sub return h(a, b) 这个理解不了一点，不知道那个with_if_statement干啥用的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def if_function(condition, true_result, false_result): &quot;&quot;&quot;Return true_result if condition is a true value, and false_result otherwise. &gt;&gt;&gt; if_function(True, 2, 3) 2 &gt;&gt;&gt; if_function(False, 2, 3) 3 &gt;&gt;&gt; if_function(3==2, 3+2, 3-2) 1 &gt;&gt;&gt; if_function(3&gt;2, 3+2, 3-2) 5 &quot;&quot;&quot; if condition: return true_result else: return false_result def with_if_statement(): &quot;&quot;&quot; &gt;&gt;&gt; result = with_if_statement() 47 &gt;&gt;&gt; print(result) None &quot;&quot;&quot; if cond(): return true_func() else: return false_func() def with_if_function(): &quot;&quot;&quot; &gt;&gt;&gt; result = with_if_function() 42 47 &gt;&gt;&gt; print(result) None &quot;&quot;&quot; return if_function(cond(), true_func(), false_func()) def cond(): &quot;*** YOUR CODE HERE ***&quot; return False def true_func(): &quot;*** YOUR CODE HERE ***&quot; print(42) def false_func(): &quot;*** YOUR CODE HERE ***&quot; print(47) def定义一个函数，如果给这个函数调用赋予变量名，系统只会打印定义该变量过程中的print，而不会返回return值，需要再次调用变量才会打印return；而如果不给函数调用赋予变量名，则视为直接计算函数值也会打印return值123456789101112def hailstone(x): print(x) cnt = 1 while x != 1: cnt += 1 if x % 2 == 0: x = x // 2 print(x) else: x = x * 3 + 1 print(x) return cnt ![[Pasted image 20230710114432.png]] Lab01: Variables &amp; Functions, Control 一些OK常用语句： 在输出行前打“DEBUG:”可以避免误识别print内容 python3 ok -q sum_digits -i 和 python3 ok -q sum_digits -trace没弄清楚啥意思，再摸索摸索（bushi python3 -q doctest &lt;文件名&gt; 可以运行程序中的测试 for i in range n: 语句表示从i到n-1，意思是包含i，但不包含n。字面意思，区分一下 Lecture 4:Higher-Order Functions（高阶函数）function example: sound 利用python进行三角波的形成和输出、整合，验证高级函数实用性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from wave import open from struct import Struct from math import floor frame_rate = 11025 def encode(x): &quot;&quot;&quot;Encode float x between -1 and 1 as two bytes. (See https://docs.python.org/3/library/struct.html)&quot;&quot;&quot; i = int(16384 * x) return Struct(&#x27;h&#x27;).pack(i) def play(sampler, name=&#x27;song.wav&#x27;, seconds=2): &quot;&quot;&quot;Write the output of a sampler function as a wav file. (See https://docs.python.org/3/library/wave.html) &quot;&quot;&quot; out = open(name, &#x27;wb&#x27;) out.setnchannels(1) out.setsampwidth(2) out.setframerate(frame_rate) t = 0 while t &lt; seconds * frame_rate: sample = sampler(t) out.writeframes(encode(sample)) t = t + 1 out.close() def tri(frequency, amplitude=0.3): &quot;&quot;&quot;A continuous triangle wave.&quot;&quot;&quot; period = frame_rate // frequency def sampler(t): saw_wave = t / period - floor(t / period + 0.5) tri_wave = 2 * abs(2 * saw_wave) - 1 return amplitude * tri_wave return sampler c_freq, e_freq, g_freq = 261.63, 329.63, 392.00 def both(f,g): return lambda t: f(t) + g(t) def note(f,start,end,fade=0.1): def sampler(t): seconds = t / frame_rate if seconds &lt; start: return 0 elif seconds &gt; end: return 0 elif seconds &lt; start + fade: return (seconds - start) / fade * f(t) elif seconds &gt; end - fade: return (end - seconds) / fade * f(t) else: return f(t) return sampler def mario_at(octave): c = tri(octave * c_freq) e = tri(octave * e_freq) g = tri(octave * g_freq) low_g = tri(octave * g_freq / 2) return mario(c, e, g, low_g) # c,e = tri(c_freq),tri(e_freq) # g,low_g = tri(g_freq),tri(g_freq/2) def mario(c, e, g, low_g): z = 0 song = note(e, z, z + 1/8) z += 1/8 song = both(song, note(e, z, z + 1/8)) z += 1/4 song = both(song, note(e, z, z + 1/8)) z += 1/4 song = both(song, note(c, z, z + 1/8)) z += 1/8 song = both(song, note(e, z, z + 1/8)) z += 1/4 song = both(song, note(g, z, z + 1/4)) z += 1/2 song = both(song, note(low_g, z, z + 1/4)) return song # play(both(note(c,0,1/4),note(e,1/2,1))) play(both(mario_at(1),mario_at(1/2))) # play(both(mario_at(1), mario_at(1/2))) Function Composition123456789101112131415def make_adder(n): def adder(k): return k + n return adder def square(x): return x * x def triple(x): return 3 * x def compose1(f,g): def h(x): return f(g(x)) return h Function Currying[[#^2f1599]] [[#^ecfc38]] 柯里化是一种将接受多个参数的函数转换为接受单个参数的函数序列的技术。1234567#应用def函数进行curryingdef curry2(f): def g(x): def h(y): return f(x,y) return h return g 123#应用lambda函数进行curryingdef curry1(f): return lambda x : lambda y : f(x,y) HW02 : Higher-Order Functions base和term()应用combiner算法进行计算时受到计算顺序的影响，不能任意调换顺序 ！记得考虑特殊情况1234567891011121314151617181920212223242526272829def accumulate(combiner, base, n, term): &quot;&quot;&quot;Return the result of combining the first n terms in a sequence and base. The terms to be combined are term(1), term(2), ..., term(n).combiner is a two-argument commutative function. &gt;&gt;&gt; accumulate(add, 0, 5, identity) # 0 + 1 + 2 + 3 + 4 + 5 15 &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5 26 &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 11 &gt;&gt;&gt; accumulate(add, 11, 3, square) # 11 + 1^2 + 2^2 + 3^2 25 &gt;&gt;&gt; accumulate(mul, 2, 3, square) # 2 * 1^2 * 2^2 * 3^2 72 &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square) 19 &gt;&gt;&gt; accumulate(lambda x, y: 2 * (x + y), 2, 3, square) 58 &gt;&gt;&gt; accumulate(lambda x, y: (x + y) % 17, 19, 20, square) 16 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if n != 0: x, loc = 2, combiner(base,term(1)) while x &lt;= n: loc = combiner(loc, term(x)) x += 1 print(loc) else: print(base) 应用accumulate函数用print函数会多打印一个None，用return就没问题1234def summation_using_accumulate(n, term): y = accumulate(add,0,n,term) return y &quot;&quot;&quot;print(y)&quot;&quot;&quot; sub是减，mul是乘… 返回值可以是函数，在compose1函数中的f(x)调用可以不指明 for循环中可以自动赋给未定义变量值为0，while循环不行123456789101112131415161718192021222324252627def compose1(func1, func2): &quot;&quot;&quot;Return a function f, such that f(x) = func1(func2(x)).&quot;&quot;&quot; def f(x): return func1(func2(x)) return f def make_repeater(func, n): &quot;&quot;&quot;Return the function that computes the nth application of func. &gt;&gt;&gt; add_three = make_repeater(increment, 3) &gt;&gt;&gt; add_three(5) 8 &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1 243 &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5)) 625 &gt;&gt;&gt; make_repeater(square, 4)(5) # square(square(square(square(5)))) 152587890625 &gt;&gt;&gt; make_repeater(square, 0)(5) # Yes, it makes sense to apply the function zero times! 5 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; f = func if n == 0: return identity for i in range(n-1): f = compose1(func, f) return f Lecture 5:Environment Diagrams（程序环境示意图）Environments for Higher-Order Functions12345def apply_twice(f,x): return f(f(x)) def square(x): return x * x Higher-Order Function Example:Repeat1234567def repeat(f,x): while f(x) != x: x = f(x) return x def g(y): return (y + 5) // 3 Environments for Nested Definitions 1234def make_adder(n): def adder(k): return k + n return adder 每一个创建的函数，它自身在哪个框架中创建，他的母函数就是那个框架的函数，在寻找变量值时，沿母函数层层向上搜寻知道全局框架，最先搜索到的值便是函数调用的值[[#^a02dcd]] Local Names 在嵌套定义中，母函数的形参可以在子函数中使用；而在相对独立的函数定义中一个函数无法找到和调用在另一个函数中定义的形参。 Lambda Expressions1. lambda表达式相关 lambda表达式是一个计算结果可以用某种方式解释的函数的表达式，当square被定义为“x * x”时，square仅仅作为一个数值存在；而当square被定义为一个关于x的lambda函数，它变成了一个具有具体调用地址的函数（甚至可以不定义lambda返回函数的名称而直接赋予形参具体值） lambda：A function with formal parameter x that returns the value of “x * x” No Return!!! 只能将单个表达式作为lambda函数的主体 2. lambda与def定义函数的区别 使用lambda定义时函数名为”lambda“形式的函数，而def语句定义函数名则为编程者赋予的函数名称，如下： Self-Reference12345def print_sums(x): print(x) def next_sum(y): return print_sums(x + y) return next_sum (好难解释md)第一次调用的参数是1-&gt;n,打印1，定义next_sum函数，调用3-&gt;k，这时第一次调用的print_sums函数返回next_sum函数，而next_sum函数返回print_sums(n+k–&gt;1+3)，即返回print_sums(4)，然后先打印4… Lab02: Higher-Order Functions, Lambda Expressions, Self ReferenceQ1: WWPD Lambda the Free 这个是真整体不咋理解，感觉没明白函数定义和返回，让我们过会来求助一波chatGPT老师（bushi）123456789101112131415161718192021222324252627282930&gt;&gt;&gt; def cake():... print(&#x27;beets&#x27;) ... def pie():... print(&#x27;sweets&#x27;) ... return &#x27;cake&#x27; ... return pie &gt;&gt;&gt; chocolate = cake()beets&gt;&gt;&gt; chocolateFunction&gt;&gt;&gt; chocolate()sweets&#x27;cake&#x27;&gt;&gt;&gt; more_chocolate, more_cake = chocolate(), cakesweets&gt;&gt;&gt; more_chocolate&#x27;cake&#x27;&gt;&gt;&gt; def snake(x, y): ... if cake == more_cake: ... return chocolate ... else: ... return x + y &gt;&gt;&gt; snake(10, 20)Function&gt;&gt;&gt; snake(10, 20)()sweets&#x27;cake&#x27;&gt;&gt;&gt; cake = &#x27;cake&#x27; &gt;&gt;&gt; snake(10, 20)30 感觉这个和上面那个例子有点异曲同工，就是定义变量名并且调用函数就会返回return值，但变量名没任何用好像（）（啊看不懂看不懂学不明白烦死了）123456&gt;&gt;&gt; onethousand = print_lambda(1000)1000&gt;&gt;&gt; onethousand&gt;&gt;&gt;&gt;&gt;&gt; print_lambda&lt;function &lt;lambda&gt; at 0x000001752468AE60&gt; Q3: Lambdas and Currying 哇！感觉头一次发现到lambda到底是干嘛用的（一直觉得是个摆设），暂时的理解是用来调用未定义的参数（def和lambda如下） 应用def调用： 123456def lambda_curry2(func): def function1(x): def function2(y): return func(x,y) return function2 return function1 应用lambda调用： 12def lambda_curry2(func): return lambda x : lambda y : func(x , y) ^2f1599 Q4: Count van Count 单纯觉得这个求质数的方法很有启发性，算是第一次让我对函数封装有了相对具体的认识吧… 就是先用count_factors函数计算出某个数的公约数，然后调用count_primes函数计算在n之内的所有质数的个数，其中调用is_prime函数利用count_factors函数判定是否符合质数条件（只有两个公约数）123456789101112131415161718192021222324252627282930def count_factors(n): &quot;&quot;&quot;Return the number of positive factors that n has. &gt;&gt;&gt; count_factors(6) 4 # 1, 2, 3, 6 &gt;&gt;&gt; count_factors(4) 3 # 1, 2, 4 &quot;&quot;&quot; i, count = 1, 0 while i &lt;= n: if n % i == 0: count += 1 i += 1 return count def count_primes(n): &quot;&quot;&quot;Return the number of prime numbers up to and including n. &gt;&gt;&gt; count_primes(6) 3 # 2, 3, 5 &gt;&gt;&gt; count_primes(13) 6 # 2, 3, 5, 7, 11, 13 &quot;&quot;&quot; i, count = 1, 0 while i &lt;= n: if is_prime(i): count += 1 i += 1 return count def is_prime(n): return count_factors(n) == 2 # only factors are 1 and n 暂时粗浅理解一下函数式编程吧，就是主函数的返回值尽可能都是一个函数，而调用一个主函数定义中没有显示的参数就要应用def或者lambda语句调用12345678910111213141516171819202122232425262728293031323334353637 &quot;&quot;&quot;Returns a function with one parameter N that counts all the numbers from 1 to N that satisfy the two-argument predicate function Condition, where the first argument for Condition is N and the second argument is the number from 1 to N. &gt;&gt;&gt; count_factors = count_cond(lambda n, i: n % i == 0) &gt;&gt;&gt; count_factors(2) # 1, 2 2 &gt;&gt;&gt; count_factors(4) # 1, 2, 4 3 &gt;&gt;&gt; count_factors(12) # 1, 2, 3, 4, 6, 12 6 &gt;&gt;&gt; is_prime = lambda n, i: count_factors(i) == 2 &gt;&gt;&gt; count_primes = count_cond(is_prime) &gt;&gt;&gt; count_primes(2) # 2 1 &gt;&gt;&gt; count_primes(3) # 2, 3 2 &gt;&gt;&gt; count_primes(4) # 2, 3 2 &gt;&gt;&gt; count_primes(5) # 2, 3, 5 3 &gt;&gt;&gt; count_primes(20) # 2, 3, 5, 7, 11, 13, 17, 19 8 &quot;&quot;&quot;def count_cond(condition): return lambda x: sum(1 for y in range(1, x+1) if condition(x, y))#这种方式用lambda函数，将condition(x,y)作为参数传给lambda，lambda函数接收一个参数x，然后使用range(1, x+1)生成从1到x的数字，对于每个数字y，如果满足条件condition(x, y)，则计数加1。最后，返回计数结果的总和。def count_cond(condition): def count_f(x): i,count = 1,0 while i &lt; x: if condition(x,i): count += 1 i += 1 return count return count_f#这种方式用def定义函数(个人认为更好理解一点)，注意返回值还是要一个函数而不是直接count（报错：NoneType那个） ^ecfc38 Q5: Both Paths 关于局部变量(nonlocal)和全局变量(global) 全局变量和局部变量（global和nonlocal）1234567g = 0 def global_test(): #global g g += 1 print(g)&gt;&gt;&gt; global_test&gt;&gt;&gt; UnboundLocalError: local variable &#x27;gcount&#x27; referenced before assignment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733~~~pythondef make_counter(): count = 0 def counter(): nonlocal count count += 1 return count return counter def make_counter_test(): mc = make_counter() print(mc()) print(mc()) print(mc()) make_counter_test()~~~ ```nonlocal```声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量。- python可以设定给一个参数默认值，当该参数调用时没有值则按默认值计算，若有值输入则按输入值，例：~~~pythondef root(x, degree=2): &quot;&quot;&quot;For example &gt;&gt;&gt; root(64) 8 &gt;&gt;&gt; root(64, 3) 4 &quot;&quot;&quot; return x ** (1 / degree)~~~- [ ] 这个...真不知道该说啥，就是说一整个没看懂好吧，最后感觉上是emmmm就是往S后面加U&amp;D？~~~pythondef both_paths(sofar=&quot;S&quot;): &quot;&quot;&quot; &gt;&gt;&gt; up, down = both_paths() S &gt;&gt;&gt; upup, updown = up() SU &gt;&gt;&gt; downup, downdown = down() SD &gt;&gt;&gt; _ = upup() SUU &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; upsofar = sofar downsofar = sofar def up(): nonlocal upsofar upsofar += &#x27;U&#x27; print(upsofar) return up, up def down(): nonlocal downsofar downsofar += &#x27;D&#x27; print(downsofar) return down , down print(sofar) return up,down~~~### Q7: Lambda the Environment Diagram- [ ] 这个也理解不了一点呢~真好呢（精神状态逐渐扭曲xie），就从f3 21就看不懂了哭...~~~pythona = lambda x: 2 * x + 1def b(b,x): return b(x + a(x))&gt;&gt;&gt; x = 3&gt;&gt;&gt; b(a,x)&gt;&gt;&gt; 21~~~![](./CS61A学习笔记/Pasted%20image%2020230712213717.png)### Q8: Composite Identity Function- 这个函数名已经足够反映我此时的心理状态了好吧...就是要调用函数调用函数，不能直接返回个值，不管是什么类型，都要先定义个函数和他的返回值，再返回那个函数~~~pythondef composite_identity(f, g): def xiande(y): if compose1(f,g)(y) == compose1(g,f)(y): return True else: return False return xiande~~~### Q9: I Heard You Liked Functions...- 好帅的递归，但不会(注意最后总函数的返回值缩进) 小小总结一下：就是这种1.2.3.1.2.3...类型的循环好像都可以用这种类型的递归，即定义一个函数（如本题的conmpose1），然后函数参数分别为当前值和下一个函数值，即```compose1(f2,cycle_f(n-1))```这种形式，之后再试试呐~~~~pythondef cycle(f1, f2, f3): def cycle_f(n): if n == 0: return lambda x : x elif n % 3 == 1: return compose1(f1,cycle_f(n-1)) elif n % 3 == 2: return compose1(f2,cycle_f(n-1)) else: return compose1(f3,cycle_f(n-1)) return cycle_f~~~## *Midterm1 Review*- ```print```函数始终返回```None```，在它被当作函数调用时同时输出他的参数（以空格分开）![](./CS61A学习笔记/Pasted%20image%2020230713091350.png)- 一个验证函数在调用参数时总是沿母函数层层相上搜索的例子，如下：我觉得最重要的一步理解就是```pirate```函数里调用的```arggg```是3，而真正应用于返回函数```plunder```的参数实际上是已经定义的```square```函数，因此本质上```add```的第一项就是4的平方![](./CS61A学习笔记/Pasted%20image%2020230713100856.png) ^a02dcd~~~pythonfrom operator import add,muldef square(x): return mul(x,x) def pirate(arggg): print(&#x27;matey&#x27;) def plunder(arggg): return arggg return plunder add(pirate(3)(square)(4),1)~~~## *Decorations*- 好像就是一个可以追踪高级函数运行过程的小玩意，但我的ucb不知道为什么运行不了（好像没装上这个库）~~~pythondef trace(fn): def traced(x): print(&#x27;Calling&#x27;,fn,&#x27;on argument&#x27;,x) return fn(x) return traced @trace def square(x): return x * x @trace def sum_squares_up_to(n): k = 1 total = 0 while k &lt;= n: total,k = total + square(k),k + 1 return total&quot;&quot;&quot;&gt;&gt;&gt; square(2)Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 24&gt;&gt;&gt; sum_squares_up_to(5)Calling &lt;function sum_squares_up_to at 0x0000015003B8AE60&gt; on argument 5Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 1Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 2Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 3Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 4Calling &lt;function square at 0x0000015003B8ADD0&gt; on argument 555&quot;&quot;&quot;~~~# Lecture 6: Recursion（递归）## *Recursive functions*- 递归的基本思路：首先具备一个```基本情况(basic case)```，然后在更复杂的函数求解过程中应用自身函数不断简化所求，使其更接近```基本情况(basic case)```~~~python #求各位之和（用递归）def split(n): return n // 10, n % 10 def sum_digits(n): #basic case if n &lt; 10: return n else: all_but_last, last = split(n) return sum_digits(all_but_last) + last~~~## *Recursion in Environment Diagrams*- 对比来看，应用```while```循环需要定义参数来进行跟踪统计，而运用递归则只需要计算机分不同框架来自动区分递归的步骤（参数少） ^5ca33e~~~pythondef fact_iter(n): total, k = 1, 1 while k &lt;= n: total, k = total * k, k + 1 return totaldef fact(n): if n == 0: return 1 else: return n * fact(n-1)~~~## Verifying Recursive Functions&lt;small&gt;老师管做递归叫信仰之跃(The Recursive Leap of Faith)笑死我了哈哈哈哈哈&lt;/small&gt;- 验证递归是否符合要求的步骤：[[#^5ca33e]] 1. Verify the base case. 验证基本情况（确定有一个情况是正确的） 2. Treat``` fact``` as a functional abstraction. 将函数看作一个函数抽象功能，不考虑这个函数如何实施，只考虑它会做什么（好抽象...） 3. Assume that ```fact(n-1)``` is correct. 假设```fact(n)```递归返回的第一个值```fact(n-1)```是正确的 4. Verify that ```fact(n)``` is correct, assuming that ```fact(n-1)``` correct 5. 代代特值（bushi）## *Mutual Recursion*### &lt;small&gt;Example: The Luhn algorithm&lt;/small&gt;- 感觉需要先给未来1000%看不懂这个例子是啥的我解释一下，就是一个现在国际上很通用的验证一些卡号的方法，具体如下： 1. 从右向左，从最右面第一个数字开始乘一，右起第二个数乘二，第三个数乘三...以此类推 2. 如果经过乘法运算后所得小于十则直接保留，如果大于十就返回其所得值的每位数字之和（如2 * 8 = 16则返回1 + 6 = 7） 3. 将整个号码每位返回值相加并且取10的余数即被称为判定位 ![](./CS61A学习笔记/Pasted%20image%2020230714014717.png)- 所以这个例子应用交互递归的点就在于一位数✖1另一位数✖2，因此需要两个分别为乘一乘二的函数的返回值都是彼此以达到变换效果^756591~~~pythondef split(n): #求前几位和末位 return n // 10, n % 10 def sum_digits(n): #求各位之和，在此示例中用来求*2后超过10的各位之和 if n &lt; 10: return n else: all_but_last, last = split(n) return sum_digits(all_but_last) + last def luhn_sum(n): #乘一的返回值，交互到乘二的函数 if n &lt; 10: return n else: all_but_last,last = split(n) return luhn_sum_double(all_but_last) + last def luhn_sum_double(n): #乘二的返回值，交互到乘一的函数 all_but_last,last = split(n) luhn_digit = sum_digits(2 * last) #超过十各位相加 if n &lt; 10: return luhn_digit else: return luhn_sum(all_but_last) + luhn_digit~~~## *Recursion and Iteration*- 从迭代```while```到递归，由于迭代是一种特殊的递归形式，所以只需要找到在不同迭代步骤中始终维护和保持的状态```n```并将其作为参数 ^afb04a~~~pythondef sum_digits_iter(n): digit_sum = 0 while n &gt; 0: n, last = split(n) digit_sum += last return digit_sum def sum_digits_rec(n,digit_sum): if n == 0: return digit_sum else: n, last = split(n) return sum_digits_rec(n,digit_sum)~~~## *Order of Recursive Calls*- Cascade Function: (级联函数) 这个例子为了证明即在任何一次函数递归中，直到执行其```return```值之前，这个函数递归都不会完成（例如本例中先执行```cascade(n//10)```再```print```）；同时，任何调用都能出现在递归调用之前或者之后；最后，在完成每个递归调用时，从最后一个递归调用逐级向上返回，直到返回第一次函数调用~~~pythondef cascade(n): if n &lt; 10: print(n) else: print(n) cascade(n//10) print(n) def cascade(n): print(n) if n &gt; 10: cascade(n//10) print(n)~~~## *Example: Inverse Cascade*- 打印逆向级联~~~pythondef f_then_g(f,g,n): if n: f(n) g(n) def inverse_cascade(n): grow(n) print(n) shrink(n)grow = lambda n: f_then_g(grow,print,n//10) shrink = lambda n: f_then_g(print,shrink,n//10) ~~~# Lecture 7: Tree Recursion（树递归）&lt;big&gt;树递归即指在某函数内有不止一次的函数递归调用，每个值都能转化为树状的基本结构直接返回对应的值&lt;/big&gt;## *Tree Recursion*~~~pythondef fib(n): #计算斐波那契数列 if n === 0: return 0 elif n == 1: return 1 else: return fib(n-1) +fib(n-2)~~~&lt;small&gt;（由于计算了很多重复值导致运行速度会慢）&lt;/small&gt;## *Example: Paths*&lt;small&gt;判断从一个m行n列的表格一角走向另一个对角有多少种可能的路径&lt;/small&gt;- Thinking: 在每一个格子时都有向上和向右两种走法，而不管往哪个方向走一格，问题都可以转化为剩余```m-1```或```n-1```个格子所具有的路径数量~~~pythondef paths(m,n): if m == 1 or n == 1: return 1 else: return path(m-1,n) + path(m,n-1)~~~## *Example: Knapsack*&lt;small&gt;判断n的各位数字组合能否等于k，可能等于返回True，反之返回False&lt;/small&gt;- u1s1这个是有点没看懂的，自己的理解大概是如果n有0位不影响加减所以直接返回```True```，然后```with_last```函数每次去掉最后一位后查看包含此步骤中n的最后一位能否满足条件，而```without_last```则表示不包含此步骤中的最后一位能否满足。 综上，这个函数主题应用树递归就是在n的每一位数都提供加上这位数字和不加上这位数字两种选择，以此来包含所有可能~~~pythondef knap(n,k): if n == 0: return k == 0 else: with_last = knap(n // 10, k - n % 10) without_last = knap(n // 10,k) return with_last or without_last~~~## *Example: Counting Partitions*- 计数分区：即定义一个函数```count_partitions(n,m)```，求出在单一分区最大为```m```的情况下，在```n```中能有多少种分区的组合。例如```count_partitions(6,4)```即有如下要求和9种解：![](./CS61A学习笔记/Pasted%20image%2020230714145032.png)- Thinking：要应用树递归的基本思路，即将所有情况分成两种情况，逐渐简化为基本情况，并且简化后的情况可以用原情况表示。本例中，可以先分为分区中有4的情况和分区中最大为3的情况。而对于第一种情况而言，可以视作求2的分区，即```n-m```的可能分区情况。如此，本例转化为的递归即为```count_partitions(n-m,m)```和```count_partitions(n,m-1)```的递归数总和，代码如下~~~pythondef count_partitions(n,m): if m == 0: return 0 elif n == 0: return 1 elif n &lt; 0: return 0 else: with_m = count_partitions(n-m, m) without_m = count_partitions(n, m-1) return with_m + without_m~~~## *Example: Binary Print*- [ ] （这节没听懂一点就是说）改日再会吧...## *Implementing Functions*- 这颗主要讲了一个程序填空题的解题思路吧，大概就是先理解框架，然后代入具体示例思考在每一步应该完成怎样的操作。~~~pythondef remove(n,digit): #删除n中为digit的数字 kept, digits = 0, 0 #digits常做计数器 while n &gt; 0 : n, last = n // 10, n % 10 if last != digit : kept = kept + last * 10 ** digits #利用digits实现位数转换 digits += 1 return kept#另一种思路def remove(n,digit): kept, digits = 0, 0 while n &gt; 0 : n, last = n // 10, n % 10 if last != digit : kept = kept / 10 + last digits += 1 return round(kept * 10 ** (digits - 1))~~~## *Lab03: Recursion, Tree Recursion*### Q2: WWPD: Journey to the Center of the Earth- [ ] 这个还是有点似懂非懂，就是单纯凭理解感觉是```70km 2900km 5300km 2900km 5300km 2900km```，但是实际上好像涉及函数调用嵌套，最后还有个函数定义（？~~~pythondef crust(): print(&quot;70km&quot;) def mantle(): print(&quot;2900km&quot;) def core(): print(&quot;5300km&quot;) return mantle() return core return mantle drill = crust drill = drill() # 70kmdrill = drill() # 2900kmdrill = drill() #5300km #2900kmdrill() #5300km #2900km #Function~~~![](./CS61A学习笔记/Pasted%20image%2020230715221249.png)### Q4: Repeated, repeated- 这个算是记一下自己的解题思路吧，就是先自然用```while```循环写了，然后想办法用递归替换迭代循环吧（让我们一起高呼：这就是GPT!） 在递归执行中因为直接返回```repeated(f,n-1)```所以就不需要```repeated_g```来作为&quot;中转&quot;（其实是不知道怎么能在全局变量里定义```repeated_g```的初始值且让这个语句就在递归里执行一次），所以就相当于直接赋给初始值```f(x)```~~~python#迭代while版def compose1(f, g): &quot;&quot;&quot;&quot;Return a function h, such that h(x) = f(g(x)).&quot;&quot;&quot; def h(x): return f(g(x)) return h def repeated(f,n): def repeated_f(x): if n == 0: return x elif n == 1: return f(x) else: i, repeated_g = 1, f while i &lt; n: repeated_g = compose1(f,repeated_g) i += 1 return repeated_g(x) return repeated_f#递归版def repeated(f,n): def repeated_f(x): if n == 0: return x else: return repeated(f, n-1)(f(x)) return repeated_f~~~### Q5: Num eights- 这个的抽象程度远超我想象...本来还想用就是先定义函数做出来然后再改，但最后咋也改不出来，借鉴了一下网上的: 就是我的理解是用一个```return 0```来表示所有位数都已经判断完毕并且初始化计数器为0，然后层层向上，如果该位数是8就返回值+1~~~pythondef num_eights(x): if x == 0: return 0 if x % 10 == 8: return num_eights(x // 10) + 1 return num_eights(x // 10)~~~### Q6: Ping-pong- 这题说真的是一点思路没有，看了网上大佬的代码后也用tutor理解了好久才勉强理解，我自己的理解大概是： 引入一个判定正负方向的判定值```flag```初始值为1，把所求的第```n```个```pingpong```数转化为上一个```pingpong```数和上一个```flag```的和，而根据```flag(x)```函数的定义，```flag```最终不是1就是-1（如果满足被8整除或者含8的条件，```flag(x)```等于```-flag(x-1)```，即前一个增减方向的相反，这样起到了改变增减方向的作用）~~~pythondef pingpong(n): def flag(x): if x == 1: return 1 if num_eights(x) or x % 8 == 0: return -flag(x-1) return flag(x-1) if n == 1: return 1 return pingpong(n-1) + flag(n-1)~~~## *HW03: Higher-Order Functions, Self Reference, Recursion, Tree Recursion*### Q1: Compose- [ ] 主打一个一个都不会做...我是真没办法透彻理解这个咋过来的，充其量能说服自己的一种理解是：(读题 认清```func```是所有嵌套 可能会想明白一点) ```composer(func)```函数直接收了一个参数```func()```，表示已有的全部函数嵌套；最终```func_adder(g)```实际上要返回一个```func(g(x))```的新函数，并把它作为参数```func()```传回给```composer()```函数，也就是添加了一个新函数进入所有函数的嵌套；最终返回```func```（已有嵌套函数）和```func_adder```（添加新函数工具函数） 对于这种两参数可以借鉴一下这个例子 [[#^afb04a]]~~~pythondef composer(func = lambda x: x): def func_adder(g): h = lambda x: func(g(x)) return composer(h) return func, func_adder~~~### Q2: G Function- 哦莫，终于做出来一个，记录一下递归和迭代的不同思路 需要注意的就是返回分清是返回函数还是具体值（即```g_iter_f```和```g_iter_f()```的区别）~~~pythondef g(n): #递归 if n &lt;= 3: return n else: return g(n-1) + 2 * g(n-2) + 3 * g(n-3)def g_iter(n): #迭代 def g_iter_f(): if n &lt;= 3: return n else: i, loc = 1, 0 while i &lt;= 3: loc += i * g(n - i) i += 1 return loc return g_iter_f()~~~### Q3: Missing Digits- 感觉很有必要先来记录以下这个在面对跟数字位数有关的问题是```all_but_last = n // 10```和```last = n % 10```的思路（每次看到恍然大悟自己想都想不到这个点）- 先读题读明白，```missing_digits(n)```提取的参数本身就是一个各位数字逐渐增大的参数，所以思路是从最后一位```last```和前一位```last_last```比较，如果相差小于等于1说明这两位数字之间没缺失，大于1说明缺失了```last - last_last - 1```个数字，然后用递归继续判定前```all_but_last```位数字；注意在```return```值中可以加上每次缺失的数字个数，这种返回方式可以类比一下这个[[#^756591]] 还有就是别忘了基本条件```basic case```，否则会一直递归（报错```RecursionError: maximum recursion depth exceeded in comparison```)~~~pythondef missing_digits(n): all_but_last, last = n // 10, n % 10 if all_but_last == 0: return 0 last_last = all_but_last % 10 if last - last_last &lt;= 1: miss = 0 else: miss = last - last_last - 1 return missing_digits(all_but_last) + miss~~~### Q4: Count Change- 类比类比and类比！这个整体思路就是应用上面计数分区[[#*Example Counting Partitions*]]的思路，分先用含最大的和不含最大的m进行分类 过程中遇到了一点小问题，就是在不应用```while```循环的情况下怎么求出小于```total```的最大m（也就是2的n次幂），求助了一下chatGPT老师给出的解决方案是转化为位运算（因为2的幂总是在二进制表示中只有一位是1，其他位都是0）。例如：7的二进制是111，共3位；所以将1向左移动2位得到100，转换为十进制就是4，是小于7最大的2的n次幂~~~pythondef count_change(total): def find_largest_power_of_two(x): # 将total转换为二进制字符串并得到其长度 binary_length = len(bin(x)) - 2 # 将1左移(binary_length - 1)位得到结果 n = 1 &lt;&lt; (binary_length - 1) return n m = find_largest_power_of_two(total) def count_change_f(total, m): if m == 1: return 1 elif total &lt; 0: return 0 else: with_m = count_change_f(total - m, m) without_m = count_change_f(total, m // 2) return with_m + without_m return count_change_f(total, m)~~~### Q5: Towers of Hanoi- 过年咯！感觉还是类比计数分区那个思路[[#*Example Counting Partitions*]]好吧，太有用了！这回变成```all_but_bottom```和```bottom```了，借助```print_move```函数来打印步骤，把每一个递归都理解成两个的思路，即```all_but_bottom: start-&gt;middle bottom: start-&gt;end all_but_bottom: middle-&gt;end```就搞定！ 中间就怎么定义这个```middle```又去寻求一下老师帮助，方法类似于定义数组，定义了一个包含所有可能数值的集合```all_numbers```，然后使用集合的差集操作```all_numbers - &#123;start, end&#125;```来找到除了```start```和```end```之外的那个元素。由于集合是无序的，我们可以使用``pop()``方法随机获取其中的一个元素，这样```middle```就会等于剩下的那个值。 虽然但是最后觉得自己像个傻子因为发现了：```middle = 6 - start - end```...~~~pythondef print_move(origin,destination): print(&quot;Move the top disk from rod&quot;, origin, &quot;to rod&quot;, destination) def move_stack(n, start, end): assert 1 &lt;= start &lt;= 3 and 1 &lt;= end &lt;= 3 and start != end, &quot;Bad start/end&quot; def find_middle(start, end): all_numbers = &#123;1, 2, 3&#125; x = (all_numbers - &#123;start, end&#125;).pop() return x middle = find_middle(start, end) if n == 1: return print_move(start, end) else: all_but_bottom = move_stack(n-1, start, middle) bottom = move_stack(1, start, end) all_but_bottom = move_stack(n-1, middle, end)~~~### Q6: Anonymous factorial- OK一朝回到解放前，又一道抽象题目...直接引用一下网上博主的解释 这道题要点，把函数当做参数传入，构造call, 在call里用lambda构造这个函数的behavior，这样就解决了迭代时需要函数名的问题。主要分为两部分: 1. 第一个括号： (lambda f: lambda k: f(f, k)) 构造一个需要f函数作为参数的函数，返回值是需要k为参数的函数，返回f函数的值，并且规定了f是一个需要2个参数的函数，f自身和k 2. 第二个括号：(lambda f , k: k if k == 1 else k * f(f, k-1) ) 这部分作为第一个括号的第一个call，构造f函数的行为，需要2个参数：f, k. 返回值为k或else后的值，if给出最简式，else给出，k和k-1的关系 3. 注意环境变量的变化，写成相同的名字便于理解，实际并不相同。~~~pythondef make_anonymous_factorial(): return (lambda f: lambda n: f(f,n))(lambda f, n: n if n == 1 else n * f(f, n-1))~~~# Lecture 8: Sequences &amp; Data Abstraction（序列与数据抽象）## *Lists*- 整体感觉就是C的数组，大括号```&#123;1，2，3，4&#125;```变成中括号```[1,2,3,4]```，另外还有些小tips和示例： ~~~python digits = [1, 2, 3, 4] len(digits) = 4 #判断数组长度 from operater import getitem digits[3] &lt;--&gt; getitem(digits, 3) #提取列表中第三个数 &gt;&gt;&gt; [2, 7] + digits * 2 &lt;--&gt; add([2, 7], mul(digits, 2)) [2, 7, 1, 2, 3, 4, 1, 2, 3, 4] &gt;&gt;&gt; pairs = [[10, 20], [30, 40]] &gt;&gt;&gt; pairs[1] [30, 40] &gt;&gt;&gt; pairs[1][0] 30 ~~~## *For Statements*- ```for```循环和```while```循环的用法功能对比：~~~python def count(s, value): total, index = 0, 0 #需要定义追踪变量index while index &lt; len(s): element = s[index] if element == value: total += 1 index += 1 return total def count(s, value): total = 0 for element in s: #不需要定义追踪变量，element初始化即为0且自增 if element == value: total += 1 return total&gt;&gt;&gt; pairs = [[1, 2], [2, 2], [3, 2], [4, 4]]&gt;&gt;&gt; same_count = 0&gt;&gt;&gt; for x, y in pairs: #固定长度序列中每个元素的名称... if x == y:... same_count += 1&gt;&gt;&gt; same_count2~~~- `for ... in ...`循环用法解释：~~~python&#x27;&#x27;&#x27;in表达式从（字符串、序列等）中依次取值，又称为遍历for-in遍历的对象必须是可迭代对象&#x27;&#x27;&#x27; &#x27;&#x27;&#x27;for-in的语法结构for 自定义变量 in 可迭代对象: 循环体&#x27;&#x27;&#x27; # 字符串中取值for item in &#x27;python&#x27;: print(item) # range产生一个整数序列，也是一个可迭代对象for i in range(10): print(i)# 如果在循环体中不需要用到自定义变量，可将自定义变量写为‘_’for _ in range(5): print(&#x27;人生苦短，我用python&#x27;)~~~## *Ranges*~~~python&gt;&gt;&gt; list[range(-2, 2)]list[range(-2, 2)]&gt;&gt;&gt; list(range(-2, 2))[-2, -1, 0, 1]&gt;&gt;&gt; list[range(4)]list[range(0, 4)]&gt;&gt;&gt; list(range(4))[0, 1, 2, 3]def cheer(): for _ in range(3): #无用用空格或者下划线代替 print(&#x27;Go bears!&#x27;)&gt;&gt;&gt; cheer()Go bears!Go bears!Go bears!~~~## *List Comprehensions*~~~pythonodds = [1, 3, 5, 7, 9]&gt;&gt;&gt; [x+1 for x in odds][2, 4, 6, 8, 10]&gt;&gt;&gt; [x for x in odds if 25 % x == 0][1, 5]def divisors(n): &quot;&quot;&quot;Return the integers that evenly divide n. &gt;&gt;&gt; divisors(1) [1] &gt;&gt;&gt; divisors(4) [1, 2] &gt;&gt;&gt; divisors(12) [1, 2, 3, 4, 6] &gt;&gt;&gt; [n for n in range(1, 1000) if sum(divisors(n)) == n] [1, 6, 28, 496] &quot;&quot;&quot; return [1] + [x for x in range(2, n) if n % x == 0]~~~## *Strings*- 对数组来说，一次只能查找一个元素；而对字符串序列来说可查找多个连续字符，如下：~~~python&gt;&gt;&gt; &#x27;here&#x27; in &quot;Where is Waldo?&quot;True&gt;&gt;&gt; 234 in [1, 2, 3, 4, 5]False&gt;&gt;&gt; [2, 3, 4] in [1, 2, 3, 4, 5]False~~~## *Data Abstraction*&lt;small&gt;Defination: A methodology by which functions enforce an abstraction barrier between representation and use&lt;/small&gt;- ```wishful thinking```通过保留有理数的分子分母来输出分数的准确值~~~pythondef mul_rational(x, y): return rational(numer(x) * numer(y), denom(x) * decom(y)) def add_rational(x, y): nx, dx = numer(x), denom(x) ny, dy = numer(y), denom(y) return rational(nx * dy + ny * dx, dx * dy) def equal_rational(x, y): return numer(x) * decom(y) == numer(y) * decom(x)~~~## *Representing Rational Numbers*- 在定义一个列表如```pair = [1, 2]```后，可以通过解包```x, y = pair```或者运用元素运算选择符```x = pair[0]```来调用列表内容，再或者用```getitem(pair, 0)```~~~pythonfrom fractions import gcd #Greatest common divisor def mul_rational(x, y): return rational(numer(x) * numer(y), denom(x) * denom(y)) def add_rational(x, y): nx, dx = numer(x), denom(x) ny, dy = numer(y), denom(y) return rational(nx * dy + ny * dx, dx * dy) def equal_rational(x, y): return numer(x) * denom(y) == numer(y) * denom(x) def rational(n, d): &quot;&quot;&quot;Construct a rational number that represents N/D&quot;&quot;&quot; g = gcd(n, d) return [n//g, d//g] def numer(x): &quot;&quot;&quot;Return the numerator of rational number x.&quot;&quot;&quot; return x[0] def denom(x): &quot;&quot;&quot;Return the denominator of rational number x.&quot;&quot;&quot; return x[1]~~~## *Abstraction Barriers*- [x] 没咋看懂 放段教材（bushi哦看懂了好像...感觉就是在函数内也尽量引用高层函数，例如```square_rational```引用```mul_rational```，确定了这两个函数的对应关系，即使在更改了选择构造器签名或者更改有理数实现的情况下，因为平方(```square```)等于两原数相乘这个关系始终不变，就不需要修改这个程序在继续更多复合数据和数据抽象的示例之前，让我们考虑一下有理数示例引发的一些问题。我们根据构造函数 `rational` 和选择器函数 `numer` 和 `denom` 来定义操作。一般来说，数据抽象的基本思想是确定一组基本操作，根据这些操作可以表达对某种值的所有操作，然后仅使用这些操作来操作数据。通过以这种方式限制操作的使用，在不改变程序行为的情况下改变抽象数据的表示会容易得多。对于有理数，程序的不同部分使用不同的操作来处理有理数，如此表中所述。|该程序的一部分...|把有理数当作...|仅使用...||---|---|---||使用有理数进行计算|整个数据值|`add_rational, mul_rational, rationals_are_equal, print_rational`||创建有理数或操作有理数|分子和分母|`rational, numer, denom`||为有理数实现选择器和构造器|二元列表|列表字面量和元素选择|在上面的每一层中，最后一列中的函数强制实施抽象障碍。这些功能会由更高层次调用，并使用较低层次的抽象实现。每当程序的一部分可以使用更高级别的函数而不是使用较低级别的函数时，就会违反抽象障碍。例如，计算有理数平方的函数最好用 `mul_rational` 实现，它不对有理数的实现做任何假设。```python&gt;&gt;&gt; def square_rational(x): return mul_rational(x, x) 直接引用分子和分母会违反一个抽象障碍。12&gt;&gt;&gt; def square_rational_violating_once(x): return rational(numer(x) * numer(x), denom(x) * denom(x)) 假设有理数会表示为双元素列表将违反两个抽象障碍。12&gt;&gt;&gt; def square_rational_violating_twice(x): return [x[0] * x[0], x[1] * x[1]] 抽象障碍使程序更易于维护和修改。依赖于特定表示的函数越少，想要更改该表示时所需的更改就越少。 计算有理数平方的所有这些实现都具有正确的行为，但只有第一个函数对未来的更改是健壮的。即使我们修改了有理数的表示，square_rational 函数也不需要更新。相比之下，当选择器函数或构造函数签名发生变化后，square_rational_violating_once 就需要更改，而只要有理数的实现发生变化，square_rational_violating_twice 就需要更新。 Data Representations维护抽象障碍的目的是为了可以更改数据表示，而不用重写整个程序 数据抽象的关键思想在于通过数据的行为来判断数据类型，而不是通过如何构造它，以下是一个示例，展示了通过修改程序内容而不修改程序表达的一个例子：123456789101112131415161718192021222324252627282930313233#在这种定义里应用列表，x作为数组列表def rational(n, d): &quot;&quot;&quot;Construct a rational number that represents N/D&quot;&quot;&quot; g = gcd(n, d) return [n//g, d//g] def numer(x): &quot;&quot;&quot;Return the numerator of rational number x.&quot;&quot;&quot; return x[0] def denom(x): &quot;&quot;&quot;Return the denominator of rational number x.&quot;&quot;&quot; return x[1]#在这种定义里应用高阶函数，x作为函数def rational(n, d): def select(name): if name == &#x27;n&#x27;: return n elif name == &#x27;d&#x27;: return d return selectdef numer(x): #这里x作为一个接收有理数（即rational函数）的函数参数 return x(&#x27;n&#x27;)def denom(x): return x(&#x27;d&#x27;)#结果都是如下&gt;&gt;&gt; x, y = rational(1, 2), rational(3, 8)&gt;&gt;&gt; print_rational(mul_rational(x, y))3 / 16 对于第二种定义方式可以这样理解：1234 x = rational(3, 8) numer(x)#对于numer函数相当于： return rational(&#x27;n&#x27;) #即返回3 61A Fall Lecture12 Video 6(Dictionary) Dictionary: 把键位key和值value联系起来，没有顺序，例如：12345&gt;&gt;&gt; numerals = &#123;&#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10&#125;&gt;&gt;&gt; numerals&#123;&#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10&#125; #这个换不换顺序都有可能，但都无所谓&gt;&gt;&gt; numerals[&#x27;X&#x27;] # &#123;dictionary&#125;[&#x27;Key&#x27;]用来在dictionary中搜索10 其中有键位keys，值values，和项目items三个变量，如下调用：123456789&gt;&gt;&gt; numerals.keys()dict_keys([&#x27;I&#x27;, &#x27;V&#x27;, &#x27;X&#x27;])&gt;&gt;&gt; numerals.values()dict_values([1, 5, 10])&gt;&gt;&gt; numerals.items()dict_items([(&#x27;I&#x27;, 1), (&#x27;V&#x27;, 5), (&#x27;X&#x27;, 10)])#如果不调用具体值则会类似显示函数地址或者结构变量，具体如下：&gt;&gt;&gt; numerals.keys&lt;built-in method keys of dict object at 0x0000014567D5FFC0&gt; 还可以应用dict构造函数来创建一个dictionary，例如：1234567&gt;&gt;&gt; items = [(&#x27;I&#x27;, 1), (&#x27;V&#x27;, 5), (&#x27;X&#x27;, 10)]&gt;&gt;&gt; items[(&#x27;I&#x27;, 1), (&#x27;V&#x27;, 5), (&#x27;X&#x27;, 10)]&gt;&gt;&gt; dict(items)&#123;&#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10&#125;&gt;&gt;&gt; dict(items)[&#x27;X&#x27;]10 可以判定一个key是否在dictionary中，应用语句&#39;X in numerals，系统返回True或者False；与此同时，如果不确定一个key是否在dictionary中，可以应用numerals.get(key, 默认值)函数，赋给想判断的key一个默认值，如果在dictionary中则返回dictionary中对应的值，如果不在dictionary中则返回get函数中所赋的默认值 一些特殊的以及一些限制 可以有如下定义：12345&gt;&gt;&gt; squares = &#123;x: x * x for x in range(10)&#125;&gt;&gt;&gt; squares&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81&#125;&gt;&gt;&gt; squares[7]49 一个key只能对应一个值value，这个值不局限于数字，也可以是列表等，但是key不能是列表list、目录dictionary或者任何可变的类型 Examples: Lists(List Functions) 这节东西好多好多，包含了很多就是列表list改变的函数首先要记住的一个小tips:切片slice [a, b]包含第a个元素但不包含第b个元素，[a:]同理包含a 我先截几张图，之后把这个做个列表在shell里试一下（好多…好烦…） 关于slice notation的一些解释：总结下来，a[-1]表示列表的最后一个值，a[:-1]表示列表除最后一个值以外的所有元素，a[::-1]表示从倒着输出列表元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; a = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;g&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;m&#x27;]&gt;&gt;&gt; b = a[:] # 列表切片，表示把列表a[]的值全部正序复制到列表b[]中&gt;&gt;&gt; print(b)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;]# b = a[n:m]表示列表切片，复制列表a[n]到a[m-1]的内容到新的列表对象b[]# 当n缺省时，默认为0，即a[:m]# 当m缺省时，默认到最后，即a[n:]&gt;&gt;&gt; b1 = a[1:4]&gt;&gt;&gt; print(b1)[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; b2 = a[:3]&gt;&gt;&gt; print(b2)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b3 = a[1:] #表示除第一个元素（编号为0）以后的全部元素&gt;&gt;&gt; print(b3)[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;]# b = a[i:j:s]这种格式呢，i,j与上面的一样，但s表示步进，缺省为1，s可以取任何数字.# 所以a[i:j:1]相当于a[i:j]&gt;&gt;&gt; b4 = a[1:5:2]&gt;&gt;&gt; print(b4)[&#x27;b&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; b5 = a[:5:-1] # 从末尾倒数取值&gt;&gt;&gt; print(b5)[&#x27;m&#x27;, &#x27;l&#x27;, &#x27;k&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; b6 = a[5::-2]&gt;&gt;&gt; print(b6) # 从a[n]处倒数取值[&#x27;f&#x27;, &#x27;d&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; b7 = a[::-1] # 倒着取值&gt;&gt;&gt; print(b7)[&#x27;m&#x27;, &#x27;l&#x27;, &#x27;k&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;f&#x27;, &#x27;e&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]&gt;&gt;&gt; b8 = a[-1] #最后一个值&gt;&gt;&gt; print(b8)&#x27;m&#x27;&gt;&gt;&gt; b9 = a[:-1] #除最后一个值以外的元素&gt;&gt;&gt; print(b9)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;l&#x27;] 以下表格所有条件均为：s = [2, 3] t = [5, 6] Operation(指令释义) Example(示例操作) Result(所得结果) append: adds one element to a listNOTES: 首先注意和extend的区别：是增加一个元素，即是把t作为列表加到s；如果t作为列表被函数调用，那么对t中元素的更改会影响调用t的s s.append(t)t = 0 s = [2, 3, [5, 6]]t = 0 extend: adds all elements in one list to another listNOTES: 首先注意和append的区别：是增加全部元素，即要把t里的全部元素加到s上；同样的t之后的改变也不影响s s.extend(t)t[1] = 0 s = [2, 3, 5, 6]t = [5, 0] addition &amp; slicing: creating new lists containing existing elementsNOTES: 首先，类似于b &#x3D; a[1:]这种slice操作，所得首先是一个列表！！！(这个有坑在下面）；其次，用于a是将t作为列表与s相加，故对b[1][1]修改实际上是在对t中元素的修改，故既会影响a也会影响t a = s + [t]b = a[1:]a[1] = 9b[1][1] = 0 s = [2, 3]t = [5, 0]a = [2, 9, [5, 0]]b = [3, [5, 0]] list function: creating new lists containing existing elements t = list(s)s[1] = 0 s = [2, 0]t = [2, 3] slice assignment: replaces a slice with new valuesNOTES: 理解c[a:a] &#x3D; b就是把b变成c的第a位，其他的全部按上边的tips(含前不含后)考虑 s[0: 0] = ts[3:] = tt[1] = 0 s = [5, 6, 2, 5, 6]t = [5, 0] pop: removes &amp; returns the last elementNOTES: 既移除s的最后一位元素，同时将元素赋给t（注意是元素不是列表） t = s.pop() s = [2]t = 3 remove: removes the first element equal to the argument t.extend(t)t.remove(5) s = [2, 3]t = [6, 5, 6] slice assignment: remove elements to a list by assigning [] to a slice s[:1] = []t[0: 2] = [] s = [3]t = [] 对下面的 Lab 4: Python Lists, Data AbstractionQ2: Reverse (iteratively) 类比一下C语言里面数组指针的特殊性 上面这个是自己写的，有个很明显的缺陷就是定义数组只有4位（这个相当于占了知道示例的便宜123456789def reverse_iter(lst): n, i = len(lst), 0 # a = lst # 如果这里这样定义，在更改a中元素的同时lst的元素也会被更改 a = [0, 0, 0, 0] while i &lt; n: a[i] = lst[n - i - 1] i += 1 return a 之后这个是大佬的代码，借助了for循环的迭代用法和列表的加法顺序性质12345def reverse_iter(lst): ans = [] for x in lst: ans = [x] + ans return ans （关于for-in循环的用法详见[[#For Statements]]） Q3: Reverse (recursively) 具体思路请详见上一个[[#Examples Lists(List Functions)]]中有关list[-1]和list[:-1]的解释把握住递归的basecase+recursion的结构[[#Recursive functions]]1234def reverse_recursion(lst): if not lst: return [] return [lst[-1]] + reverse_recursion(lst[:-1]) Q5: Closer city 学一个选择返回的语句123456if distance_a &lt; distance_b: return get_name(city_a) else: return get_name(city_b)#等效于return get_name(city_a) if distance_a &lt; distance_b else get_name(city_b) Q7: Add Characters 就告诉自己一句话：别怕递归！按思路走[[#Recursive functions]]，对于字符串的基本情况记得考虑一下len(list) == 01234567def add_chars(w1, w2): if len(w1) == 0: return &quot;&quot; #OK犯病不知道为什么这里新建空字符串和返回空字符串都不行，就要我返回w1或者w2 if w1[0] == w2[0]: return add_chars(w1[1:], w2[1:]) return w2[0] + add_chars(w1, w2[1:]) Lecture 9: Functional Decomposition &amp; Debugging（功能分解与调试）Assertions assert函数为断言函数，用来检查代码是否符合已有的理解。如果函数表达式的结果为真则没有任何效果产生，如果之后的表达式结果为假则返回预先设置好的报错信息，可以去看一下之前汉诺塔那个事例中用过[[#Q5 Towers of Hanoi]] isinstance(数据, 数据类型)函数则是一个判断所给数据是否为指定数据类型的函数，是则返回True，反之返回False具体的代码实现如下：12345678910111213def fact(x): assert isinstance(x, int) assert x &gt;= 0 if x == 0: return 1 else: return x * fact(x-1)def half_fact(x): return fact(x / 2)&gt;&gt;&gt; half_fact(5)None #调用fact函数时变量2.5不符合int整数类型 Testing 调试程序能够发现程序中的错误，同时让我们能够保证某一个程序小组块的正确性，进而缩小未来可能需要的调试范围，也能够记录下程序的运行过程 Python所提供的具体的调试方案即doctest函数，具体的执行方式为python3 -m doctest filename.py，实现测试的代码模板如下：12345678def f(n): &quot;&quot;&quot;对函数功能的解释 &gt;&gt;&gt; f(1) #第一个函数验证测试示例 1 #第一个函数期待返回的结果值 &gt;&gt;&gt; f(2) 2 &quot;&quot;&quot; #...具体函数代码 Print Debugging 即应用打印过程值的方式来观察代码运行步骤，以起到检测调试代码的效果1234567891011121314151617def fact(x): # assert isinstance(x, int) # assert x &gt;= 0 print(&quot;Debug x = &quot;, x) if x == 0: return 1 else: return x * fact(x-1)def half_fact(x): return fact(x / 2)&gt;&gt;&gt; fact(2)x = 2x = 1x = 02 Interative Debugging 交互调试（Interative Debugging）再python中通常被等同于是一种叫做REPL: Read-Eval-Print-Loop(读取-求值-打印-循环)的工具，可以近似认为是python的命令行窗口，这种方式可以不用在PyCharm中不断的修改代码并运行，而是直接在命令行窗口中执行命令，具体指令为python3 -i filename.py。 Error Types 本节介绍一些常见的Python报错，用来判断自己的程序出现了什么问题 SyntaxError(语法错误) 出现此类错误表示您运行的文件中有不是有效的Python标准语法，程序中有错误语法或者错别字等 应该试图搜索缺失或多余的括号、if while等语句末尾缺失的冒号，或是开始的声明中却没有包含内容 IndentationError(缩进错误) 出现此类错误表示由于缩进不一致导致语法不正确，或者是因为用错了程序文本编辑器 应该试图搜索一下是否出现混淆空格和Tab的情况、错位情况，或者将自己的程序在一个程序编辑器中打开，还有可能是用错了空格类型（有不止一种空格类型） TypeError: ‘X’ object is not callable…(对象类型不可调用错误) 出现此类错误表示数据X的类型不能被看作函数，在函数过程中调用了一个非函数变量 应该被分配给函数的变量被分配给了非函数，或者局部变量中不包含全局变量里的同名函数 TypeError: … NoneType …(类型错误) 出现此类错误表示在程序不该使用的某处运用了None 事实上表示函数没有返回return语句 NameError or UnboundLocalError(命名错误&amp;非绑定本地错误) 出现此类错误表示Python寻找一个变量名但没找到 检查名称拼写错误，另一种不太常见的情况是在局部框架中对一个全局框架中的变量做了阴影处理（没理解，代码如下）12345678def f(x): return x ** 2def g(x): y = f(x) def f(): return y + x return f Tracebacks 程序返回的报错包括报错本身，返回错误的行数和每行都在进行着什么进程，最近的调用和错误返回将会显示在最底部 牢记基本的报错含义，依次浏览各行检查可能出错的位置。 Exceptions 编程语言中的一种内置机制用于声明和反映异常的地方（这节没听懂） Rasing Exceptions(引发异常) Assert: 最简单常见的引发报错的方式便是断言语句assert，语法为assert&lt;表达式&gt;, &lt;string&gt;，例如：assert False, &#39;Error&#39;会返回AssertionError: Error. 同时由于assert语句会减慢程序运行速度，可以使用python3 -O语句来忽略程序中的所有assert语句（相当于屏蔽了__debug__语句(会返回False) Raise: 感官上就是引发异常并抛出一个报错，格式大概是raise &lt;错误类型(如NameError, TypeError, KeyError(在dictionary中找不到对应的key), RuntimeError(超出运行时间), Exceptions等)&gt; (&#39;报错内容&#39;) Try Statements try语句用来处理异常，具体语法如下:1234try: &lt;try suite&gt;except &lt;出现异常类型&gt; as &lt;命名&gt;: &lt;except suite&gt; try语句的执行规则： 首先执行&lt;try suite&gt;，如果运行一切正常，就不执行异常语句except suite； 如果在执行&lt;try suite&gt;的过程中产生了某种异常，则执行except语句中对应异常类型的except suite语句； try语句的执行不会导致解释器停止工作，只会在特定出现异常情况下执行except操作以下是一个示例：12345678910#一种很常见的做法，当我们试图把一个名称绑定到一个值上但没有成功，就把名称绑定到特定值&gt;&gt;&gt; try:... x = 1 / 0... except ZeroDivisionError as e:... print(&#x27;handling a&#x27;, type(e))... x = 0...handling a &lt;class &#x27;ZeroDivisionError&#x27;&gt;&gt;&gt;&gt; x0 下面这个示例是为了对比以显示出try语句不会使程序停止运行的特性123456789101112131415def invert(x): y = 1 / x print(&#x27;Never print if x is zero.&#x27;) return y def invert_safe(x): try: return invert(x) except ZeroDivisionError as e: print(&#x27;handled&#x27;, e) return 0&gt;&gt;&gt; invert_safe(0)handled division by zero #这里的division by zero是原本1/0的报错0 当输入指令invert_safe(1/0)时，程序不会运行，因为操作数1/0本身遍已经产生了ZeroDivisionError异常 运算符在操作数之前计算，即当&gt;&gt;&gt; inverrrrt_safe(1/0)时，会优先出现NameError: name &#39;inverrrrt_safe&#39; is not defined 当遇到如下嵌套try语句时，经过内部try语句执行后的部分便已经变成了一个没有异常运行良好的程序，所以外层的except suite永远不会被执行(代码如下)1234567&gt;&gt;&gt; try:... invert_safe(0)... except ZeroDivisionError as e:... print(&#x27;handled!&#x27;)...handled division by zero #不会执行外部循环的handled！语句0 Example: Reduce对reduce函数的解释如下： 1234567891011121314151617181920212223242526272829303132333435363738from operator import add, mul, truediv def divide_all(n, ds): try: return reduce(truediv, ds, n) except ZeroDivisionError as e: return float(&#x27;inf&#x27;) def reduce(f, s, initial): #循环 &quot;&quot;&quot;Combine elements of s using f starting with initial &gt;&gt;&gt; reduce(mul, [2, 4, 8], 1) 64 &gt;&gt;&gt; reduce(add, [1, 2, 3, 4], 0) 10 &quot;&quot;&quot; for x in s: initial = f(initial, x) return initial def reduce(f, s, initial): #递归 &quot;&quot;&quot;Combine elements of s using f starting with initial &gt;&gt;&gt; reduce(mul, [2, 4, 8], 1) 64 &gt;&gt;&gt; reduce(add, [1, 2, 3, 4], 0) 10 &quot;&quot;&quot; if not s: return initial else: first, rest = s[0], s[1:] return reduce(f, rest, f(initial, first))&gt;&gt;&gt; divide_all(1024, [2,4,8,0])inf&gt;&gt;&gt; divide_all(1024, [2,4,8])16.0 Lecture 10: TreesBox-and-Pointer Notation 讲了一种指针表示列表元素的方法，有个闭包属性没咋听懂 Slicing 一种对已有列表进行“切片”的操作具体操作请看上面的[[#Examples Lists(List Functions)]] Processing Containing Values 一些遍历列表和目录的内置函数(稍后制表) 函数名 函数用途 示例 sum函数 sum(iterable[, start]) -&gt; value将所给的可迭代变量（如列表）中的数字与start初始值相加（没有默认为0） &gt;&gt;&gt; sum([2, 3, 4]) 9 &gt;&gt;&gt; sum([2, 3, 4], 5) 14 &gt;&gt;&gt; sum([[2, 3], [4]], []) [2, 3, 4] max函数 max(iterable[, key = func]) -&gt; valuemax(a, b, c, ...[, key = func]) -&gt; value输出所给的可迭代变量（如列表）中最大的数字，当给出key function时，调用这个函数来计算最大值 &gt;&gt;&gt; max(range(5)) 4 &gt;&gt;&gt; max(0, 1, 2, 3, 4)4&gt;&gt;&gt; max(range(10), lambda x: 7 - (x-2) * (x-4))3 all函数 all(iterable) -&gt; bool当所提供的可迭代对象（如列表）中所有元素都为True值或列表为空时返回True &gt;&gt;&gt; [x &lt; 5 for x in range(5)] [True, True, True, True, True] &gt;&gt;&gt; all([x &lt; 5 for x in range(5)])True&gt;&gt;&gt; all(range(5))False Trees本质上来说，Tree实际上是一种列表嵌套的表示，即将列表作为其他列表中的元素，称之为数据类型的闭包属性(closure property) 首先介绍了Tree的两种理解方式吧~ 第一种是递归描述(recursive description -&gt; wooden trees): 即每一个树结构都有一个根标签(root label)和若干个枝干(branches)，同时每一个枝干都可以视作为一个子树结构，一个没有枝干的树结构便称之为叶(leaf) 第二种则是亲缘描述(relative description -&gt; family trees): 即树结构上的每一个位置都可以视作一个节点(node)，每个节点所对应的标签(label)都可以是任何值，而每一个节点同时也作为其他节点的父节点或者子节点(parent&#x2F;child) 接下来，是如何让python定义出一个树结构，如果仅用概念抽象表示的话，树应该是这样的1234&gt;&gt;&gt; tree(3, [tree(1), ... tree(2, [tree(1), ... tree(1)])])[3, [1], [2, [1], [1]]] 紧接着，我们来实际在python下通过编写函数来实现构建Tree的过程 首先我们从构造函数Tree， 选择器函数label和 branches 组成。12345678910def tree(label, branches = []): for branch in branches: #引入branch遍历branches列表中的元素 assert is_tree(branch), &#x27;Branches must be trees&#x27; #运用断言函数判断branches中的每一个元素是否也为Tree return [label] + list(branches) #返回时将label值转化为列表，并重新构建一个列表递归除label以外的branches def label(tree): #返回Tree的第一个值，即root label return tree[0] def branches(tree): #返回Tree除第一个以外的值，即branches return tree[1:] 由上方Tree的定义知，只有当树有一个根标签并且所有分支也是树时，树才是结构良好的。is_tree 函数应用于构造函数tree以验证所有分支是否结构良好。1234567def is_tree(tree): if type(tree) != list or len(tree) &lt; 1: #验证一个tree是否不是列表或者是否没有root label return False for branch in branches(tree): if not is_tree(branch): #借助branch遍历branches的每一个元素（枝干）是否为Tree return False return True 同时用is_leaf函数验证Tree是否有分支12def is_tree(tree): return not branches(tree) 具体运行情况如下：12345678910111213&gt;&gt;&gt; t = tree(3, [tree(1), tree(2, [tree(1), tree(1)])])&gt;&gt;&gt; t[3, [1], [2, [1], [1]]]&gt;&gt;&gt; label(t)3&gt;&gt;&gt; branches(t)[[1], [2, [1], [1]]]&gt;&gt;&gt; label(branches(t)[1])2&gt;&gt;&gt; is_leaf(t)False&gt;&gt;&gt; is_leaf(branches(t)[0])True Tree ProcessingExample: Printing Trees","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://binisalegend.github.io/tags/Python/"}]},{"title":"Missing-Semester学习笔记","slug":"Missing-Semester学习笔记","date":"2023-11-08T02:28:04.000Z","updated":"2023-11-08T04:23:20.896Z","comments":true,"path":"2023/11/08/Missing-Semester学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/08/Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本文是一些零散的如命令行、Git、vim的学习笔记","text":"本文是一些零散的如命令行、Git、vim的学习笔记 1. 课程概览与shell使用shell教材部分 shell根据空格分割命令并进行解i析，如果要传入的参数中包含空格，一种方式是应用单双引号，另一种方法是应用转义字符\\进行处理（My\\ Photos） 课程视频部分在shell中导航教材部分 shell中的路径是被分割的目录，在Linux和MacOS中使用 / 分割，而在Windows上是 \\ pwd：获取当前工作目录 cd：切换目录 . 表示当前目录， .. 表示上级目录(在使用cd和ls命令时都可以用) ls：查看指定目录下含有哪些文件 大多数的命令都可以接受标记选项，通常以-&lt;命令字母&gt;的形式表示，例如：123456missing:~$ ls --help-l 使用较长格式列出信息missing:~$ ls -l /home总用量 4drwxr-xr-x 29 binisalegend binisalegend 4096 8月 11 00:05 binisalegend 其中，d表示missing是一个目录，而后面的字母三个为一组。rwx、r-x、r-x分别表示文件所有者(missing)、用户组(user)以及其他所有人所具有的权限：即只有missing作为文件所有者具有可写(write)权限，用户组和其他访问者均只有可读(read)和可执行(execute)权限 其他命令：mv -&gt; 重命名或移动文件、cp -&gt; 拷贝文件、mkdir -&gt; 新建文件夹 如果想了解一个函数或者是指令的输入输出形式和工作信息，可以man &lt;指令&gt;(manual的缩写)，并用q退出 课程视频部分 cd ~可以直接返回到home目录下，cd -可以快速返回到上一步所在的目录 rm &lt;文件路径&gt;：只能删除单个文件；rmdir &lt;文件目录路径&gt;： 删除一个目录(dictionary) 类似mkdir my photos这样的指令会创建两个文件夹分别问my和photos，如果想要创建一个名为my photos的文件夹则需要用双引号引用mkdir &quot;my photos&quot;或者使用转义空格mkdir my\\ photos 在程序间创建连接教材部分 &lt; 文件名 和 &gt; 文件名 可以将程序的输入输出重定义到文件，具体如下：12345678missing:~$ echo hello &gt; hello.txtmissing:~$ cat hello.txthellomissing:~$ cat &lt; hello.txthellomissing:~$ cat &lt; hello.txt &gt; helloooootxtmissing:~$ cat hellooooo.txthello 可以借助 | 将一个程序的输出与另外一个程序的输入联系起来，例如：12missing:~$ ls -l / | tail -n1 #第一个命令输出所包含全部文件夹的详细信息，第二个命令则输出文件中的最后&lt;number&gt;行drwxr-xr-x 2 root root 4096 12月 18 2022 work 课程视频部分 &gt; 相当于在进行一个覆盖操作，而 &gt;&gt; 则是在进行追加操作，具体演示如下： 吐了吐了…老是看到老师在讲课的时候突然命令行里就能出现上一步的命令内容，查了半天发现最后就是一个上键…直接人傻掉，不过也顺便查到了很多常用的linux快捷键：1234561. Ctrl + L：清空终端中所有的内容并返回当前的目录2. Ctrl + C：强制中断某个程序的执行3. Ctrl + D：结束键盘输入（不知道和上面那个有啥区别）4. !!：重复执行上一步的命令5. Ctrl Shift C/V：复制粘贴6. Ctrl + A：快速回到当前行最左一个字符 | 被称作”pipe characater”(管道字符)：将程序的输出放在左侧，将程序的输入放在右侧。这也可以对前面的ls -l / | tail -n1进行解释，即ls -l产生了一个输出，而tail -2则是一个需要输入的命令 一个功能全面又强大的工具教材部分 对于类Unix系统，根用户(root user)几乎不受任何限制，需要应用sudo(super do)命令来执行。而有一些操作是只有根用户才能够进行的，例如向sysfs文件中写入内容 课程视频部分 /sys目录中存放着电脑的各种内核参数，只有root用户才能对这些内核参数进行更改，除去sudo命令之外，我们也可以应用sudo su进入root命令行界面来进行操作与更改 课后练习 touch &lt;新文件名&gt;：本质上是改变一个文件的时间戳（修改时间），也可以新建一个文件 如果直接访问一个文件夹要用完整的路径例如/home/binisalegend/missing/semester，但是实际上发现好像./semester就可以 ~~写入文件的时候可以使用&gt;&gt;来写入文件，暂时看起来的作用是换行 rm -rf &lt;文件路径&gt;：删除文件 在执行文件遇到权限不足的情况时可以用ls -l &lt;文件名&gt;来查看文件权限，然后用 chmod [权限名称] &lt;文件名&gt; 来更改文件权限，其中可读权限为4、可写权限为2、可执行权限为1，即如果想分别设置所有者、用户和其他人的权限为全部、可读可写、可读，则语句为 chmod 764 semester。具体相关细节详见以下 之后的这个问题很有意思，相当于把smester文件执行的内容输出中的一条拷贝到last-modified文件中，具体命令如下：1./semester | grep last-modified &gt; last-modified.txt 可以理解成./semester是运行这个文件，用 | 让后面的grep last-modified同时执行，即注意grep命令抓取last-modified所在的输出并将其添加到last-modified.txt文件中 2. shell工具和脚本 这节教材没看明白(听课一开始也似懂非懂 所以直接听到啥记点啥) shell脚本 赋值语句的表示即为foo=bar，而访问变量中存储的数值的语法即为$foo。值得注意的是，在bash种如果输入命令foo = bar是不能正确执行命令的，因为系统会调用foo并把=和bar作为函数的参数。这是本人第一次遇到在语句中增添空格会导致程序执行失败的例子，务必多加小心 同时要注意双引号&quot;&quot;和单引号&#39;&#39;的区别，即双引号中会访问变量实际存储的数据值，而单引号则会全部保留原有的数据格式(变量不会被转义)，演示如下：1234~/missing$ echo &quot;Value is $foo&quot;Value is bar~/missing$ echo &#x27;value is $foo&#x27;Value is $foo 一种在权限不足的情况下重新尝试命令的方法是运用 !! 命令，即可以在执行某个命令系统提示”Permission denied”后，使用sudo !!来快速运用sudo权限来再一次执行命令 在Linux中Vim文本编辑器中，想要对文本进行修改可以使用”Esc“或者”Ctrl + 【“ 快捷键进入编辑模式（我的不知道为什么好像要再按一下A才能开始编辑），其中-w为保存命令，-wq为保存并退出编辑器 在bash脚本中有很多特殊的参数来表示参数，错误代码和相关变量，其中一些如下： $0 - 脚本名 $1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。 $@ - 所有参数 $# - 参数个数 $? - 前一个命令的返回值 $$ - 当前脚本的进程识别码 $_ - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 使用echo $?检查错误命令时，输出0表示一切正常没有错误，输出1表示前面的命令语句出现了问题，其中true后echo $?返回始终为0，false后始终返回1(这个感觉有点奇怪好像Linux里面true和false是小写) 在bash中也有”或”和”与”运算符，它们都属于短路运算符。其中||或运算符在符号前语句没有0错误代码时(即echo $?返回不为0，语句有问题)便会执行符号后的语句，反之，如果符号前语句错误代码为0，则符号后语句会被短路不会被执行，同时如果错误代码均不为0则不输出且错误代码返回1；而&amp;&amp;与运算符则只在前后错误代码均为0时才会执行语句。示例如下： 可以使用分号在一行中打印多个语句，不管执行什么都会全部执行所有语句：12&gt;&gt;&gt; false ; echo &quot;This will always print&quot;This will always print 我们可以以变量的形式获取一个命令的输出，这种方式通常被称作命令替换(command substitution), 例如： 其中，有一些点值得注意：在扩展字符串的时候记得用双引号而不是单引号，原因详见2.2；同时在调用的时候要使用$ &lt;变量名称&gt;，可以类比一下C语言中格式化赋予变量值的操作。 ^1f484b 同时，还有一种相对冷门的类似特性被称为进程替换(process substitution)。其通过&lt;(&lt;命令语句&gt;)来将执行命令的结果保存到一个临时文件中，同时可以将两个命令所得结果进行串联，例如cat &lt;(ls) &lt;(ls ..)会打印当前文件目录和上级文件目录中的全部内容名称 下面是一组应用命令替换和进程替换的例子：1234567891011121314#/missing/example.shecho &quot;Starting program at $(date)&quot; # date会被替换成日期和时间echo &quot;Running program $0 with $# arguments with pid $$&quot;for file in &quot;$@&quot;; do grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null #grep用于在某个文件中中搜索子字符串 # 如果模式没有找到，则grep退出状态为 1 # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息 if [[ $? -ne 0 ]]; then # -ne表示不等于 echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fi # fi表示循环语句结束done ^4dd971 程序运行后得到： 1234~/missing$ ./example.sh mcd.shStarting program at 2023年 08月 14日 星期一 18:12:03 CSTRunning program ./example.sh with 1 arguments with pid 20563File mcd.sh does not have any foobar, adding one 当我们需要提供形式类似的参数时，可以应用shell的通配(globbing)，它可以基于文件扩展名展开表达式，其中主要包含通配符 * 和 ? 以及大括号 &#123;&#125; 。其中 ?用来匹配一个任意字符，而 * 可以匹配任意个字符；而大括号 &#123;&#125; 可以展开一系列包含一段公共子串的指令，这种方式在批量移动和转换文件时非常方便。以下是一些示例：1234567891011121314151617181920212223convert image.&#123;png,jpg&#125;# 会展开为convert image.png image.jpgcp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath# 会展开为cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath# 也可以结合通配使用mv *&#123;.py,.sh&#125; folder# 会移动所有 *.py 和 *.sh 文件mkdir foo bar# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件touch &#123;foo,bar&#125;/&#123;a..h&#125; # ..表示省略中间的部分，注意不要随意添加空格touch foo/x bar/y# 比较文件夹 foo 和 bar 中包含文件的不同diff &lt;(ls foo) &lt;(ls bar) #流程替换，相当于将两个输出共同存放到一个临时文件中进行储存比较# 输出# &lt; x# ---# &gt; y 同时，脚本并不一定只有在bash中才能使用，我们也可以将其写在诸如python等文件中，通过shebang来为内核提供去运行脚本所需的编辑器位置，这时我们通常要在文件开头第一行使用env命令，通过环境变量搜索来进行定位，例如#!/usr/bin/env python。应用这种方式我们就可以使用任意语言来运行程序了。 shell工具 有时我们在man一个函数时由于其雕有了Linux的官方文件，导致其通常会列出该函数的所有用法，显示过于冗长。因此我们可以应用一个tldr &lt;函数名&gt;来相对更简洁的获取函数的具体应用方式。 在shell中，我们可以借助find命令在仅提供一定模糊信息的情况下来寻找一个文件(夹)所在的位置。其中，-name 用来指定所寻找的文件名；-type 用来指定所寻找的文件类型(如d表示文件夹。f表示文件等)；-path用来指定在何位置路径寻找(可以用* ？等符号来指定有一定相同之处的多个路径)；-mtime用来指定修改时间(如-1表示最后一天修改的文件内容)等。同时，在执行结束find语句后可以应用 -exec 直接执行一些相关的命令。例如find . -m &quot;*.tmp&quot; =exec rm &#123;&#125; \\ 即寻找所有扩展名为tmp格式的文件并且删除。PS: 省流简化版：fd &quot;.*py&quot; 还有另一个查找文件的命令locate &lt;文件名&gt;，会输出所的文件的绝对路径，即简历路径下该文件的索引。同时还可以应用sudo updatedb命令来更新数据库。 在试图获取文件内容时，我们可以应用 grep &lt;要搜索的字符串&gt; &lt;文件名&gt; 函数来执行这个操作，系统会输出包含这个字符串的行；同时我们也可以用 grep -R &lt;要搜索的字符串&gt; &lt;文件目录&gt; 来令程序在整个目录中遍历搜索。还有很多选项如：-C (注意是大写) ：获取查找结果的上下文；-v 将对结果进行反选，也就是输出不匹配的结果。举例来说， grep -C 5 会输出匹配结果前后五行。 同时还有一系列的获取文件内容的方式，例如 rg(ripgrep) &lt;搜索内容&gt; &lt;文件名或者搜索路径&gt; 等，其中rg会以更为清晰明了的形式(颜色突出)展现搜索结果，包括文件名、搜索内容所在的行数 我们还有一系列的来查找执行过的命令的方法，一种常用的方式便是使用上箭头，另一种方式则是应用history &lt;搜索的命令数&gt;命令，同时也可以利用管道结合grep来具有目的性的搜索我们所执行过的指令，即 history &lt;命令数&gt; | grep &lt;相关字符串&gt; 。我们也可以采用 Ctrl + R快捷键来对命令历史记录进行回溯搜索，在按下快捷键后可以通过输入相关字符串来进行精确搜索 自己配置了一个zsh环境，个人感觉很好用吧(至少对于我这种喜欢漂亮窗口字体的人来说很好用)，同时也提供了一系列命令提示和代码高亮的功能，具体配置方法可以看下这几个帖子：zsh 简单介绍 - LiuChengloong - 博客园 (cnblogs.com)使用 Zsh 作为 Ubuntu 的默认 Shell (regding.github.io) 最后是一些相对零散的用来进行快速的列表导航的小工具，例如 ls -R 可以快速产生文件夹内的文件结构，应用 tree 可以以更清楚的方式来展示文件夹内的各种关系等。 课后练习 Linux中以 . 开头的文件为隐藏文件，可以使用 ls -all (ls -a) 命令来显示全部隐藏文件。同时常用的几个命令有：-g 不显示文件的所有者，--human-readable (-h) 可以将文件的大小按照”MB KB GB”这样易读的形式显示出来，-lt 将文件按照访问时间排序并输出详细信息，ls --color=auto 可以根据文件类型显示出不同的颜色(如果在zsh中安装了相关的插件就不需要了)。 首先，这个题一定要用到前面的命令替换[[#^1f484b]]，即以变量的形式获取一个命令的输出，在本题中如 echo &quot;$(pwd)&quot; 可以获取当前的地址。着重理解一下下面这条语句：1cd &quot;$(cat &quot;$HOME/marco_history.log&quot;)&quot; 其中 cd 后以及 cat 后的 &quot;&quot; 均表明要进入的目录是后面这一段（需要执行引号内的命令——双引号），$() 表示命令执行后的内容将会以变量形式调用。还有另一种感觉很神奇的思路：12345678 #!/bin/zsh marco()&#123;export MARCO=$(pwd) &#125; polo()&#123; cd &quot;$MARCO&quot; &#125; 自己理解的大概思路是定义一个储存当前地址的环境变量 NARCO ，然后直接调用 这个其实个人不太理解，从网上查了一下相关的先理解一下题示代码吧，包括[[#^4dd971]]这里也有一样的东西，就是那个 2&gt; 和 &gt;&amp;2 ，原题示代码和相关知识点理解如下：12345678910#!/bin/env zshn=$(( RANDOM % 100 ))if [[ n -eq 42 ]];then echo &quot;Somethong went wrong!&quot; &gt;&amp;2 echo &quot;The error was using magic numbers&quot; exit 1fiecho &quot;Everything went according to the plan&quot; 每个文件在执行后都会产生至少三个文件描述符，分别是：0–标准输入(stdin) 1–标准输出(stdout) 2–标准错误(stderr) 举例来说，假如一个文件夹内只有一个文件hello1.txt，当输入命令 ls &#123;hello1,hello2&#125;.txt 就会报错 ls: 无法访问 &#39;hello2.txt&#39;: 没有那个文件或目录\\nhello1.txt ，这时我们可以使用命令 ls &#123;hello1,hello2&#125;.txt &gt;right.txt 2&gt;wrong.txt ，这样终端中就不会输出内容(因为返回值都重定向到相应的文件中了)，而 cat 两个文件内容分别为 hello1.txt 和 ls: 无法访问 &#39;hello2.txt&#39;: 没有那个文件或目录 。 而 &amp; 是一个描述符，如果1和2前面不加&amp;，会被zsh视作一个普通文件。在这种情况下，(1)&gt;&amp;2 就表示将标准输出重定向到标准错误中去，如果标准错误被定义到例如某个log文件，那么标准输出也被定义到那个log文件中去，终端上看不到任何信息。然后我们可以在理解源代码的基础上思考如何解题了。又是经典的有思路但一行代码写不出来…. 首先要明确的是在一个脚本文件中可以运行另一个脚本并且将其运行结果进行重定向。然后我们可以引入一个计数器 count 初始化为0，应用 echo &gt; out.log 命令清除已有的日志；接下来，因为我们要让程序运行到直到随机数产生42才结束，故我们设置一个无限循环，在循环中让程序不断运行，并将其标准输出和错误都重定向到out.log文件中，当运行出现错误即 $? -ne 0 时推出新循环，返回count。于是我们得出了以下程序，注意zsh中循环的语法，可以替换为for，until等语句：12345678910111213#!/bin/env zshecho &gt; out.logcount=0while true;do ./example1.sh &amp;&gt;&gt; out.log if [[ $? -ne 0 ]];then cat out.log echo &quot;Example1 went wrong after running $count times!&quot; break fidone 这个就不多bb了好吧，直接解释代码就行了，代码如下：1~/missing find . -type f -name &quot;*.html&quot; | xargs -d &#x27;\\n&#x27; tar -cvzf html.zip 管道前面的部分都很好理解，xargs 通俗理解就是可以将一个命令转化传给另一个命令，-d 后面可以指定一个定界符；对于 tar 的解释可以查看这个帖子tar中的参数 cvf,xvf,cvzf,zxvf的区别_tar xvf_想要一百块的博客-CSDN博客，重要的内容如下： 参数： 12345-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 12345-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 –delete 从存档中删除 注意是两个减号。下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 3. 编辑器(Vim)当这一节开始时，我开始意识到，前面的一个我看似理解的指令 vim ~/.zshrc 实际上便是用vim编辑器来编辑一个文件，而此时请自动忽略前面所有关于vim中快捷键的内容，包括切换模式等，她们都是在我不了解vim的时候擅自使用后产生的一些自我理解，忘掉他们！Then we start…PS: 以下内容大部分都可以通过 vimtutor 来进行练习 Vim的哲学Vim的思路是，在进行编程时将手从键盘移动到鼠标是一种极其繁琐费时的操作，所以在Vim中所有操作都可以通过键盘来实现。因为用的不太熟练，也不明白原理，所以把可能每次都需要配置一下的命令记录在这里，可以把Esc和Ctrl键重定义到CapsLock键（借用了这位大佬的思路将 Caps Lock 映射为 Escape 和 Ctrl | weirane’s blog (ruo-chen.wang)）： 1234#将CapsLock定义为Ctrlsetxkbmap -option ctrl:nocaps#将CapsLock定义为Escxcape -e &#x27;Control_L=Escape&#x27; 编辑模式vim编辑器中通常处在标准模式(normal)，还有一系列其他的模式如插入模式(insert): 用来编辑插入代码(i)、替换模式(replace): 用于覆盖文本，将前面的代码向前推(R)、一般可视化模式(visual)(V)、可视化行模式(visual-line)(shift + V)、可视化块模式(visual-block)(Ctrl + V)、命令行模式(command-line)(:)等。(返回normal模式时按下Esc) 基本操作这其中的一大部分操作是通过命令行模式(command-line)来实现的，即在标准模式下按下 : 后输入命令。可以将其类比成上两节中的shell，只不过这个命令行窗口属于vim。命令行窗口有一系列可执行的命令，例如： 1234567:q(quit) :qa 退出 退出所有窗口:w(write) 保存:wq 保存并退出:help &lt;command&gt; 显示对command的帮助文档:e &lt;filename&gt; 打开要编辑的文件:ls 打开现在已经打开的文件列表（缓存）:sp 将同一个文件(缓冲区)在上下两个窗口中打开 Vim接口作为编程语言的一些特性vim正常情况下处于标准模式，在标准模式下，有很多快捷键可以让我们很方便快捷的对文件进行移动、检索、编辑等一系列操作，具体的一些实例如下：(救命心态真的会崩太多了沃日) 移动命令123456789101112h j k l: 左下上右移动光标w: 将光标移动到下一个单词b: 将光标向前移动到单词开头e: 将光标移动到单词末尾0 $: 将光标移动到行首和行末^: 将光标移动到一行中第一个非空字符Ctrl + U/D: 将整个页面向上或向下翻动gg/G: 移动到整个文件的第一行和最后一行L M H: 将光标移动到当前显示界面的最下方/中间和最上方f/F&lt;字符&gt; t/T&lt;字符&gt;: 寻找到在当前光标所在位置之前/之后的第一个所求字符，f在其之上，t在其之前/后/: 进行搜索 使用N/n分别进行向上和向下的查找%: 用来找到如中括号等符号所对应的另一半 编辑命令123456i：插入命令，在当前位置切换到Insert模式，可以插入字符O/o：在光标所在行上/下新建一行，并切换到输入模式x：删除光标所在当前字符r/R + &lt;替换字符&gt;：用替换字符对一个或多个字符进行替换u/Ctrl+R：撤销，分别等同于Ctrl+Z和Ctrl+Shift+Z~：可以将小写字母转换为大写字母(可结合可视化模式使用) 以下的四个常用命令都可以结合可视化模式(Visual Mode)来进行，分别用v、V和Ctrl+V来进入基本、行和可视化块模式，并结合移动键来更便捷的实现选中操作。123d + &lt;移动命令&gt;：删除(如dw表示删除一个单词，de表示删除到这个单词的末尾，dd表示删除整行)c + &lt;移动命令&gt;：基本和上面命令效果相同，只是删除之后进入插入模式y&amp;p + &lt;移动命令&gt;: 操作方式与上面相同，分别表示复制和粘贴 计数命令以上命令都可以结合数字来确定一个命令执行的次数。例如4j表示向下移动四行，3e向前移动三个单词，7dw表示删除7个单词等。有用的一点是vim中左侧标出了其他行与当前的差值行数，就可以根据这个应用&lt;number&gt; j/k来进行快速导航了。 修饰命令修饰符主要有 i 和 a ，分别表示“在内“和”周围“的含义。以下是一些示例：123ci( : 改变当前括号内的内容di[ : 删除方括号内的内容da&#x27; : 删除一个单引号字符串，包括周围的单引号 demo示例 可以借助 G 命令快速跳转文件的最后一行以添加新的内容 借助 / 搜索命令可以快速跳转到你想编辑的位置 e 移到词末，w 向前移动一个单词，$ 移到行末等命令在定位并修改一些细小错误中非常有用 . 可以重复执行刚刚进行过的编辑命令等 4. 数据整理^cd331a 破防了破防了家人们谁懂啊，真的这节课就感觉一个字没听懂我真的服辣(50分钟的课我听了37分钟我甚至不知道我该从哪里记起)，没办法，放链接吧…视频链接：Lecture 4: Data Wrangling (2020) - YouTube教材链接：数据整理 · the missing semester of your cs education (missing-semester-cn.github.io) 哦莫，Java课讲这个了，这下不得不听了（睡），移步那边吧~[[Java程序设计笔记#^b2609e]] 5. 命令行环境任务控制(Job Control)结束进程当我们在命令行环境中按下 Ctrl + C，shell会为我们打断一个正在进行的进程。深层来讲，终端会向程序发送一个 SIGINT --&gt; signal interrupt 信号告诉程序自行停止。我们可以通过 man signal 指令来查看这些信号以及其对应的数字表示符和简短的描述。我们可以使用以下代码来简单验证一下两个信号指令 SIGINT 和 SIGQUIT ： 123456789101112#!/usr/bin/env pythonimport signal, timedef handler(signum, time): print(&quot;\\nI got a SIGINT, but I am not stopping&quot;)signal.signal(signal.SIGINT, handler)i = 0while True: time.sleep(.1) print(&quot;\\r&#123;&#125;&quot;.format(i), end=&quot;&quot;) i += 1 当我们按下 Ctrl + C 时，代码会捕获SIGINT指令并且返回语句，但是计数程序并不会停止运行；而当我们再次按下 Ctrl + \\ 时，程序并不会捕获到SIGQUIT指令，指令生效后程序会有如下提示并且立即停止： 而对于如下情况，当我们按下 Ctrl + Z 时，相当于终端发送了一个 SIGTSTP(Terminal Stop) 信号让正在运行的进程停止，但这个程序停止在后台并且可以通过 fg 让它在前台继续运行和 bg 让它在后台继续运行（也就是说可以通过 Ctrl + Z 和 bg 命令一起使用来让一个运行中的进程在后台运行 暂停和后台执行进程jobs 命令可以显示出当前正在运行和后台运行或者暂停的进程数并将它们标号，可以通过 命令 + %&lt;命令编号&gt; 来对某个进程进行操作(调用最近的进程也可以用 $!)在进程命令后加 &amp; 符号也可以让一个进程直接在后台启动运行，这样我们就可以继续在shell的窗口进行一系列其他的操作然而，进入后台的进程依然是这个终端的子进程，也就是在关闭终端的时候这个进程也会被终止，如果想要避免这种情况可以在进程命令前加上 nohup 指令来实现我们也可以用 kill &lt;-SIGHUP&gt; / &lt;-STOP&gt; %&lt;命令编号&gt; 来终止一个进程 终端多路复用(Terminal Multiplexers)像 tmux 这样的终端多路复用器可以让我们分出多个终端窗口，这样我们可以同时与多个shell对话进行交互。 tmux 有三个基本思想分别是 “Sessions Windows Panes –&gt; 会话 窗口 窗格”在shell中直接输入 tmux 命令就可以新建一个tmux会话( 可以通过 tmux new -t &lt;窗口名&gt; 命令来新建一个会话并给tmux会话进行命名)，看起来和我们平时使用的zsh没有什么不同，但我们可以在其中运行一些相关的进程，并通过 Ctrl + B 后再按下 D 来返回到原本的zsh窗口，在zsh中使用 tmux a(ttach) -t &lt;tmux会话名称&gt; 命令来返回到刚刚的tmux会话，也可以在tmux中使用 exit 命令或者是 Ctrl + D 快捷键来彻底退出当前的tmux会话在一个tmux会话中，我们可以使用 Ctrl + B 再按下 C(create) 来新建一个窗口，这个操作相当于tmux为我们新建了一个与shell的对话窗口，我们可以在新的窗口中执行一系列其他命令。同时，我们还可以用 Ctrl + B 再按下 P(privious) || N(next) || &lt;窗口编号&gt; 来进行窗口之间的切换同时，我们可以用 Ctrl + B 再按 &quot; 或者 % 来新建一个窗格，实现类似于上下和左右分屏的效果，可以使用 Ctrl + B 加上上下左右箭头键在一系列窗格中切换。使用 Ctrl + B 再按 Z 可以切换当前面板在全屏和普通模式， Ctrl + B 加上空格键可以在不同窗格排布中切换 别名(Aliases)alias是一种相当于可以自定义快捷键的的指令，可以为一个长命令设置一个别名，它的语法如下： 12alias aliad_name=&quot;command_to_alias arg1 arg2&quot;#注意等号两边没有空格 alias命令可以在很多种情况发挥作用，除了直接定义像 alias gs=&quot;git status&quot; 这样的别名以外，我们还可以对一些我们容易打错的命令来使用它，例如 alias sl=ls ，包括对一个命令进行更加细致的规划如 alias mv=&quot;mv -i&quot; 等等。我们也可以用 alias &lt;别名&gt; 来查看一个别名代表了什么具体内容 配置文件(Dotfiles)很多程序的控制都是通过被称为点文件(Dotfiles)来控制的，例如 ~/.vimrc ~/.zshrc 等， 他们通常是隐藏文件，ls 并不会显示他们我们可以通过对这些文件的编辑和修改来修改相关的配置，例如添加上一小节的alias到bashrc文件中就可以在每次启动bash时都执行相关的命令 (这部分没弄懂)我们还可以通过建立一个dotfiles文件夹来整理所有的配置文件，通过符号链接将他们链接到他们需要的位置，并将其传递到如Github这样的云端，以便我们可以在各种设备上配置我们的终端 远端设备(Remote machines)我们通常使用ssh(safe shell)来远程连接服务器，ssh最基本的运行格式是 1ssh &lt;用户名&gt; @ &lt;主机IP地址&gt; (需要远程执行的命令) 当然，使用这种方式需要我们每次链接都输入密码，这显然有些不太方便，我们可以通过SSH密钥来解决这个问题，首先我们需要让主机产生SSH密钥，然后将产生的密钥传递给远程主机，以我自己的虚拟机为例，具体命令如下： 1234ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519cat .ssh/id_ed25519.pub | ssh &lt;用户名&gt; @ &lt;主机IP地址&gt; tee .ssh/authorized_keys# 我们还可以用以下命令来保存密钥的密码ssh-copy-id &lt;用户名&gt; @ &lt;主机IP地址&gt; 执行完以上命令后，我们就可以直接通过ssh命令连接主机而不用每次都输入密码了我们还可以用一些和本身命令行相近的命令来使他们在ssh使用中生效，例如复制文件命令 123456# tee命令：cat 本地文件 | ssh &lt;用户名&gt; @ &lt;主机IP地址&gt; tee 远端文件# scp命令：scp 本地文件路径 &lt;用户名&gt; @ &lt;主机IP地址&gt;: 远端文件路径#以下是shell原本的命令 做个对照cp notes.md notes.md 如果我们想复制大量文件，则可以使用另一个更好的命令 rsync 1ryscp -avP . &lt;用户名&gt; @ &lt;主机IP地址&gt;:&lt;文件夹名&gt; 我们还可以通过配置文件进行对ssh的自定义配置，文件及其地址为 ~/.ssh/config，例如我们可以通过以下配置来自定义远程主机名，这样我们就不需要在每次连接时输入繁琐的主机名和地址 1234Host &lt;自定义主机名&gt; HostName 主机IP地址 User 用户名 IdentityFile SSH密钥地址 同时，我们在远程连接的主机中如果展开了一个tmux，我们可以在其中运行程序执行命令，并且退出主机远程连接，当我们重新连接时一切都不会有变化 6. 版本控制(Git)版本控制系统是用来追踪源代码或者其他文件或文件夹集合的更改工具，他们有助于追踪某个文件集的修改历史纪录，同时他们也能促进团队协作，因为可以有很多人共同协作更改某个文件集。同时，我们可以查看自己程序的不同版本来对比所出现的问题，可以查看有谁对某个东西提交了更改并且我们自己也可以对这些文件集进行修订；在多种版本控制工具中Git已经成为了最被大众所接受的工具之一 Git的数据模型这一部分主要讲述了Git的工作机制，主要通过关联快照和历史记录建模，以及对象内存寻址的运行机制来实现，这一部分具体请看官方教程文档（中文文档地址：版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)） Git的命令行接口基础 首先我们可以使用git init命令来初始化一个文件夹使其变成一个Git仓库，当我们执行命令以后，系统会在该文件夹中新建一个名为.git的隐藏文件夹用来储存本地磁盘中的存储库(repository)数据 git help &lt;命令名&gt;可以对某个特定命令给出具体解释，类似Linux的 man 命令 当我们输入 git status 命令时可以看到当前仓库的（快照）状态，Untracked files 表示该文件经过了改动或者是新建的，即Git在对比过已有的系统快照后发现了不同，没有进行记录，这时我们可以使用 git add &lt;文件名/文件夹名&gt; 来将这个未被追踪的文件添加到系统快照中接下来，我们可以使用 git commit &lt;-m &quot;备注&quot;&gt; 来将我们所做的改动提交到暂存区中，注意既可以用 -m 命令来在后面直接添加提交备注，也可以跳转到提交界面添加备注，在提交成功后终端会显示提交的信息以及该快照的哈希值（一个Git用来记录文件上传信息的16位数字），我们可以使用 git cat-file -p &lt;hash numbers&gt; 来获取刚刚commit的信息内容（git log 也可以获取暂存日志虽然，这个好像可以输出上传文件中的内容） git add :/ 可以将所有的未追踪文件都添加到系统快照中，git commit -a 可以将所有没有被追踪的文件都添加到缓存区中（原谅某个笨比一次次打超长的文件名…） git log 可以用来获取版本历史纪录，但是老师说这个扁平化的看起来很烦，推荐了一个 git log --all --graph --decorate 来让版本更新记录图标化显示（虽然命令很长且我没看出什么区别，但我相信zsh插件会记住它的） 通常Git会默认创建一个 master 分支作为库中代码开发主要分支，代表着项目的最新快照版本(即最后一次commit)。我们可以将 master 视作一个指向当前提交的指针，当我们继续添加提交时，这个指针也会发生变化来指向新的提交；而在log中提示的 HEAD 则通常表示你现在正在处于的提交状态（通常是最近的提交，如果需要切换可以使用 git check &lt;parts of hash numbers&gt; ，这会将当前工作目录的状态切换回你所指向的提交时的状态，我们可以在最新状态之前对文件或者目录进行修改，但是在返回master目录时checkout会提示报错，此时可以用 -f 命令来强制执行） git checkout &lt;文件名&gt; 是对checkout命令的另一种使用，他会丢弃掉当前对文件所做的一切更改并且将当前文件的状态返回到 HEAD 快照所在的状态 git diff (&lt;hash numbers&gt; &lt;hash numbers&gt;) &lt;文件名&gt; 命令可以查看修改前后的不同之处，包括在不同工作目录下对文件修改前后的不同之处 分支和合并 使用 git branch &lt;新建分支名&gt; 可以查看现有的分支或者新建一个分支，这个新建的分支会指向当前提交的内容，例如如果我们新建一个名为cat的分支，我们再次应用 git log --all --graph --decorate 命令时就会看到当前HEAD仍然会指向原有的master分支，但是在后面会新建一个cat分支（使用 git checkout &lt;分支名&gt; 可以切换到新的分支，同时会发现此时HEAD指向了我们新建的分支，所显示的内容是master分支的最新提交内容） git commit 中可以应用 :x 命令来快速上交暂存备注 git branch -vv 以非常详细的方式展现已有的分支信息 不理解这个为什么不能早点教，害我一直看着很长一段log发愁：git log --all --graph --decorate --oneline 可以在一行中显示暂存日志，基本上是只显示哈希码和后面的暂存提交备注 当我们在一个分支中对某个程序进行了修改，再使用 git checkout &lt;分支名&gt; 切换回其他分支时会发现发刚刚作出改动的内容并不会显示在当前的工作目录中，这样我们就可以实现在并行的开发线中来回跳转 可以应用 git branch &lt;分支名&gt; ; git checkout &lt;分支名&gt; 来实现新建一个分支并且跳转到新建的工作表目录中去，简化版命令是 git check -b &lt;分支名&gt; （盲猜-b全拼是-branch） 当我们在多个分支工作目录中对代码进行改动后，我们同通常会需要将功能进行合并，这是我们可以先切换回master分支中，应用 git merge &lt;分支名&gt; ... 来将不同分支中的内容进行合并，指向master的指针HEAD会指向master和cat，前后对比图如下：在执行合并操作的时候，Git可能会对一些合并不是太灵敏，这时会出现合并冲突问题（merge conflict），这是需要我们手动在文件中进行符合我们预期的修订后重新add更改，然后执行 git merge --continue 命令继续执行合并操作 远程操作实际上，对于Git的远程操作主要是为了能够和他人一起协作，以及将自己的本地储存库上传到像GitHub、gitee等云端仓库 git remote 命令可以查看当前所有已经连接的远程仓库 git remote add &lt;远程连接名&gt; &lt;远程仓库http地址&gt; 可以远程连接一个新的仓库 git push &lt;远程连接名&gt; &lt;local branch&gt; : &lt;remote branch&gt; 用来将本地仓库推送到远程仓库中去，当我们仅将一个本地分支推送到基本固定的一个远程仓库分支时，可以使用 git branch --set-upstream-to=&lt;远程仓库名&gt;/&lt;分支名&gt; 可以配置一个固定的本地和远程分支连接，这样下次我们只需要使用 git push 即可完成推送工作 git clone &lt;URL&gt; &lt;要复制到的文件夹&gt; 可以从远端仓库下载内容到本地 git fetch 可以从远端获取对象、索引、推送记录等信息，检索对远端存储库的更改并且将这些信息保存到本地计算机中；同时还有一个命令 git pull 可以等同于命令 git fetch; git merge ，即从远端拉取内容并且与本地分支进行合并 撤销操作git commit --amend 可以重新编辑提交的内容和信息git restore 可以撤销在工作区中的很多操作git checkout &lt;文件名&gt; 可以丢弃在某个文件中所做的修改 一些高级一点的操作git clone --shallow 可以用于当我们要下载一个内容较大的仓库，这样我们就不会保存一系列版本历史记录信息，能更快地从远程仓库拉取到我们本地git add -p &lt;文件名&gt; 让我们可以以交互式的方式来选择具体上传什么，例如我们可以选择只对一处更改进行上传并添加快照；git diff --cached 可以让我们查看到即将上传的修改是什么git blame 可以让我们查看到谁对某行或者某个文件做出了修改，以及相关的一些信息git stash 可以使我们返回到上一个操作我们所处的工作目录状态，暂时移除工作目录下的修改内容；再使用一次 git stash &lt;Filename&gt; 就会取消对文件修改的隐藏操作git bisect: 通过二分查找搜索历史记录，比如跳转到某个时间的提交快照这个个人感觉很有用，可以通过配置 .gitignore 文件来忽略某些文件，例如一些系统文件、程序编译文件等，通过添加文件名或者类似 *.exe* 这类东西来使在查看 git status 时忽略他们 笨狗的小记：如何上传本地文件到github&#x2F;gitee库 初始化：git init：初始化，将一个新文件夹变成git可管理的仓库 连接github库：git remote add github &lt;Github库的https链接&gt;连接gitee库：git remote add gitee &lt;gitee库的https链接&gt; 可以使用 git remote -v 查看已经连接的远程仓库 本地文件修改上传：git status：查看当前文件夹修改的状态 git add &lt;文件名&gt; or &lt;文件路径&gt;：将新增或者删减文件上传到本地暂存库 git commit -m &quot;备注信息&quot;：改动内容上传到本地库 将本地仓库拉取到GitHub：git push -u &lt;远程仓库名称&gt; master：拉取本地库 Tips: git branch：查看库中的分支(前面带*的表示现在正处于的branch) git check &lt;分支名&gt;：切换到其他的分支 可以通过配置 .git/config 文件，通过添加URl来配置远程仓库","categories":[],"tags":[{"name":"杂技学习","slug":"杂技学习","permalink":"https://binisalegend.github.io/tags/%E6%9D%82%E6%8A%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java程序设计学习笔记","slug":"Java程序设计学习笔记","date":"2023-11-07T15:58:22.000Z","updated":"2023-11-08T03:32:08.051Z","comments":true,"path":"2023/11/07/Java程序设计学习笔记/","link":"","permalink":"https://binisalegend.github.io/2023/11/07/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"本篇文章是BIT人工智能专业的限选课Java语言程序设计相匹配的学习笔记","text":"本篇文章是BIT人工智能专业的限选课Java语言程序设计相匹配的学习笔记 Class1如果一个类被声明为 public 那么当前文件名必须与其相同，这并不是说java程序中只能包含一个类，只是只能包含一个共有类 public classJava程序从 main 开始执行，且 main 方法声明必须是共有且静态的 public staticSystem(类名).out(类字段).println(标准输出对象方法)() 可以直接打印一个空行 转义字符 字符 转义字符 字符 \\\\ 反斜杠 \\f 换页 \\b 退格 \\t 跳出一个Tab \\r 回车 \\n 换行 \\&quot; 双引号 \\&#39; 单引号 Java类中的核心包以 java 开头（无需引用即可直接使用，如 System），扩展包以 javax 开头，第三方包以反写网址开头(如 com.exanple表示 www.example.com 的包) 以下是一个包含多个类的程序，以此演示调用静态和实例类型类的不同1234567891011121314151617181920212223242526272829/** MultipleClassesJavaProgram.java */class Class1&#123; public int outputInt(int x) &#123; return 1024 + x; &#125;&#125;class Class2&#123; public static void printInfo() &#123; System.out.println(&quot;调用Class2的printInfo方法&quot;); &#125;&#125;public class MultipleClassesJavaProgram&#123; public static void main(String[] args) &#123; Class1 c1 = new Class1(); Class2.printInfo(); int v1 = c1.outputInt(6); System.out.println(&quot;调用了Class1的main方法&quot;); System.out.printf(&quot;%d\\n&quot;, v1); System.exit(0); &#125;&#125; 即静态类可以直接调用类函数，而实例类需要先实例化一个变量，再对变量进行赋值操作（可以看一下[[CS61B学习笔记#^9a36d4]] Class2Lesson3: Java程序设计语法基础 利用关键词 final 声明常量相当于 public 一个 const 类型变量，如果常量仅在本类使用就要定义为 private 类型 enum 为枚举类型，具体调用方法有 &lt;枚举变量&gt;.&lt;变量名&gt; = &lt;枚举变量&gt;.枚举元素 (如Size s = Size.SMALL) 或 Size t = Size.valueOf(&quot;SMALL&quot;) ，也可以通过类似 MyEnum &lt;变量名&gt; : MyEnum.values() 来遍历枚举中的元素 JOptionPane.showInputDialog 可以在显示的输入框中显示我们想显示的内容，同时可以使用 JOptionPane.showMessageDialog(Component parentComponent, Object message, String title, int messageType) 来控制输出形式，具体的可以看看官方文档 数据类型转化中精度问题： Integer.parseInt() 可以将字符串类型变量转化为整型变量，而 String.valueOf(variable) 则可以将变量转化为字符串类型，结合 write 方法可以将内容输出到终端 Java中可以直接将 String + 其他类型变量 ，最终输出的是一个 String 类型变量 Lesson4: Java中的方法 在调用类似 Math 库时可以使用 import static java.lang.Math.*; 命令，使得在代码中只写静态方法名而省略函数名 对于较大数的运算可以考虑用 BigInteger 变量，相比于 double BigDecimal 能避免精度丢失问题注意 BigInteger 的运算方式要调用 .add .multiply 等方法来进行 在Java中将一个方法放入类中，相当于C语言中定义一个函数，具体的语法格式为12345访问权限 [static] 返回值类型 方法名(参数列表)&#123; return 表达式&#125; 生成随机数的一个惯用语句：Random ran = new Random(System.currentTimeMills());,这个语句使用当前时间作为“种子”来生成随机数 从JDK5.0开始，Java支持可变参数，基本代码如 &lt;variables class&gt;... &lt;variables name&gt;,注意当函数具有多个参数时，可变参数只能放在所有参数的最后（放前面识别不出来结束）在调用可变参数方法时系统自动为可变参数创造一个数组，在函数中以数组形式调用可变参数 对于 System.out.println() 可以输出不同类型参数，实际上调用了 write(String.valueOf(&lt;variable&gt;)) 来将不同变量转化为String类型，再由write方法输出到终端 看PPT突然发现读取输入的另一种方式 int x = Integer.parseInt(args[0]); 可以直接读取第一行的数据（尤其是对于只有一个数输入的情况很好用） 在这里就已经能发现引用类内方法的迹象了 Class ClassName = new Class() ,具体的解释在[[#^bea8b9]] 计算机不能精确的比较浮点数，因此在执行 0.00001 == 0.00000000000001 时会返回true，因此应该比较其差的绝对值是否在某个范围之内 Math.Abs(i-j) &lt; 1e-10 Lesson5: Java中的类和对象 Java中的类和对象可以理解成每个类都是为了某些特定对象而服务的方法集，在一个类中封装了面向一类对象的处理方法，而面向用户只开放特定的简单接口 编写类的方法如下：1234public/private class class_name&#123; public/private &lt;variable class&gt; variable_name; public/private &lt;return value variable class&gt; function_name(parameter List)&#125; 调用一个自定义类可以使用 Class class_name = new Class() 的语法，在调用类中的具体方法或者变量时使用 class_name.&lt;variable_name&gt;() ^bea8b9 我们在定义一个原始类型的变量时Java会要求立刻显式初始化变量，并且JDK会直接为该变量分配内存，如 int value = 100; ,而当我们声明一个对象类型的变量时系统不会立刻为变量分配内存，而是会让这个对象类型变量初始化为null，即 Class obj = null; ，如果一个对象变量不引用一个真实存在的已定义对象，就必须初始化为null 在对象类型变量的赋值上，对于像如下这种类型的赋值，相当于把other类的指针也指向了obj类型的地址，因此当我们更改other类中的方法或者变量时，会导致obj类型中的变量同时发生改变，这个可以和[[CS61B学习笔记#^14da37]]类比着看123456789101112131415public class test&#123; public static void main(String[] args) &#123; MyClass obj = new MyClass(); MyClass other = obj; other.x = 19; System.out.println(obj.x); &#125;&#125;class MyClass&#123; public int x = 0; private int y = 19;&#125;&gt;&gt;&gt; 19 相似的，在判断两个对象类型变量是否相等时尽量不要用 == ,这样比较的是两个对象的地址是否相同（对于上面那个情况是可以的，但是如果是重新new了一个对象变量就不行了），尽量使用 .equals() 方式来比较(代码在这里ObjectEquals) 对于这个 .equals() 的调用有点没看懂，讲义里写道有重写(override)和重载(overload)两种方式: 重写方式在方法前要加上 @Override 表示此方法是重写 Object 基类的的同名方法（这种以“@”打头的标记被称为“Annotation”），在方法中的对象类型参数为 Object 类型；而如果直接重载 .equals() 方法就不需要附加 @Override 标记，同时由于重载中 .equals() 的父类已经是最顶层的 Object 类，所以参数类型为当前方法所处的类名在代码的这一部分：123 public MyTestClass (int initValue)&#123; Value = initValue;&#125; 以上位于类中的定义被称作类的构造方法（也被称作构造函数），构造方法的名称与类相同，没有返回值；同一个类可以有很多个构造函数，具体的构造函数由参数来区分，并且可以通过 this 来进行相互调用 可以在类中直接使用 &#123;&#125; 将一个字段包裹起来，直接作为这个类的一个字段，作为类的“初始化块”，前面加上 static 就是静态初始化字段 在类中可以定义静态字段 static int total_employee_id，在调用时需要以类名为前缀进行调用（用对象变量也行但不推荐） 代码在这里TestStaticInitializeBlock extends 表示继承，在定义一个类 class &lt;class_name&gt; extends &lt;father_class_name&gt; 表示一个类继承了一个父类的属性，在执行当前新定义类之前一定会先执行父类的初始化；同时，静态初始优先于所有的初始，因此静态初始化模块会优先执行 super 关键字代表当前对象的父类型特征，可以和 this 类比来看，当子类构造方法第一行中没有 super 定义时系统会自动加上无参数的 super() 方法，详细的解释可以看这个帖子Java中super关键字及super()的使用 ^1f05af 类的静态方法只能访问类的静态成员，静态初始化块只执行一次，同时创建子类型的对象时，父类型中的静态初始化块也会被执行 Java中提供了一系列的包装类（引用类型，可以创建相应对象），简单来说就是把基本变量类型首字母大写，具体作用是为基本数据类型提供了一些方法和字段，可以使用 import package.class 来引用一个包，也可以在文件前使用 package &lt;包的路径(把/换成.)&gt; 语句来将类加入到指定的包中在对上述这种进行将类放入自定义包中操作的文件进行编译时，使用 javac -d 文件相对路径 文件名.java 命令，系统会自动按照 package 语句中的路径创建文件夹并将 .class 文件放在文件夹中，但注意执行可执行文件时需要在根目录执行类似这样 java Try.test.Hello 的命令才能偶正确运行 学到了一个新的类：StringBuffer / StringBuilder 可以直接用 .append() .insert() .delete() 来对字符串进行一系列操作 Class3Lesson6: Java程序设计中的字符串 上来就是老生常谈好吧：String 类型比较相同不能使用 == ,用string自带的判定方式 .equals() 来进行判断（Java自带的内存压缩机制导致相同的变量可能被指向同一个地址，而如果 new 一个变量会导致指向一个全新分配的地址，== 比较的不是元素值而是地址，所以会返回 false） compareTo :使用字典法进行比较,返回0表两字串相等,小于返回负值,大于返回正值 这些方法记录在这，用的时候自己查吧(bushi): regionMatches: 比较两字串的某一部分是否相等 startsWith和endsWith: 查询字符串是否以某字符串开始或结尾 indexOf和lastIndexOf: 在字串中查找字符或子串 操作函数 功能函数 功能描述 .substring(StartIndex, EndIndex) 查找字符串中某一段的内容(经典含前不含后) str1.concat(str2) 将str2接到str1后 .replace(OldChar, NewChar) 将旧字符替换为新字符 .trim() 去除头尾空格 .toUpperCase() .toLowerCase() 大小写转换 .getChars(srcstart, srcend, string, strIndex) 获取从指定位置起的子串复制到字符数组中 4. StringBuffer/StringBuilder类的常用使用方法：StringBuilder 相较 StringBuffer 有速度优势 构造方法：StringBuffer string = new StringBuffer(String str) 操作函数 功能函数 功能描述 .capacity() 不另外分配内存情况下 StringBuffer 还能存放的字符个数 .ensureCapacity(int capacity) 明确 StringBuffer 的最小容量 .setLength(int length) 指定 StringBuffer 变量的长度 .charAt(int index) 返回 StringBuffer 中位于 index 位的字符 .setCharAt(int index, char ch) 替换 StringBuffer 中位于 index 位的字符为 ch .getChars(int IndexOfPrevious, int length, char[] str, IndexOfNew) 将 StringBufffer 中的字符片段拷贝到字符数组中 .reverse() 倒转 StringBuffer .append(char[]/String str) 在 StringBuffer 后加上一段字符串 .insert(int index, string/char[] str) 从第 index 位开始插入字符串 .deleteCharAt(int index) &amp; delete(int StartIndex, int EndIndex) 删除 StringBuffer 中的某一个(段)字符 Lesson7: Java中的正则表达式^b2609e PS：当初听[[Missing-Semester学习笔记]]里面[[Missing-Semester学习笔记#^cd331a]]数据整理这一节的时候一点都没听懂，倒是没想到现在还是得学hhh正则表达式：对字符串本身具有特性的形式化表达，用来描述字符串“模式”正则表达式主要由普通字符和元字符(meta character)组成 字串字面量匹配(literal)/abc/匹配“abc”字符串(但不会匹配到像&quot;a bc&quot;的字符串，空格会影响到字串匹配)，但是这样的方式只会匹配到文档中最前面的那个匹配字符串，在命令中选择global模式 /abc/g 可以匹配文档中全部匹配字串 “元字符”匹配 元字符指正则表达式中具有一些特殊含义的字符，主要有 \\ . * + - &#123;&#125; [] ^ $ | ? () : ! = 等，例如 . 代表任意一个单个字符，* 代表任意一段字串 当我们想把元字符当作普通字符使用时，就需要使用 &#39;\\&#39; + 元字符 来对元字符进行转义 其他的特殊字符 要匹配的字符 在正则表达式中应该写… Tab \\t 回车，换行 \\r(代表回车)，\\n(代表换行)，\\r\\n(代表回车换行) ESC \\e ASC码字符 如0xA9要写作:\\xA9 Unicode字符 如4e00要写作：\\u4e00 3. 定义可选字符集合 使用 [ 和 ] 定义字符串中某个位置（注意是单个位置）的“候选字符集合” 例如 [aeiou] 表示搜索这五个字符; gr[ea]t 表示搜索 gret 和 grat，即在第四位是e或a的字符 同时使用 - 可以定义一个字符区间，如 [0-9] 可以表示10个数字，[A-Z] 表示26个大写字母 特例：[50-99] 真实的意义并不表示50-99这个数字区间，而是相当于 [5][0-9][9] 实际上就是0-9的区间；如果要表示50-99则应该分位进行搜索，即 [5-9][0-9] 定义例外字符集合 使用 ^ 定义在某文档中排除的字符，如 see[^mn] 表示排除掉以mn结尾的单词，[^a-z] 表示排除掉所有小写字母 处理特殊的字符对于 ] - ^ \\ 包围在 [] 中有时候需要进行转义，如 /var [[(] [0-9] [\\])]/ 表示数字由 [] 或 () 包围（后边的 ] 为了不与可选字符集合边界混淆需要进行转义） 字符集合的缩写 浅总结一下：小写 d w s 分别表示数字、数字和大小写、空白(包括空格、Tab、回车（\\r）和换行（\\n）)，大写的 D W S 就表示非前面说的字符 处理重复的“贪婪量词” * 表示指定字符重复0次或n词，+ 表示指定字符出现1次或n次，? 表示指定字符出现0次或一次。(注意：如果不加括号的话贪婪量词都只作用于紧跟着的前一个字符) 指定次数的重复使用 &#123;min, max&#125; 来指定重复次数，其中min必填且最小为0，而max可选 如 \\d&#123;4,&#125; 表示最小四位的的数字字串，\\d&#123;4&#125; 表示4位数字字串 注意默认情况下系统会自动匹配尽可能多的字符，而可以使用一种叫“Lazy Expression”的表达方式使其匹配尽可能少的字符—*? &#123;min, max&#125;? +? ??(其实就是重复量词后面加个？) 分组() 把若干个字符当作一个整体进行处理 多选一 使用 | 从多个选项中选择一个进行匹配，左边的选项具有高优先级。如 w(ie|ei)rd 匹配weird和wierd 字符串的开头与结尾 使用 ^ 来指定起始字符，如 ^\\d+[a-z]* 表示以至少一个数字开头，后面接任意个数的小写字母 使用 $ 来指定结束字符，如 ^\\d\\-[a-z]+$ 表示至少以一个小写字母为结尾的字符串，如 5-adfjk!!要注意的是正则表达式默认引擎都是singleline，即对于所行文本只会匹配最开头和最结尾的字符；想要匹配多行首尾字符则需要切换Multline anchors模式!! 处理单词的边界 使用 \\b 和 \\B 来代表单词的边界和非单词的边界，如匹配段落中的所有单词可以使用 \\b\\w+\\b 反向引用 可以使用 \\1 \\2 ... 来引用前面出现过的已经被 () 分组的字符组 由于一般正则表达式引擎都只能处理9个反向引用，我们使用 ?: 来指定某字符组不参与反向引用；如 (?:orange) and (peach) to \\1 会匹配到 orange and peach to peach 而不是 orange and peach to orange 断言 可以使用 ?= 给字符串加上条件判断以影响匹配进程，要注意的点是，?= 后的正则表达式并不会出现在匹配字符串中，他们只用来影响匹配进程 同时，使用判断后能够回到起点的断言，可以对一个字符串根据多个标准进行判断 可以使用 ?! 表示一个“否”断言，如 ?!.*4321 表示不包含4321的字串 使用 ?&lt;= 和 ?&lt;! 可以明确告知正则引擎进行断言回退，如 /(?&lt;=base)ball/ 表示如果发现了ball，就应回退检查其前面是不是base，若是则匹配 Java中对正则表达式的编译(pattern)和匹配(matcher)方法 在 String 类中，matches() 方法可以验证字符串是否符合指定的正则表达式，replaceAll() 方法可以将符合正则表达式的字符串替换为指定的字符串，split() 可以以正则表达式进行分割 如果某正则表达式需要用很多次，则可以先调用java.util.regex包中的 Pattern 类的 compile 方法得到一个“编译后”的 Pattern 对象，再调用其 matcher 方法得到一个 Matcher 对象，对 Matcher 对象调用它的 matches() 方法进行正则表达式验证，模板如下12345678 Pattern expression = Pattern.compile(&quot;...&quot;);String str1 = &quot;...&quot;Matcher matcher = expression.matcher(str1);while (matcher.find()) System.out.println(matcher.group()); Lesson8: Java中的继承、抽象类与接口 继承 指既具有父类的一切特性，同时又具有自己的独有特性，通常称为 IS_A 关系 继承的语法：class &lt;child class&gt; extends &lt;parent class&gt; &#123;&#125;，其中parent class和super class通常指某一类的直接上级，而base class通常指公共的基类 子类自动拥有父类声明为 public 和 protected 的成员，这也是继承特性的体现之一（下附继承条件下类的访问权限表） 声明 访问权限规则 public 外界自由访问 private 外界不可访问 protected 同一包中的子类、派生于同一父类的包的子类都可以访问 default 如果不指明任何权限，默认同一包中的类可以访问 使用继承类时，其实系统都会默认在第一行有一个 super(),而我们可以在第一行使用 super(variables) 来调用父类中参数匹配的其他功能；但无论如何，子类的构造方法在运行之前，必须调用父类的构造方法。 具体可以康康这个[[#^1f05af]] 以 final 声明的类不允许覆盖和更改，可以更加方便的用于多线程环境中 父类与子类之间的关系可以有以下三种： Extends(扩充): 子类中定义的方法在父类中没有同名方法 Override(覆盖&#x2F;重写): 子类和父类定义了完全一样的方法在“+”运算中，当一个变量和String类型变量执行操作时，系统会自动隐式调用其 toString() 方法将其转化为字符串类型变量；默认情况下该方法返回 &lt;class name&gt; + hashnode，而如果需要其输出其他有意义信息则可以在当前类中重写该 toString() 方法 注意一定要和父类方法一模一样！！否则就是重载(overload)了 Overload(重载): 子类和父类的方法名相同，但两者的参数类型或数不一样 抽象类 有abstract修饰的类称为抽象类;在方法前加上abstract就形成了抽象方法 抽象类只定义了什么方法应该存在，不能创建对象，必须派生出一个子类，并在子类中实现其未实现的方法之后，才能使用new关键字创建对象；抽象方法只有方法声明，没有实现代码。例： 1234abstract class person&#123; public abstract String getDesCription();&#125; 抽象类中可以包含非抽象方法和静态变量，即包含抽象方法的类一定是抽象类，但是抽象类中的方法不一定都是抽象方法 抽象类的三种类型 直接定义抽象方法 继承一个抽象父类，但没有包含所有父类中的抽象方法（如果包含了所有抽象方法就可以作为一个子类创建对象了，不再是抽象类） 实现了一个接口，但没有完全包含该接口所包含的抽象方法 抽象类的使用抽象类不能直接创建对象，通常用来引用子类对象，语法格式如下：&lt;abstract class&gt; &lt;abstract class variable&gt; = new &lt;child class from abstract class&gt; 抽象类的作用在我们进行程序设计时，可以先思考项目需要实现什么功能，这些功能步骤就相当于是抽象的行为，即抽象类；然后我们可以再通过继承方法，实现对应更为细致功能的类，以此实现模块化的程序设计 接口 定义一个接口使用关键字 interface，实现一个接口采用关键字 implements;接口的成员函数自动成为public的，数据成员自动成为static和final的。 接口使用语法：接口类型 接口类型的变量 = new 实现了接口的具体类型(); 接口的扩充：使用 extends 继承来扩充已有接口并实现一个新的接口；需要注意的是，实现子接口的类，必须实现“父”“子”接口所定义的所有方法，才能被实例化（即new出一个对象） 接口中定义常量：1234public interface ArrayBound&#123; public static final int lower_bound = 0; public static final int upper_bound = 0;&#125; 以这种方式定义的接口常量，只要被一个类声明实现，就可以直接使用这些常量(变量必须被初始化) 接口可以理解为，面向符合该接口设定类的一组需求 接口与抽象类的区别： 抽象类是一个不完全的类；接口则只表明类有哪些外部特征但不涉及具体实现细节 接口不具备继承特点，只是承诺了外部可调用的方法 一个类可以包含多个接口，但是只能继承一个父类 Lesson9: Java程序设计之多态 多态(polymorphism)：指相同的一条语句在不同的类中进行不同的解释，在不同的运行环境中能够运行出不同的结果 多态的最本质特征即父类（或接口）变量可以引用子类对象（或实现了接口的类），即将子类对象当作基类对象来使用，可以让更一般的对象容纳更具体化的对象：1Parent p = new child(); 基类变量与子类变量之间的赋值 子类对象可以直接赋给基类对象变量 基类对象赋给子类对象变量需要进行变量类型转换，语法为 &lt;child class variable&gt; = (child class)&lt;base class&gt;；可以使用 classA instanceof classB 来判断一个对象是否能转换成指定的类型，转换失败会抛出 ClassCastException 异常 当子类和父类具有同名方法，并且让一个父类变量引用一个子类变量时，具体调用哪个方法取决于对象本身的类型是父类还是子类 如果父类和子类中具有相同的字段，子类中访问方法会访问子类本身的方法，父类中的方法会被隐藏（如果确实需要访问使用 super 关键字）；而如果子类被当作父类使用时则会调用父类中的方法 当多个类实现同一接口中的方法时，针对这些类所创建的对象调用接口所定义的方法时，会分别调用相应的类的具体实现代码。同时，编译器在编译上述代码时采取“滞后绑定”(late bind)方法，即编译器在编译时并不知道调用了哪个方法如果没有进行强制转换，编译器会将所有都识别为父类的方法和字段值，因此在TestPolymorphism示例中输出的 value 值都是父类的100，而当我们进行强制转换后，经反编译我们可以看出编译器会进行 checkcast 操作识别出字符串值的具体归属 使用多态最大的好处即修改程序或是扩充系统时修改代码较少，且对其他代码部分的影响较小面向对象编程的思想就是，先构思过程，再细化每个过程涉及的相关数据，最后再针对具体数据完善对应的操作 小专题之快速幂和矩阵快速算法 快速幂算法基本步骤： 将指数n表示为其二进制形式。例如，将n表示为二进制数 $n &#x3D; b_k * 2^k + b_{k-1} * 2^{k-1} + … + b_1 * 2 + b_0$，其中 $b_i$ 表示二进制位的值（0或1），k 是二进制位数。 初始化一个变量 result 为 1，用于存储最终的计算结果。 从最高位开始，从左向右遍历二进制位。对于每一位 $b_i$，进行以下操作： 如果 $b_i$ &#x3D; 1，将 result 乘以底数（要求的数的幂），即 result &#x3D; result * base。 将底数 base 自乘一次，即 base &#x3D; base * base。 继续遍历下一位，重复步骤3，直到遍历完所有二进制位。 当遍历完所有位后，result 就包含了底数的n次幂的值。 快速幂代码示例1234567891011121314private static int FastNthRoot(int num, int sqrt)&#123; int base = num; int result = 1; while (sqrt &gt; 0) &#123; if ((sqrt&amp;1) == 1) &#123; result *= base; &#125; base *= base; sqrt = sqrt &gt;&gt; 1; &#125; return result;&#125; 矩阵快速乘法(斐波那契数列)： 使用矩阵来表示斐波那契数列关系式 F(n) = F(n-1) + F(n-2) 如下：$$\\begin{bmatrix}F(n) \\F(n-1)\\end{bmatrix}&#x3D;\\begin{bmatrix}1 &amp; 1 \\1 &amp; 0\\end{bmatrix}\\times\\begin{bmatrix}F(n-1) \\F(n-2)\\end{bmatrix}$$ 利用快速幂算法计算矩阵 $\\begin{bmatrix}1 &amp; 1 \\1 &amp; 0\\end{bmatrix}$ 的n-1次幂，结果矩阵的第[0][0]项就是斐波那契数列的第n项 小专题之位运算相关 位运算符号概览 符号 描述 运算规则 &amp; 与(且)运算 两位都为1时才返回1 | 或运算 两位都为0时才返回0 ^ 异或运算 两位相同为0，不同为1 ~ 取反运算 0变1，1变0 &lt;&lt; 左移运算 各二进位全部左移若干位，高位丢弃，低位补0 &gt;&gt; 右移运算 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 2. 按位与 &amp; 运算符 例如：3 &amp; 5 = 0011 &amp; 0101 = 0001, 故 3&amp;5 返回1 用途 清零：将各位与0进行相与操作，均返回为0 判断奇偶：只需根据二进制末位是0还是1来判断，即 if((a&amp;1)==0) 来判断是不是偶数(1的前几位都是0只有最后一位能产生效果) 按位或 | 运算符 例如：3 | 5 = 0011 | 0101 = 0111, 故 3|5 返回7 异或 ^ 运算符 交换律、结合律、自反性均成立 用途 与0相异或值不变 交换两个数(代码示例如下)123456789void Swap(int &amp;a, int &amp;b)&#123; if (a != b) &#123; a ^= b; b ^= a; a ^= b; &#125;&#125; 左移 &lt;&lt; 右移 &gt;&gt; 运算符 左移相当于各二进制位全部左移若干位，左边的位丢弃，右边补0；如 a = 10101110; a = a &lt;&lt; 2 执行操作后相当于 a = 10111000若舍弃的高位不含1，则每左移一位都相当于该数乘2 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃；如 a = a &gt;&gt; 2 执行操作后相当于 a = 00101011(a &gt; 0) 或 a = 11101011(a &lt; 0)操作数每右移一位相当于该数除二 Class4Lesson10: 泛型程序设计 泛型类 使用泛型的目的：限制集合能接收的数据类型，并且避免了类型转换的需要。语法一般为如 ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;(); 相关术语 ArrayList&lt;E&gt; 定义了一个泛型类型，E 称为“类型变量”或“类型参数” ArrayList&lt;Integer&gt; 称为“参数化的类型”，Integer 称为“实际类型参数”。 ArrayList 称为泛型类型 ArrayList&lt;E&gt; 的“原始类型(raw type)” 使用泛型可以减少类的数目，同时能在编译中检查代码中的类型错误 注意：Java7后语法变为：ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); 泛型对象具有自动装箱特性，即如 ArrayList&lt;Integer&gt; IntList = new ArrayList&lt;&gt;(); IntList.add(3); 实际上是按照 IntList.add(Integer.valueOf(3)); 来进行的；int n = IntList.get(0) 将被按照 int n = IntList.get(0).intValue() 来执行。因此在使用泛型类时应尽可能明确数据类型，防止在循环中过多出现装拆箱现象 泛型使用须知： 泛型参数必须是引用类型而不能是基本数据类型，即只能为 Double String Integer 等 不能定义泛型化数组 像 Pair&lt;String&gt;[] strPair = new Pair&lt;String&gt;[10] 是不可接受的 泛型类型不能直接创建实例 泛型类不能继承自 Throwable 类(Java中所有错误或异常的超类)，所以我们也不能直接捕获或抛出泛型类型的异常对象 不能定义静态 static 泛型成员 从泛型类中派生子类 不允许基类中具有泛型参数，即 class MyChild extends MyClass&lt;String&gt; 可以编译但 class MyChild extends MyClass&lt;T&gt; 是错误的 如果继承自泛型类的子类不指定实际类型参数，则泛型参数类型默认为 Object 泛型方法 泛型方法的定义123456789 class ArrayAlg &#123; public static &lt;T&gt; T getMiddle(T[ ] a) &#123; return a[a.length / 2]; &#125; &#125; String[] names = .../*下面的两句代码等价，编译器能自动推断传入参数的实际类型*/ String middle = ArrayAlg.&lt;String&gt;getMiddle(names); String middle = ArrayAlg.getMiddle(names); 泛型类同样可以接收 ... 定义的可变参数类型 泛型的多态特性 泛型多态特性实例12345678910 public class GenericPolymorphism &#123; public static void main(String[] args) &#123; List&lt;Number&gt; nums=new ArrayList&lt;Number&gt;(); nums.add(2); nums.add(3.14); for (Number number : nums) &#123; System.out.println(number.getClass()); &#125; &#125;&#125; 一个值得注意的点是，ArrayList&lt;Number&gt; 对象可以直接赋值给 List&lt;Number&gt; 变量 add() 方法奏效的原因是因为 Integer 和 Double 类都是 Number 类的子类 List&lt;Number&gt; 不是 List&lt;Integer&gt; 的基类型，所以","categories":[],"tags":[{"name":"Java语言学习","slug":"Java语言学习","permalink":"https://binisalegend.github.io/tags/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://binisalegend.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"强化学习","slug":"强化学习","permalink":"https://binisalegend.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://binisalegend.github.io/tags/Python/"},{"name":"杂技学习","slug":"杂技学习","permalink":"https://binisalegend.github.io/tags/%E6%9D%82%E6%8A%80%E5%AD%A6%E4%B9%A0/"},{"name":"Java语言学习","slug":"Java语言学习","permalink":"https://binisalegend.github.io/tags/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]}